[
  {
    "title": "Two Sum",
    "link": "https://www.techiedelight.com/?problem=TwoSum",
    "category": "Array, Sorting",
    "tag": "Hashing",
    "lists": "TopClassic, TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/TwoSum/TwoSum.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array, find a pair with the given sum in it.\r\n\r\n\u00e2\u0080\u00a2 Each input can have multiple solutions. The output should match with either one of them.\r\n\r\nInput : nums[] = [8, 7, 2, 5, 3, 1], target = 10\r\nOutput: (8, 2) or (7, 3)\r\n\r\n\u00e2\u0080\u00a2 The solution can return pair in any order. If no pair with the given sum exists, the solution should return null.\r\n\r\nInput : nums[] = [5, 2, 6, 8, 1, 9], target = 12\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Zero Sum",
    "link": "https://www.techiedelight.com/?problem=ZeroSum",
    "category": "Array",
    "tag": "Hashing",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ZeroSum/ZeroSum.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, check if it contains a contiguous subarray having zero-sum.\r\n\r\nInput : [3, 4, -7, 3, 1, 3, 1, -4, -2, -2]\r\nOutput: true\r\nExplanation: The subarrays with zero-sum are\r\n\r\n[3, 4, -7]\r\n[4, -7, 3]\r\n[-7, 3, 1, 3]\r\n[3, 1, -4]\r\n[3, 1, 3, 1, -4, -2, -2]\r\n[3, 4, -7, 3, 1, 3, 1, -4, -2, -2]\r\n\r\nInput : [4, -7, 1, -2, -1]\r\nOutput: false\r\nExplanation: The subarray with zero-sum doesn't exist.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Zero Sum II",
    "link": "https://www.techiedelight.com/?problem=ZeroSumII",
    "category": "Array",
    "tag": "Hashing",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ZeroSumII/ZeroSumII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find all contiguous subarrays with zero-sum.\r\n\r\nInput : [4, 2, -3, -1, 0, 4]\r\nOutput: {[-3, -1, 0, 4], [0]}\r\n\r\nInput : [3, 4, -7, 3, 1, 3, 1, -4, -2, -2]\r\nOutput: {[3, 4, -7], [4, -7, 3], [-7, 3, 1, 3], [3, 1, -4], [3, 1, 3, 1, -4, -2, -2], [3, 4, -7, 3, 1, 3, 1, -4, -2, -2]}\r\n\r\nInput : [0, 0]\r\nOutput: {[0], [0, 0]}\r\n\r\nInput : [1, 2, 3]\r\nOutput: {}\r\n\r\nNote: Since an input can have multiple subarrays with zero-sum, the solution should return a set containing all the distinct subarrays.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sort Binary Array",
    "link": "https://www.techiedelight.com/?problem=SortBinaryArray",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SortBinaryArray/SortBinaryArray.java",
    "problem": "/* START *//*\r\n\r\nGiven a binary array, in-place sort it in linear time and constant space. The output should contain all zeroes, followed by all ones.\r\n\r\nInput : [1, 0, 1, 0, 1, 0, 0, 1]\r\nOutput: [0, 0, 0, 0, 1, 1, 1, 1]\r\n\r\nInput : [1, 1]\r\nOutput: [1, 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Length Subarray",
    "link": "https://www.techiedelight.com/?problem=MaximumLengthSubarray",
    "category": "Array",
    "tag": "Hashing",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumLengthSubarray/MaximumLengthSubarray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the maximum length contiguous subarray having a given sum.\r\n\r\nInput : nums[] = [5, 6, -5, 5, 3, 5, 3, -2, 0], target = 8\r\nOutput: [-5, 5, 3, 5]\r\nExplanation: The subarrays with sum 8 are [[-5, 5, 3, 5], [3, 5], [5, 3]]. The longest subarray is [-5, 5, 3, 5] having length 4.\r\n\r\nNote: Since an input can contain several maximum length subarrays with given sum, the solution should return any one of the maximum length subarray.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shift Matrix",
    "link": "https://www.techiedelight.com/?problem=ShiftMatrix",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ShiftMatrix/ShiftMatrix.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix, shift all its elements by `1` in spiral order.\r\n\r\nInput:\r\n\r\n[\r\n\t[ 1,  2,  3,  4, 5],\r\n\t[16, 17, 18, 19, 6],\r\n\t[15, 24, 25, 20, 7],\r\n\t[14, 23, 22, 21, 8],\r\n\t[13, 12, 11, 10, 9]\r\n]\r\n\r\nOutput:\r\n\r\n[\r\n\t[25,  1,  2,  3, 4],\r\n\t[15, 16, 17, 18, 5],\r\n\t[14, 23, 24, 19, 6],\r\n\t[13, 22, 21, 20, 7],\r\n\t[12, 11, 10,  9, 8]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Largest Subarray",
    "link": "https://www.techiedelight.com/?problem=LargestSubarray",
    "category": "Array",
    "tag": "Hashing",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LargestSubarray/LargestSubarray.java",
    "problem": "/* START *//*\r\n\r\nGiven a binary array containing 0\u00e2\u0080\u0099s and 1\u00e2\u0080\u0099s, find the largest contiguous subarray with equal numbers of 0\u00e2\u0080\u0099s and 1\u00e2\u0080\u0099s.\r\n\r\nInput : [0, 0, 1, 0, 1, 0, 0]\r\nOutput: [0, 1, 0, 1] or [1, 0, 1, 0]\r\n\r\nInput : [0, 0, 0, 0]\r\nOutput: []\r\n\r\nNote: Since an input can contain several largest subarrays with equal numbers of 0\u00e2\u0080\u0099s and 1\u00e2\u0080\u0099s, the code should return any one of them.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Product Pair",
    "link": "https://www.techiedelight.com/?problem=MaximumProductPair",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumProductPair/MaximumProductPair.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find a pair with the maximum product in it.\r\n\r\nEach input can have multiple solutions. The output should match with either one of them.\r\n\r\nInput : [-10, -3, 5, 6, -2]\r\nOutput: (-10, -3) or (-3, -10) or (5, 6) or (6, 5)\r\n\r\nInput : [-4, 3, 2, 7, -5]\r\nOutput: (3, 7) or (7, 3)\r\n\r\nIf no pair exists, the solution should return null.\r\n\r\nInput : [1]\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Derive Strings",
    "link": "https://www.techiedelight.com/?problem=DeriveStrings",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/DeriveStrings/DeriveStrings.java",
    "problem": "/* START *//*\r\n\r\nCheck if a given string can be derived from another string by circularly rotating it. The rotation can be in a clockwise or anti-clockwise rotation.\r\n\r\nInput: X = \"ABCD\", Y = \"DABC\"\r\nOutput: true\r\nExplanation: \"DABC\" can be derived from \"ABCD\" by right-rotating it by 1 unit\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rotated Palindrome",
    "link": "https://www.techiedelight.com/?problem=RotatedPalindrome",
    "category": "String",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RotatedPalindrome/RotatedPalindrome.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, check if it is a rotated palindrome or not.\r\n\r\nInput: \"CBAABCD\"\r\nOutput: true\r\nExplanation: \"CBAABCD\" is a rotation of the palindrome \"ABCDCBA\"\r\n\r\nInput: \"BAABCC\"\r\nOutput: true\r\nExplanation: \"BAABCC\" is a rotation of the palindrome \"ABCCBA\"\r\n\r\nInput: \"DCABC\"\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rotate Matrix",
    "link": "https://www.techiedelight.com/?problem=RotateMatrix",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RotateMatrix/RotateMatrix.java",
    "problem": "/* START *//*\r\n\r\nGiven an `N \u00c3\u0097 N` integer matrix, rotate the matrix by 90 degrees in a clockwise direction. The transformation should be done in-place and in quadratic time.\r\n\r\nInput:\r\n\r\n[\r\n\t[1,  2,  3,  4],\r\n\t[5,  6,  7,  8],\r\n\t[9,  10, 11, 12],\r\n\t[13, 14, 15, 16],\r\n]\r\n\r\nOutput:\r\n\r\n[\r\n\t[13, 9,  5, 1],\r\n\t[14, 10, 6, 2],\r\n\t[15, 11, 7, 3],\r\n\t[16, 12, 8, 4]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rotate Matrix II",
    "link": "https://www.techiedelight.com/?problem=RotateMatrixII",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RotateMatrixII/RotateMatrixII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `N \u00c3\u0097 N` integer matrix, rotate the matrix by 180 degrees in a clockwise direction. The transformation should be done in-place in quadratic time.\r\n\r\nInput:\r\n\r\n[\r\n\t[1,  2,  3,  4],\r\n\t[5,  6,  7,  8],\r\n\t[9,  10, 11, 12],\r\n\t[13, 14, 15, 16]\r\n]\r\n\r\nOutput:\r\n\r\n[\r\n\t[16, 15, 14, 13],\r\n\t[12, 11, 10, 9],\r\n\t[8,  7,  6,  5],\r\n\t[4,  3,  2,  1]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Merge Arrays",
    "link": "https://www.techiedelight.com/?problem=MergeArrays",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MergeArrays/MergeArrays.java",
    "problem": "/* START *//*\r\n\r\nGiven two sorted integer arrays, `X[]` and `Y[]` of size `m` and `n` each, in-place merge elements of `X[]` with elements of array `Y[]` by maintaining the sorted order, i.e., fill `X[]` with the first `m` smallest elements and fill `Y[]` with remaining elements.\r\n\r\nInput :\r\n\r\nX[] = [1, 4, 7, 8, 10]\r\nY[] = [2, 3, 9]\r\n\r\nOutput:\r\n\r\nX[] = [1, 2, 3, 4, 7]\r\nY[] = [8, 9, 10]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Merge Arrays II",
    "link": "https://www.techiedelight.com/?problem=MergeArraysII",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MergeArraysII/MergeArraysII.java",
    "problem": "/* START *//*\r\n\r\nGiven two sorted integer arrays `X[]` and `Y[]` of size `m` and `n` each where `m >= n` and `X[]` has exactly `n` vacant cells, merge elements of `Y[]` in their correct position in array `X[]`, i.e., merge `(X, Y)` by keeping the sorted order.\r\n\r\nInput : Two arrays X[] and Y[] where vacant cells in X[] is represented by 0.\r\n\r\nX[] = [0, 2, 0, 3, 0, 5, 6, 0, 0]\r\nY[] = [1, 8, 9, 10, 15]\r\n\r\nOutput: X[] = [1, 2, 3, 5, 6, 8, 9, 10, 15]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Dutch National Flag Problem",
    "link": "https://www.techiedelight.com/?problem=DutchNationalFlagProblem",
    "category": "Array, Sorting",
    "tag": "Algorithm",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DutchNationalFlagProblem/DutchNationalFlagProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven an array containing only 0\u00e2\u0080\u0099s, 1\u00e2\u0080\u0099s, and 2\u00e2\u0080\u0099s, in-place sort it in linear time and using constant space.\r\n\r\nInput : [0, 1, 2, 2, 1, 0, 0, 2, 0, 1, 1, 0]\r\nOutput: [0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Continuous Sequence",
    "link": "https://www.techiedelight.com/?problem=MaximumContinuousSequence",
    "category": "Array",
    "tag": "Sliding Window",
    "lists": "TopClassic, TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumContinuousSequence/MaximumContinuousSequence.java",
    "problem": "/* START *//*\r\n\r\nGiven a binary array, find the index of 0 to be replaced with 1 to get the maximum length sequence of continuous ones. The solution should return the index of first occurence of 0, when multiple continuous sequence of maximum length is possible.\r\n\r\nInput : [0, 0, 1, 0, 1, 1, 1, 0, 1, 1]\r\nOutput: 7\r\nExplanation: Replace index 7 to get the continuous sequence of length 6 containing all 1\u00e2\u0080\u0099s.\r\n\r\nInput : [0, 1, 1, 0, 0]\r\nOutput: 0\r\nExplanation: Replace index 0 or 3 to get the continuous sequence of length 3 containing all 1\u00e2\u0080\u0099s. The solution should return the first occurence.\r\n\r\nInput : [1, 1]\r\nOutput: -1\r\nExplanation: Invalid Input (all 1\u00e2\u0080\u0099s)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Continuous Sequence II",
    "link": "https://www.techiedelight.com/?problem=MaximumContinuousSequenceII",
    "category": "Array",
    "tag": "Sliding Window",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumContinuousSequenceII/MaximumContinuousSequenceII.java",
    "problem": "/* START *//*\r\n\r\nGiven a binary array and a positive integer `k`, return the indices of the maximum sequence of continuous 1\u00e2\u0080\u0099s that can be formed by replacing at most `k` zeroes by ones.\r\n\r\n\u00e2\u0080\u00a2 The solution should return a pair of the starting and the ending index of the maximum sequence.\r\n\u00e2\u0080\u00a2 For invalid inputs, the solution should return null.\r\n\u00e2\u0080\u00a2 In case multiple sequence of continuous 1\u00e2\u0080\u0099s of maximum length exists, the solution can return any one of them.\r\n\r\nInput : nums[] = [1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0], k = 0\r\nOutput: (6, 9)\r\nExplanation: The longest sequence of continuous 1\u00e2\u0080\u0099s is formed by index 6 to 9.\r\n\r\nInput : nums[] = [1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0], k = 1\r\nOutput: (3, 9)\r\nExplanation: The longest sequence of continuous 1\u00e2\u0080\u0099s is formed by index 3 to 9 on replacing zero at index 5.\r\n\r\nInput : nums[] = [1, 1, 1, 1, 1], k = 1\r\nOutput: (0, 4)\r\n\r\nInput : nums[] = [1, 0, 1, 1, 0, 0, 1, 1, 0, 1], k = 1\r\nOutput: (0, 3) or (6, 9)\r\n\r\nInput : nums[] = [], k = 1\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Equilibrium Index",
    "link": "https://www.techiedelight.com/?problem=EquilibriumIndex",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/EquilibriumIndex/EquilibriumIndex.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, return all equilibrium index in it. For an array `A[0..n-1]`, index `i` is an equilibrium index if the sum of elements of subarray `A[0\u00e2\u0080\u00a6i-1]` is equal to the sum of elements of subarray `A[i+1\u00e2\u0080\u00a6n-1]`.\r\n\r\nInput : [0, -3, 5, -4, -2, 3, 1, 0]\r\nOutput: {0, 3, 7}\r\nExplanation: For each index `i` in the output, A[0] + A[1] + \u00e2\u0080\u00a6 + A[i-1] = A[i+1] + A[i+2] + \u00e2\u0080\u00a6 + A[n-1]\r\n\r\nInput : [-7, 3, 7, -3, 1]\r\nOutput: {4}\r\nExplanation: `n-1` is an equilibrium index if A[0] + A[1] + \u00e2\u0080\u00a6 + A[n-2] sums to 0.\r\n\r\nInput : [1, 2, -4, 2]\r\nOutput: {0}\r\nExplanation: 0 is an equilibrium index if A[1] + A[2] + \u00e2\u0080\u00a6 + A[n-1] sums to 0.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Largest Consecutive Subarray",
    "link": "https://www.techiedelight.com/?problem=LargestConsecutiveSubarray",
    "category": "Array",
    "tag": "Hashing",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LargestConsecutiveSubarray/LargestConsecutiveSubarray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the largest contiguous subarray formed by consecutive integers. The subarray should contain all distinct values.\r\n\r\nInput : [2, 0, 2, 1, 4, 3, 1, 0]\r\nOutput: [0, 2, 1, 4, 3]\r\n\r\nIn case the multiple consecutive subarrays of maximum length exists, the solution can return any one of them.\r\n\r\nInput : [-5, -1, 0, 2, 1, 6, 5, 8, 7]\r\nOutput: [-1, 0, 2, 1] or [6, 5, 8, 7]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Majority Element",
    "link": "https://www.techiedelight.com/?problem=MajorityElement",
    "category": "Array",
    "tag": "Algorithm, Hashing",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MajorityElement/MajorityElement.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array of size `n`, return the element which appears more than `n/2` times. Assume that the input always contain the majority element.\r\n\r\nInput : [2, 8, 7, 2, 2, 5, 2, 3, 1, 2, 2]\r\nOutput: 2\r\n\r\nInput : [1, 3, 1, 1]\r\nOutput: 1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Move Zeroes to End",
    "link": "https://www.techiedelight.com/?problem=MoveZeroesToEnd",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MoveZeroesToEnd/MoveZeroesToEnd.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, in-place move all zeros present in it to the end. The solution should maintain the relative order of items in the array and should not use constant space.\r\n\r\nInput : [6, 0, 8, 2, 3, 0, 4, 0, 1]\r\nOutput: [6, 8, 2, 3, 4, 1, 0, 0, 0]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Replace Array Elements",
    "link": "https://www.techiedelight.com/?problem=ReplaceArrayElements",
    "category": "Array",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReplaceArrayElements/ReplaceArrayElements.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, in-place replace each element with the product of every other element without using the division operator.\r\n\r\nInput : [1, 2, 3, 4, 5]\r\nOutput: [120, 60, 40, 30, 24]\r\n\r\nInput : [5, 3, 4, 2, 6, 8]\r\nOutput: [1152, 1920, 1440, 2880, 960, 720]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Bitonic Subarray",
    "link": "https://www.techiedelight.com/?problem=LongestBitonicSubarray",
    "category": "Array",
    "tag": "Algorithm",
    "lists": "TopClassic",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestBitonicSubarray/LongestBitonicSubarray.java",
    "problem": "/* START *//*\r\n\r\nThe Longest Bitonic Subarray (LBS) problem is to find a contiguous subarray of a given sequence in which the subarray\u00e2\u0080\u0099s elements are first sorted in increasing order, then in decreasing order, and the subarray is as long as possible.\r\n\r\nInput : [3, 5, 8, 4, 5, 9, 10, 8, 5, 3, 4]\r\nOutput: [4, 5, 9, 10, 8, 5, 3]\r\n\r\nIn case the multiple bitonic subarrays of maximum length exists, the solution can return any one of them.\r\n\r\nInput : [-5, -1, 0, 2, 1, 6, 5, 4, 2]\r\nOutput: [-5, -1, 0, 2, 1] or [1, 6, 5, 4, 2]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Difference Pair",
    "link": "https://www.techiedelight.com/?problem=MaximumDifferencePair",
    "category": "Array",
    "tag": "",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumDifferencePair/MaximumDifferencePair.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the maximum difference between two elements in it such that the smaller element appears before the larger element. If no such pair exists, return any negative number.\r\n\r\nInput : [2, 7, 9, 5, 1, 3, 5]\r\nOutput: 7\r\nExplanation: The pair with the maximum difference is (2, 9).\r\n\r\nInput : [5, 4, 3, 2, 1]\r\nOutput: -1 (or any other negative number)\r\nExplanation: No pair with the maximum difference exists.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Sum Subarray",
    "link": "https://www.techiedelight.com/?problem=MaximumSumSubarray",
    "category": "Array, DP",
    "tag": "Algorithm",
    "lists": "TopLiked, TopClassic",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumSumSubarray/MaximumSumSubarray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the maximum sum among all its subarrays.\r\n\r\nInput : [-2, 1, -3, 4, -1, 2, 1, -5, 4]\r\nOutput: 6\r\nExplanation: The maximum sum subarray is [4, -1, 2, 1]\r\n\r\nInput : [-7, -3, -2, -4]\r\nOutput: -2\r\nExplanation: The maximum sum subarray is [-2]\r\n\r\nInput : [-2, 2, -1, 2, 1, 6, -10, 6, 4, -8]\r\nOutput: 10\r\nExplanation: The maximum sum subarray is [2, -1, 2, 1, 6] or [6, 4] or [2, -1, 2, 1, 6, -10, 6, 4]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Sum Subarray II",
    "link": "https://www.techiedelight.com/?problem=MaximumSumSubarrayII",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumSumSubarrayII/MaximumSumSubarrayII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find a contiguous subarray within it that has the maximum sum.\r\n\r\nInput : [-2, 1, -3, 4, -1, 2, 1, -5, 4]\r\nOutput: [4, -1, 2, 1]\r\n\r\nInput : [-7, -3, -2, -4]\r\nOutput: [-2]\r\n\r\nIn case multiple subarrays exists with the largest sum, the solution can return any one of them.\r\n\r\nInput : [-2, 2, -1, 2, 1, 6, -10, 6, 4, -8]\r\nOutput: [2, -1, 2, 1, 6] or [6, 4] or [2, -1, 2, 1, 6, -10, 6, 4]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Sum Circular Subarray",
    "link": "https://www.techiedelight.com/?problem=MaximumSumCircularSubarray",
    "category": "Array",
    "tag": "Algorithm",
    "lists": "TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumSumCircularSubarray/MaximumSumCircularSubarray.java",
    "problem": "/* START *//*\r\n\r\nGiven a circular integer array, find a contiguous subarray with the largest sum in it.\r\n\r\nInput : [2, 1, -5, 4, -3, 1, -3, 4, -1]\r\nOutput: 6\r\nExplanation: Subarray with the largest sum is [4, -1, 2, 1] with sum 6.\r\n\r\nInput : [8, -7, -3, 5, 6, -2, 3, -4, 2]\r\nOutput: 18\r\nExplanation: Subarray with the largest sum is [5, 6, -2, 3, -4, 2, 8] with sum 18.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Array",
    "link": "https://www.techiedelight.com/?problem=RearrangeArray",
    "category": "Array",
    "tag": "",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeArray/RearrangeArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, in-place rearrange it such that every second element becomes greater than its left and right elements.\r\n\r\n\u00e2\u0080\u00a2 Assume that no duplicate elements are present in the input array.\r\n\u00e2\u0080\u00a2 The solution should perform single traveral of the array.\r\n\u00e2\u0080\u00a2 In case the multiple rearrangement exists, the solution can return any one of them.\r\n\r\nInput : [1, 2, 3, 4, 5, 6, 7]\r\nOutput: [1, 3, 2, 5, 4, 7, 6] or [1, 5, 2, 6, 3, 7, 4], or any other valid combination..\r\n\r\nInput : [6, 9, 2, 5, 1, 4]\r\nOutput: [6, 9, 2, 5, 1, 4] or [1, 5, 2, 6, 4, 9], or any other valid combination..\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Array II",
    "link": "https://www.techiedelight.com/?problem=RearrangeArrayII",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeArrayII/RearrangeArrayII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, in-place rearrange it such that it contains positive and negative numbers at alternate positions. Assume that all values in the array are non-zero.\r\n\r\n\u00e2\u0080\u00a2 In case the multiple rearrangement exists, the solution can return any one of them.\r\n\r\nInput : [9, -3, 5, -2, -8, -6, 1, 3]\r\nOutput: [9, -3, 5, -2, 1, -8, 3, -6] or [5, -2, 9, -6, 1, -8, 3, -3] or any other valid combination..\r\n\r\n\u00e2\u0080\u00a2 If the array contains more positive or negative elements, the solution should move them to the end of the array.\r\n\r\nInput : [9, -3, 5, -2, -8, -6]\r\nOutput: [5, -2, 9, -6, -3, -8] or [-2, 5, -6, 9, -3, -8] or any other valid combination..\r\n\r\nInput : [5, 4, 6, -1, 3]\r\nOutput: [5, -1, 4, 6, 3] or [-1, 5, 4, 6, 3] or any other valid combination..\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Array III",
    "link": "https://www.techiedelight.com/?problem=RearrangeArrayIII",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeArrayIII/RearrangeArrayIII.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array `A` of size `n`, whose elements lie in the range 0 to `n-1`, in-place rearrange the array such that `A[A[i]]` is set to `i` for every array element `A[i]`. Do this in linear time and without using any extra constant space.\r\n\r\nInput : [1, 3, 4, 2, 0]\r\nOutput: [4, 0, 3, 1, 2]\r\nExplanation:\r\n\r\nA[0] = 1, A[1] becomes 0\r\nA[1] = 3, A[3] becomes 1\r\nA[2] = 4, A[4] becomes 2\r\nA[3] = 2, A[2] becomes 3\r\nA[4] = 0, A[0] becomes 4\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Array IV",
    "link": "https://www.techiedelight.com/?problem=RearrangeArrayIV",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeArrayIV/RearrangeArrayIV.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of positive and negative integers, in-place segregate them in linear time and constant space. The output should contain all negative numbers, followed by all positive numbers.\r\n\r\nInput : [9, -3, 5, -2, -8, -6, 1, 3]\r\nOutput: [-3, -2, -8, -6, 9, 5, 1, 3] or [-3, -2, -8, -6, 9, 5, 1, 3] or any other valid combination.\r\n\r\nInput : [-4, -2, -7, -9]\r\nOutput: [-4, -2, -7, -9] or any other valid combination.\r\n\r\nInput : [2, 4, 3, 1, 5]\r\nOutput: [2, 4, 3, 1, 5] or any other valid combination.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sorted Merge Arrays",
    "link": "https://www.techiedelight.com/?problem=SortedMergeArrays",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SortedMergeArrays/SortedMergeArrays.java",
    "problem": "/* START *//*\r\n\r\nGiven two integer arrays, each of which is sorted in increasing order, merge them into a single array in increasing order, and return it.\r\n\r\nInput: X = [1, 3, 5, 7], Y = [2, 4, 6]\r\nOutput: [1, 2, 3, 4, 5, 6, 7]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sorted Merge Arrays II",
    "link": "https://www.techiedelight.com/?problem=SortedMergeArraysII",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SortedMergeArraysII/SortedMergeArraysII.java",
    "problem": "/* START *//*\r\n\r\nGiven two sorted integer arrays, merge them into a single array in decreasing order, and return it. In other words, merge two sorted arrays from their end.\r\n\r\nInput : X = [1, 3, 5], Y = [2, 6, 7, 10]\r\nOutput: [10, 7, 6, 5, 3, 2, 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Spiral Matrix",
    "link": "https://www.techiedelight.com/?problem=SpiralMatrix",
    "category": "Matrix",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SpiralMatrix/SpiralMatrix.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix, return its elements in spiral order.\r\n\r\nInput:\r\n\r\n[\r\n\t[ 1   2   3   4  5],\r\n\t[16  17  18  19  6],\r\n\t[15  24  25  20  7],\r\n\t[14  23  22  21  8],\r\n\t[13  12  11  10  9]\r\n]\r\n\r\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Spiral Matrix II",
    "link": "https://www.techiedelight.com/?problem=SpiralMatrixII",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SpiralMatrixII/SpiralMatrixII.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number `N`, return an `N \u00c3\u0097 N` spiral matrix containing numbers from 1 to `N \u00c3\u0097 N` in a counterclockwise direction.\r\n\r\nInput: N = 5\r\n\r\nOutput:\r\n[\r\n\t[25, 24, 23, 22, 21],\r\n\t[10, 9,  8,  7,  20],\r\n\t[11, 2,  1,  6,  19],\r\n\t[12, 3,  4,  5,  18],\r\n\t[13, 14, 15, 16, 17]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Spiral Matrix III",
    "link": "https://www.techiedelight.com/?problem=SpiralMatrixIII",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SpiralMatrixIII/SpiralMatrixIII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array containing `N \u00c3\u0097 N` elements, construct an `N \u00c3\u0097 N` matrix from it in spiral order.\r\n\r\nInput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\r\n\r\nOutput:\r\n\r\n[\r\n\t[ 1   2   3   4  5],\r\n\t[16  17  18  19  6],\r\n\t[15  24  25  20  7],\r\n\t[14  23  22  21  8],\r\n\t[13  12  11  10  9]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Palindromic Substring",
    "link": "https://www.techiedelight.com/?problem=LongestPalindromicSubstring",
    "category": "String",
    "tag": "Algorithm",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestPalindromicSubstring/LongestPalindromicSubstring.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find the maximum length contiguous substring of it that is also a palindrome.\r\n\r\nInput: \"bananas\"\r\nOutput: \"anana\"\r\n\r\nInput: \"abdcbcdbdcbbc\"\r\nOutput: \"bdcbcdb\"\r\n\r\nThe longest palindromic substring is not guaranteed to be unique. If multiple longest palindromic substring exists, the solution should return the one which appear first in the string.\r\n\r\nInput: \"abracadabra\"\r\nOutput: \"aca\"\r\nExplanation: There is no palindromic substring in a string \"abracadabra\" with a length greater than 3. There are two palindromic substrings with length 3, namely, \"aca\" and \"ada\". The solution returns \"aca\" as it appears before \"ada\" in the string.\r\n\r\nInput: \"dcabc\"\r\nOutput: \"d\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Repeated Subsequence",
    "link": "https://www.techiedelight.com/?problem=RepeatedSubsequence",
    "category": "String",
    "tag": "Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/RepeatedSubsequence/RepeatedSubsequence.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, check if a repeated subsequence is present in it or not. The repeated subsequence should have a length of 2 or more.\r\n\r\nInput: \"XYBAXB\"\r\nOutput: true\r\nExplanation: String \"XYBAXB\" has XB(XBXB) as a repeated subsequence\r\n\r\nInput: \"XBXAXB\"\r\nOutput: true\r\nExplanation: String \"XBXAXB\" has XX(XXX) as a repeated subsequence\r\n\r\nInput: \"XYBYAXBY\"\r\nOutput: true\r\nExplanation: String \"XYBYAXBY\" has XB(XBXB), XY(XYXY), YY(YYY), YB(YBYB), and YBY(YBYBY) as repeated subsequences.\r\n\r\nInput: \"ABCA\"\r\nOutput: false\r\nExplanation: String \"ABCA\" doesn\u00e2\u0080\u0099t have any repeated subsequence\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Excel Sheet Column Name",
    "link": "https://www.techiedelight.com/?problem=ExcelSheetColumnName",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ExcelSheetColumnName/ExcelSheetColumnName.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number, convert the number to the corresponding Excel column name.\r\n\r\nInput: 1\r\nOutput: \"A\"\r\n\r\nInput: 27\r\nOutput: \"AA\"\r\n\r\nInput: 1001\r\nOutput: \"ALM\"\r\n\r\nNote: Excel supports upto 2^14 columns, i.e. 16,384 columns.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Check Anagram",
    "link": "https://www.techiedelight.com/?problem=CheckAnagram",
    "category": "String",
    "tag": "Hashing",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CheckAnagram/CheckAnagram.java",
    "problem": "/* START *//*\r\n\r\nGiven two strings, determine whether they are anagrams.\r\n\r\nAny word that exactly reproduces the letters in another order is an anagram. In other words, X and Y are anagrams if by rearranging the letters of X, we can get Y using all the original letters of X exactly once.\r\n\r\nInput: X = \"silent\", Y = \"listen\"\r\nOutput: true\r\n\r\nInput: X = \"incest\", Y = \"insect\"\r\nOutput: true\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Interleaving String",
    "link": "https://www.techiedelight.com/?problem=InterleavingString",
    "category": "String",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/InterleavingString/InterleavingString.java",
    "problem": "/* START *//*\r\n\r\nFind all interleavings of given strings that can be formed from all the characters of the first and second string where the order of characters is preserved.\r\n\r\nInput: X = \"ABC\", Y = \"ACB\"\r\nOutput: {\"ACBABC\", \"AABCBC\", \"ACABCB\", \"ABCACB\", \"AACBBC\", \"ABACCB\", \"ACABBC\", \"ABACBC\", \"AACBCB\", \"AABCCB\"}\r\n\r\nInput: X = \"\", Y = \"\"\r\nOutput: {}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Interleaving String II",
    "link": "https://www.techiedelight.com/?problem=InterleavingStringII",
    "category": "Dynamic Programming, String",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/InterleavingStringII/InterleavingStringII.java",
    "problem": "/* START *//*\r\n\r\nGiven three strings, check if the third string is interleaving the first and second strings. In other words, check if third string is formed from all characters of the first and second string, and the order of characters is preserved.\r\n\r\nInput: X = \"AB\", Y = \"CD\", S = \"ACDB\"\r\nOutput: true\r\n\r\nInput: X = \"ABC\", Y = \"DEF\", S = \"ADEBCF\"\r\nOutput: true\r\n\r\nInput: X = \"ABC\", Y = \"ACD\", S = \"ACDABC\"\r\nOutput: true\r\n\r\nInput: X = \"ABC\", Y = \"DE\", S = \"ACBCD\"\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Isomorphic Strings",
    "link": "https://www.techiedelight.com/?problem=IsomorphicStrings",
    "category": "String",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/IsomorphicStrings/IsomorphicStrings.java",
    "problem": "/* START *//*\r\n\r\nGiven two strings, check if they are isomorphic. Two strings, X and Y, are called isomorphic if all occurrences of each character in X can be replaced with another character to get Y and vice-versa.\r\n\r\nNote that mapping from a character to itself is allowed, but the same character may not replace two characters.\r\n\r\nInput: X = \"ACAB\", Y = \"XCXY\"\r\nOutput: true\r\nExplanation: The strings \"ACAB\" and \"XCXY\" are isomorphic as we can map 'A' to 'X', 'B' to 'Y', and 'C' to 'C'.\r\n\r\nInput: X = \"xbxb\", Y = \"Ybyb\"\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Search Sorted Array",
    "link": "https://www.techiedelight.com/?problem=SearchSortedArray",
    "category": "Array, Divide & Conquer",
    "tag": "Algorithm, Binary Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SearchSortedArray/SearchSortedArray.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted integer array and a target, determine if the target exists in the array in logarithmic time. If target exists in the array, the procedure should return the index of it.\r\n\r\nInput: nums[] = [2, 3, 5, 7, 9], target = 7\r\nOutput: 3\r\nExplanation: Element found at 4th (index 3) position\r\n\r\n\u00e2\u0080\u00a2 If there are duplicate elements in the array, the procedure may return any index whose element is equal to the target.\r\n\r\nInput: nums[] = [1, 2, 3, 4, 4, 5, 6, 7], target = 4\r\nOutput: 3 (or 4)\r\nExplanation: Element found at the 4th (index 3) or 5th (index 4) position.\r\n\r\n\u00e2\u0080\u00a2 If the target is not located, the procedure should return -1.\r\n\r\nInput: nums[] = [1, 4, 5, 8, 9], target = 2\r\nOutput: -1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Unbounded Search Sorted Array",
    "link": "https://www.techiedelight.com/?problem=UnboundedSearchSortedArray",
    "category": "Array, Divide & Conquer",
    "tag": "Algorithm, Binary Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/UnboundedSearchSortedArray/UnboundedSearchSortedArray.java",
    "problem": "/* START *//*\r\n\r\nGiven a monotonically increasing function f(x) on positive numbers, find the lowest positive integer x where f(x) > 0. In other words, find a positive number x such that f(i) > 0 for any integer i greater than or equal to x.\r\n\r\nA function is called monotonically increasing if f(x) <= f(y) is true for all x and y, where x <= y. For example,\r\n\r\nInput: f(x) = 2x - 100\r\nOutput: 51\r\nExplanation: f(x) becomes positive for the first time when x = 51.\r\n\r\nInput: f(x) = 3x - 100\r\nOutput: 34\r\nExplanation: f(x) becomes positive for the first time when x = 34.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rotation Count",
    "link": "https://www.techiedelight.com/?problem=RotationCount",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search, Recursive",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RotationCount/RotationCount.java",
    "problem": "/* START *//*\r\n\r\nGiven a circularly sorted array of distinct integers, find the total number of times the array is rotated. You may assume that the rotation is in anti-clockwise direction.\r\n\r\nInput: [8, 9, 10, 2, 5, 6]\r\nOutput: 3\r\n\r\nInput: [2, 5, 6, 8, 9, 10]\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Search Circular Array",
    "link": "https://www.techiedelight.com/?problem=SearchCircularArray",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SearchCircularArray/SearchCircularArray.java",
    "problem": "/* START *//*\r\n\r\nGiven a circularly sorted integer array, search a target element in it. If the target exists in the array, the procedure should return the index of it. If the target is not located, the procedure should return -1. You may assume there are no duplicates in the array, and the rotation is in the anti-clockwise direction.\r\n\r\nInput: nums[] = [8, 9, 10, 2, 5, 6], target = 10\r\nOutput: 2\r\nExplanation: Element found at 3rd (index 2) position.\r\n\r\nInput: nums[] = [9, 10, 2, 5, 6, 8], target = 5\r\nOutput: 3\r\nExplanation: Element found at 4th (index 3) position.\r\n\r\nInput: nums[] = [8, 9, 1, 4, 5], target = 2\r\nOutput: -1\r\nExplanation: Target not found\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "First and Last Occurrence",
    "link": "https://www.techiedelight.com/?problem=FirstAndLastOccurrence",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/FirstAndLastOccurrence/FirstAndLastOccurrence.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted integer array, find the index of a given number's first and last occurrence.\r\n\r\nInput: nums[] = [2, 5, 5, 5, 6, 6, 8, 9, 9, 9], target = 5\r\nOutput: (1, 3)\r\nExplanation: The first and last occurrence of element 5 is located at index 1 and 3, respectively.\r\n\r\n\u00e2\u0080\u00a2 If the target is not present in the array, the solution should return the pair (-1, -1).\r\n\r\nInput: nums[] = [2, 5, 5, 5, 6, 6, 8, 9, 9, 9], target = 4\r\nOutput: (-1, -1)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Count Occurrences",
    "link": "https://www.techiedelight.com/?problem=CountOccurrences",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CountOccurrences/CountOccurrences.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted integer array containing duplicates, return the count of occurrences of a given number.\r\n\r\nInput: nums[] = [2, 5, 5, 5, 6, 6, 8, 9, 9, 9], target = 5\r\nOutput: 3\r\nExplanation: Target 5 occurs 3 times\r\n\r\nInput: nums[] = [2, 5, 5, 5, 6, 6, 8, 9, 9, 9], target = 6\r\nOutput: 2\r\nExplanation: Target 6 occurs 2 times\r\n\r\nInput: nums[] = [5, 4, 3, 2, 1], target = 6\r\nOutput: 0\r\nExplanation: Target 6 occurs 0 times\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Smallest Missing Number",
    "link": "https://www.techiedelight.com/?problem=SmallestMissingNumber",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SmallestMissingNumber/SmallestMissingNumber.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted array of non-negative distinct integers, find the smallest missing non-negative element in it.\r\n\r\nInput: [0, 1, 2, 6, 9, 11, 15]\r\nOutput: 3\r\n\r\nInput: [1, 2, 3, 4, 6, 9, 11, 15]\r\nOutput: 0\r\n\r\nInput: [0, 1, 2, 3, 4, 5, 6]\r\nOutput: 7\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Smallest Missing Number II",
    "link": "https://www.techiedelight.com/?problem=SmallestMissingNumberII",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SmallestMissingNumberII/SmallestMissingNumberII.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array, find the smallest missing positive integer in it.\r\n\r\nInput: [1, 4, 2, -1, 6, 5]\r\nOutput: 3\r\n\r\nInput: [1, 2, 3, 4]\r\nOutput: 5\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Floor and Ceil",
    "link": "https://www.techiedelight.com/?problem=FloorAndCeil",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/FloorAndCeil/FloorAndCeil.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted integer array, find the floor and ceiling of a given number in it. For a given number x, floor(x) is the largest integer in the array less than or equal to x, and ceil(x) is the smallest integer in the array greater than or equal to x.\r\n\r\nThe solution should return the (floor, ceil) pair. If the floor or ceil doesn't exist, consider it to be -1.\r\n\r\nInput: nums[] = [1, 4, 6, 8, 9], x = 2\r\nOutput: (1, 4)\r\nExplanation: The floor is 1 and ceil is 4\r\n\r\nInput: nums[] = [1, 4, 6, 8, 9], x = 6\r\nOutput: (6, 6)\r\nExplanation: The floor is 6 and ceil is 6\r\n\r\nInput: nums[] = [-2, 0, 1, 3], x = 4\r\nOutput: (3, -1)\r\nExplanation: The floor is 3 and ceil doesn't exist\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Search Nearly Sorted Array",
    "link": "https://www.techiedelight.com/?problem=SearchNearlySortedArray",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SearchNearlySortedArray/SearchNearlySortedArray.java",
    "problem": "/* START *//*\r\n\r\nGiven a nearly sorted array such that each of its elements may be misplaced by no more than one position from the correct sorted order, efficiently search a given element in it and return its index.\r\n\r\nAn element at index `i` in a correctly sorted order can be misplaced by the \u00c2\u00b11 position, i.e., it can be present at index `i-1` or `i` or `i+1` in the input array.\r\n\r\nInput: nums[] = [2, 1, 3, 5, 4, 7, 6, 8, 9], target = 5\r\nOutput: 3\r\nExplanation: Target 5 found at index 3\r\n\r\n\u00e2\u0080\u00a2 If there are duplicate elements in the array, the procedure may return any index whose element is equal to the target.\r\n\r\nInput: nums[] = [2, 1, 3, 5, 4, 5, 6, 8, 9], target = 5\r\nOutput: 3 (or 5)\r\nExplanation: Target 5 found at index 3 and 5\r\n\r\n\u00e2\u0080\u00a2 If the target is not located, the procedure should return -1.\r\n\r\nInput: nums[] = [2, 1, 3, 5, 4, 7, 6, 8, 9], target = 10\r\nOutput: -1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Count Ones",
    "link": "https://www.techiedelight.com/?problem=CountOnes",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CountOnes/CountOnes.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted binary array, efficiently count the total number of 1's in it.\r\n\r\nInput: [0, 0, 0, 0, 1, 1, 1]\r\nOutput: 3\r\n\r\nInput: [0, 0, 1, 1, 1, 1, 1]\r\nOutput: 5\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Peak Element",
    "link": "https://www.techiedelight.com/?problem=PeakElement",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search, Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PeakElement/PeakElement.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array `A`, find the peak element in it. An element `A[i]` is a peak element if it's greater than its neighbor(s). i.e.,\r\n\r\n\u00e2\u0080\u00a2 A[i-1] <= A[i] >= A[i+1]\t(for 0 < i < n-1)\r\n\u00e2\u0080\u00a2 A[i-1] <= A[i]\t\t\t(if i = n \u00e2\u0080\u0093 1)\r\n\u00e2\u0080\u00a2 A[i] >= A[i+1]\t\t\t(if i = 0)\r\n\r\n\r\nInput: [8, 9, 10, 12, 15]\r\nOutput: 15\r\n\r\nInput: [10, 8, 6, 5, 3, 2]\r\nOutput: 10\r\n\r\n\u00e2\u0080\u00a2 There might be multiple peak elements in an array, the solution should report any peak element.\r\n\r\nInput: [8, 9, 10, 2, 5, 6]\r\nOutput: 10 or 6\r\n\r\nInput: [8, 9, 2, 5, 6, 3]\r\nOutput: 9 or 6\r\n\r\n\u00e2\u0080\u00a2 If the peak element is not located, the procedure should return -1.\r\n\r\nInput: []\r\nOutput: -1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "K Closest Elements",
    "link": "https://www.techiedelight.com/?problem=KClosestElements",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/KClosestElements/KClosestElements.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted integer array `nums` and two positive integers `k` and `target`, find the `k` closest elements to `target` in the array. Here, `target` may or may not be present in the input array. The solution should return elements in the same order as present in the input array.\r\n\r\nInput : nums[] = [10, 12, 15, 17, 18, 20, 25], k = 4, target = 16\r\nOutput: [12, 15, 17, 18]\r\n\r\n\r\n\u00e2\u0080\u00a2 If `target` is less than or equal to the first element in the input array, the solution should return the first `k` elements.\r\n\r\nInput : nums[] = [2, 3, 4, 5, 6, 7], k = 3, target = 1\r\nOutput: [2, 3, 4]\r\n\r\n\r\n\u00e2\u0080\u00a2 If `target` is more than or equal to the last element in the input array, the solution should return the last `k` elements.\r\n\r\nInput : nums[] = [2, 3, 4, 5, 6, 7], k = 2, target = 8\r\nOutput: [6, 7]\r\n\r\n\r\n\u00e2\u0080\u00a2 In case multiple sets of `k` closest elements exists, the solution should return the first occuring set.\r\n\r\nInput : nums[] = [10, 12, 15, 17, 20, 25], k = 3, target = 16\r\nOutput: [12, 15, 17]\r\nExplanation: There are two k-closest element sets present in the array i.e., [12, 15, 17] and [15, 17, 20]. The solution returns set [12, 15, 17] as it appears before set [15, 17, 20] in the array.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Common Prefix",
    "link": "https://www.techiedelight.com/?problem=LongestCommonPrefix",
    "category": "String, Trie",
    "tag": "Trie",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/LongestCommonPrefix/LongestCommonPrefix.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of strings, find their longest common prefix (LCP).\r\n\r\nInput: [\"technique\", \"technician\", \"technology\", \"technical\"]\r\nOutput: \"techn\"\r\n\r\nInput: [\"techie delight\", \"tech\", \"techie\", \"technology\", \"technical\"]\r\nOutput: \"tech\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Convert Matrix",
    "link": "https://www.techiedelight.com/?problem=ConvertMatrix",
    "category": "Matrix",
    "tag": "",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ConvertMatrix/ConvertMatrix.java",
    "problem": "/* START *//*\r\n\r\nGive an `M \u00c3\u0097 N` binary matrix, change all elements of row `i` and column `j` to 0 if cell (i, j) has value 0.\r\n\r\nInput:\r\n[\r\n\t[1, 1, 0, 1, 1],\r\n\t[1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 0, 1],\r\n\t[1, 1, 1, 1, 1],\r\n\t[0, 1, 1, 1, 1]\r\n]\r\n\r\nOutput:\r\n[\r\n\t[0, 0, 0, 0, 0],\r\n\t[0, 1, 0, 0, 1],\r\n\t[0, 0, 0, 0, 0],\r\n\t[0, 1, 0, 0, 1],\r\n\t[0, 0, 0, 0, 0]\r\n]\r\n\r\nExplanation:\r\n\r\n0\u00e2\u0080\u0099s are present at (0, 2), (4, 0), and (2, 3) in the input matrix. Therefore, every element of the following cells is changed to 0:\r\n\r\n\u00e2\u0080\u00a2 row 0 and column 2\r\n\u00e2\u0080\u00a2 row 4 and column 0\r\n\u00e2\u0080\u00a2 row 2 and column 3\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Convert Matrix II",
    "link": "https://www.techiedelight.com/?problem=ConvertMatrixII",
    "category": "Matrix, Queue",
    "tag": "Breadth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConvertMatrixII/ConvertMatrixII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` matrix of integers whose each cell can contain a negative, zero, or a positive value, determine the minimum number of passes required to convert all negative values in the matrix positive.\r\n\r\nOnly a non-zero positive value at cell (i, j) can convert negative values present at its adjacent cells (i-1, j), (i+1, j), (i, j-1), and (i, j+1), i.e., up, down, left and right.\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[-1, -9,  0, -1,  0],\r\n\t[-8, -3, -2,  9, -7],\r\n\t[ 2,  0,  0, -6,  0],\r\n\t[ 0, -7, -3,  5, -4]\r\n]\r\n\r\nOutput: 3\r\n\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[1, 9, 1],\r\n\t[8, 3, 2],\r\n\t[7, 3, 4]\r\n]\r\n\r\nOutput: 0\r\n\r\n\r\nThe solution should return -1 if conversion is not possible.\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[-1, -9, -1],\r\n\t[-8, -3, -2],\r\n\t[-7, -3, -4]\r\n]\r\n\r\nOutput: -1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Diagonal Matrix Traversal",
    "link": "https://www.techiedelight.com/?problem=DiagonalMatrixTraversal",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DiagonalMatrixTraversal/DiagonalMatrixTraversal.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix, return all its diagonal elements having a positive slope.\r\n\r\nInput:\r\n\r\n[\r\n\t[1, 2, 3, 4, 5],\r\n\t[2, 3, 4, 5, 6],\r\n\t[3, 4, 5, 6, 7],\r\n\t[4, 5, 6, 7, 8],\r\n\t[5, 6, 7, 8, 9]\r\n]\r\n\r\nOutput:\r\n\r\n[\r\n\t[1]\r\n\t[2, 2],\r\n\t[3, 3, 3],\r\n\t[4, 4, 4, 4],\r\n\t[5, 5, 5, 5, 5],\r\n\t[6, 6, 6, 6],\r\n\t[7, 7, 7],\r\n\t[8, 8],\r\n\t[9]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Replace Matrix",
    "link": "https://www.techiedelight.com/?problem=ReplaceMatrix",
    "category": "Matrix",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReplaceMatrix/ReplaceMatrix.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` binary matrix, replace all occurrences of 0\u00e2\u0080\u0099s by 1\u00e2\u0080\u0099s, which are not completely surrounded by 1\u00e2\u0080\u0099s from all sides, i.e., top, left, bottom, right, top-left, top-right, bottom-left, and bottom-right.\r\n\r\nInput:\r\n\r\n[\r\n\t[1, 1, 1, 1, 0, 0, 1, 1, 0, 1],\r\n\t[1, 0, 0, 1, 1, 0, 1, 1, 1, 1],\r\n\t[1, 0, 0, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 0, 0, 1, 1, 0, 1],\r\n\t[1, 1, 1, 1, 0, 0, 0, 1, 0, 1],\r\n\t[1, 1, 0, 1, 1, 0, 1, 1, 0, 0],\r\n\t[1, 1, 0, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 0, 1, 1, 0, 0, 1, 0, 1],\r\n\t[1, 1, 1, 0, 1, 0, 1, 0, 0, 1],\r\n\t[1, 1, 1, 0, 1, 1, 1, 1, 1, 1]\r\n]\r\n\r\nOutput:\r\n\r\n[\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 0, 0, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 0, 0, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 0, 0, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 0, 0, 0, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 0, 0, 1, 0, 1],\r\n\t[1, 1, 1, 1, 1, 0, 1, 0, 0, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Replace Matrix II",
    "link": "https://www.techiedelight.com/?problem=ReplaceMatrixII",
    "category": "Matrix",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReplaceMatrixII/ReplaceMatrixII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` binary matrix, replace all occurrences of 0\u00e2\u0080\u0099s by 1\u00e2\u0080\u0099s, which are completely surrounded by 1\u00e2\u0080\u0099s from all sides (top, left, bottom, right, top-left, top-right, bottom-left, and bottom-right).\r\n\r\nInput:\r\n\r\n[\r\n\t[1, 1, 1, 1, 0, 0, 1, 1, 0, 1],\r\n\t[1, 0, 0, 1, 1, 0, 1, 1, 1, 1],\r\n\t[1, 0, 0, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 0, 0, 1, 1, 0, 1],\r\n\t[0, 0, 1, 1, 0, 0, 0, 1, 0, 1],\r\n\t[1, 0, 0, 1, 1, 0, 1, 1, 0, 0],\r\n\t[1, 1, 0, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 0, 1, 1, 0, 0, 1, 0, 1],\r\n\t[1, 1, 1, 0, 1, 0, 1, 0, 0, 1],\r\n\t[1, 1, 1, 0, 1, 1, 1, 1, 1, 1]\r\n]\r\n\r\nOutput:\r\n\r\n[\r\n\t[1, 1, 1, 1, 0, 0, 1, 1, 0, 1],\r\n\t[1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 0, 1],\r\n\t[0, 0, 1, 1, 1, 1, 1, 1, 0, 1],\r\n\t[1, 0, 0, 1, 1, 1, 1, 1, 0, 0],\r\n\t[1, 1, 0, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 0, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 0, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 0, 1, 1, 1, 1, 1, 1]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Negative Numbers Count",
    "link": "https://www.techiedelight.com/?problem=NegativeNumbersCount",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/NegativeNumbersCount/NegativeNumbersCount.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` row-wise and column-wise sorted integer matrix, find the total number of negative numbers in it in linear time.\r\n\r\nInput:\r\n\r\n[\r\n\t[-7, -3, -1, 3, 5],\r\n\t[-3, -2,  2, 4, 6],\r\n\t[-1,  1,  3, 5, 8],\r\n\t[ 3,  4,  7, 8, 9]\r\n]\r\n\r\nOutput: 6\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Toeplitz Matrix",
    "link": "https://www.techiedelight.com/?problem=ToeplitzMatrix",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ToeplitzMatrix/ToeplitzMatrix.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix, check if it is a Toeplitz matrix or not. A Toeplitz matrix or diagonal-constant matrix is a matrix with each descending diagonal from left to right is constant.\r\n\r\nAny `M \u00c3\u0097 N` matrix `mat` is a Toeplitz matrix if mat(i, j) = mat(i+1, j+1) = mat(i+2, j+2), and so on\u00e2\u0080\u00a6 Here, mat(i, j) denotes the element mat[i][j] in the matrix.\r\n\r\nInput:\r\n\r\n[\r\n\t[3, 7, 0, 9, 8],\r\n\t[5, 3, 7, 0, 9],\r\n\t[6, 5, 3, 7, 0],\r\n\t[4, 6, 5, 3, 7]\r\n]\r\n\r\nOutput: true\r\n\r\nInput:\r\n\r\n[\r\n\t[3, 7, 0, 9, 8],\r\n\t[5, 3, 7, 0, 9],\r\n\t[6, 5, 3, 7, 0],\r\n\t[4, 5, 5, 3, 7]\r\n]\r\n\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Fill Matrix",
    "link": "https://www.techiedelight.com/?problem=FillMatrix",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/FillMatrix/FillMatrix.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` binary matrix, fill it with alternating rectangles of 1\u00e2\u0080\u0099s and 0\u00e2\u0080\u0099s.\r\n\r\nInput: 10 \u00c3\u0097 8 matrix\r\nOutput:\r\n\r\n[\r\n\t[1, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 0, 0, 0, 0, 0, 0, 1],\r\n\t[1, 0, 1, 1, 1, 1, 0, 1],\r\n\t[1, 0, 1, 0, 0, 1, 0, 1],\r\n\t[1, 0, 1, 0, 0, 1, 0, 1],\r\n\t[1, 0, 1, 0, 0, 1, 0, 1],\r\n\t[1, 0, 1, 0, 0, 1, 0, 1],\r\n\t[1, 0, 1, 1, 1, 1, 0, 1],\r\n\t[1, 0, 0, 0, 0, 0, 0, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1]\r\n]\r\n\r\n\r\nInput: 3 \u00c3\u0097 5 matrix\r\nOutput:\r\n\r\n[\r\n\t[1, 1, 1, 1, 1],\r\n\t[1, 0, 0, 0, 1],\r\n\t[1, 1, 1, 1, 1]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Common Elements",
    "link": "https://www.techiedelight.com/?problem=CommonElements",
    "category": "Matrix",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CommonElements/CommonElements.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix, find the common elements present in all rows of the matrix. The solution should traverse the matrix once and return the common elements.\r\n\r\nInput:\r\n[\r\n\t[7, 1, 3, 5, 3, 6],\r\n\t[2, 3, 6, 1, 1, 6],\r\n\t[6, 1, 7, 2, 1, 4],\r\n\t[6, 6, 7, 1, 3, 3],\r\n\t[5, 5, 6, 1, 5, 4],\r\n\t[3, 5, 6, 2, 7, 1],\r\n\t[4, 1, 4, 3, 6, 4],\r\n\t[4, 6, 1, 7, 4, 3]\r\n]\r\n\r\nOutput: {1, 6}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Ones Row",
    "link": "https://www.techiedelight.com/?problem=MaximumOnesRow",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumOnesRow/MaximumOnesRow.java",
    "problem": "/* START *//*\r\n\r\nGiven a binary `M \u00c3\u0097 N` row-wise sorted matrix, find a row that contains the maximum number of 1\u00e2\u0080\u0099s in linear time.\r\n\r\nInput:\r\n[\r\n\t[0, 0, 0, 1, 1],\r\n\t[0, 0, 1, 1, 1],\r\n\t[0, 0, 0, 0, 0],\r\n\t[0, 1, 1, 1, 1],\r\n\t[0, 0, 0, 0, 1]\r\n]\r\n\r\nOutput: 4\r\nExplanation: The maximum 1\u00e2\u0080\u0099s are present in row 4\r\n\r\n\r\nIf multiple rows have same maximum number of 1\u00e2\u0080\u0099s, the solution should return the first row number. If no 1\u00e2\u0080\u0099s are present in the matrix, the solution should return 0.\r\n\r\nInput:\r\n[\r\n\t[1, 1, 1, 1],\r\n\t[1, 1, 1, 1],\r\n\t[1, 1, 1, 1],\r\n]\r\n\r\nOutput: 1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "N Queen Problem",
    "link": "https://www.techiedelight.com/?problem=NQueenProblem",
    "category": "Backtracking, Matrix",
    "tag": "Algorithm, Recursive",
    "lists": "TopClassic, TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/NQueenProblem/NQueenProblem.java",
    "problem": "/* START *//*\r\n\r\nThe N\u00e2\u0080\u0093queens puzzle is the problem of placing `N` chess queens on an `N \u00c3\u0097 N` chessboard so that no two queens threaten each other. Thus, the solution requires that no two queens share the same row, column, or diagonal.\r\n\r\nThe solution should return a Set of the string representation of each possible solution to the N\u00e2\u0080\u0093Queens problem.\r\n\r\nInput: N = 4\r\nOutput:\r\n{\r\n\t'[[0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]',\r\n\t'[[0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 0]]'\r\n}\r\n\r\nHere 1 represents the position of a queen in chessboard. Note that the solution exists for all natural numbers, except for 2 and 3. The solution should return an empty set for N = 2 and N = 3.\r\n\r\nInput: N = 2\r\nOutput: {}\r\n\r\nNote: To get the string representation of a N\u00e2\u0080\u0093Queen's problem solution stored in int[][] or List<List<Integer>>, you can call `Arrays.deepToString()` or `toString()` method, respectively.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Knight Tour Problem",
    "link": "https://www.techiedelight.com/?problem=KnightTourProblem",
    "category": "Backtracking, Matrix",
    "tag": "Recursive",
    "lists": "TopClassic, TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/KnightTourProblem/KnightTourProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a chessboard, return all sequences of moves of a knight on a chessboard such that the knight visits every square only once.\r\n\r\n\u00e2\u0080\u00a2 The solution should start the tour from the top-leftmost of the board, mark it as 1, and use the next numbers to represent the knight's consecutive moves.\r\n\u00e2\u0080\u00a2 The solution should return a Set of the string representation of each possible solution.\r\n\r\nInput: N = 5\r\n\r\nOutput:\r\n\r\n{\r\n\t'[[1, 18, 7, 12, 25], [8, 13, 2, 19, 6], [3, 20, 17, 24, 11], [14, 9, 22, 5, 16], [21, 4, 15, 10, 23]]',\r\n\t'[[1, 10, 21, 16, 7], [20, 15, 8, 11, 22], [9, 2, 23, 6, 17], [14, 19, 4, 25, 12], [3, 24, 13, 18, 5]]',\r\n\t'[[1, 18, 13, 8, 3], [12, 7, 2, 21, 14], [17, 22, 19, 4, 9], [6, 11, 24, 15, 20], [23, 16, 5, 10, 25]]',\r\n\t'[[1, 18, 13, 8, 21], [12, 7, 20, 3, 14], [19, 2, 17, 22, 9], [6, 11, 24, 15, 4], [25, 16, 5, 10, 23]]'\r\n\r\n\t...and 300 more tours.\r\n}\r\n\r\nNote: To get the string representation of a knight tour stored in int[][] or List<List<Integer>>, you can call `Arrays.deepToString()` or `toString()` method, respectively.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Chess Knight Problem",
    "link": "https://www.techiedelight.com/?problem=ChessKnightProblem",
    "category": "Matrix, Queue",
    "tag": "Algorithm, Breadth-First Search",
    "lists": "TopClassic, TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ChessKnightProblem/ChessKnightProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a chessboard, find the shortest distance (minimum number of steps) taken by a knight to reach a given destination from a given source.\r\n\r\nInput:\r\n\r\nN = 8 \t\t\t(8 x 8 matrix)\r\nsrc  = (0, 7)\t(Source coordinates)\r\ndest = (7, 0)\t(Destination coordinates)\r\n\r\nOutput: 4\r\n\r\nExplanation: The minimum number of steps required is 6. The knight's movement is illustrated in the following figure:\r\n\r\nhttps://techiedelight.com/practice/images/Chess-Board.png\r\n\r\n\r\nThe solution should return -1 if the path is not possible.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shortest Path",
    "link": "https://www.techiedelight.com/?problem=ShortestPath",
    "category": "Backtracking, Matrix",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ShortestPath/ShortestPath.java",
    "problem": "/* START *//*\r\n\r\nGiven a maze in the form of a binary rectangular matrix, find the length of the shortest path from a given source to a given destination. The path can only be constructed out of cells having value 1, and at any moment, you can only move one step in one of the four directions (Top, Left, Down, Right).\r\n\r\nInput:\r\n\r\nmatrix = [\r\n\t[1, 1, 1, 1, 1, 0, 0, 1, 1, 1],\r\n\t[0, 0, 1, 0, 1, 1, 0, 1, 0, 1],\r\n\t[0, 0, 1, 0, 1, 1, 1, 0, 0, 1],\r\n\t[1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\r\n\t[0, 0, 0, 1, 0, 0, 0, 1, 0, 1],\r\n\t[1, 0, 1, 1, 1, 0, 0, 1, 1, 0],\r\n\t[0, 0, 0, 0, 1, 0, 0, 1, 0, 1],\r\n\t[0, 1, 1, 1, 1, 1, 1, 1, 0, 0],\r\n\t[1, 1, 1, 1, 1, 0, 0, 1, 1, 1],\r\n\t[0, 0, 1, 0, 0, 1, 1, 0, 0, 1]\r\n]\r\nsrc  = (0, 0)\r\ndest = (5, 7)\r\n\r\nOutput: 12\r\n\r\nExplanation: The shortest path from (0, 0) to (5, 7) has length 12. The shortest path is marked below with x.\r\n\r\n[\r\n\t[x, x, x, x, x, 0, 0, 1, 1, 1],\r\n\t[0, 0, 1, 0, x, 1, 0, 1, 0, 1],\r\n\t[0, 0, 1, 0, x, x, x, 0, 0, 1],\r\n\t[1, 0, 1, 1, 1, 0, x, x, 0, 1],\r\n\t[0, 0, 0, 1, 0, 0, 0, x, 0, 1],\r\n\t[1, 0, 1, 1, 1, 0, 0, x, 1, 0],\r\n\t[0, 0, 0, 0, 1, 0, 0, 1, 0, 1],\r\n\t[0, 1, 1, 1, 1, 1, 1, 1, 0, 0],\r\n\t[1, 1, 1, 1, 1, 0, 0, 1, 1, 1],\r\n\t[0, 0, 1, 0, 0, 1, 1, 0, 0, 1]\r\n]\r\n\r\nNote: The solution should return -1 if no path is possible.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Path",
    "link": "https://www.techiedelight.com/?problem=LongestPath",
    "category": "Backtracking, Matrix",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestPath/LongestPath.java",
    "problem": "/* START *//*\r\n\r\nGiven a rectangular path in the form of a binary matrix, find the length of the longest possible route from source to destination by moving to only non-zero adjacent positions, i.e., A route can be formed from positions having their value as 1. Note there should not be any cycles in the output path.\r\n\r\nInput:\r\n\r\nmatrix = [\r\n\t[1, 0, 1, 1, 1, 1, 0, 1, 1, 1],\r\n\t[1, 0, 1, 0, 1, 1, 1, 0, 1, 1],\r\n\t[1, 1, 1, 0, 1, 1, 0, 1, 0, 1],\r\n\t[0, 0, 0, 0, 1, 0, 0, 1, 0, 0],\r\n\t[1, 0, 0, 0, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\r\n\t[1, 0, 0, 0, 1, 0, 0, 1, 0, 1],\r\n\t[1, 0, 1, 1, 1, 1, 0, 0, 1, 1],\r\n\t[1, 1, 0, 0, 1, 0, 0, 0, 0, 1],\r\n\t[1, 0, 1, 1, 1, 1, 0, 1, 0, 0]\r\n]\r\nsrc  = (0, 0)\r\ndest = (5, 7)\r\n\r\nOutput: 22\r\n\r\nExplanation: The longest path is:\r\n\r\n(0, 0) \u00e2\u0080\u0094> (1, 0) \u00e2\u0080\u0094> (2, 0) \u00e2\u0080\u0094> (2, 1) \u00e2\u0080\u0094> (2, 2) \u00e2\u0080\u0094> (1, 2) \u00e2\u0080\u0094> (0, 2) \u00e2\u0080\u0094> (0, 3) \u00e2\u0080\u0094> (0, 4) \u00e2\u0080\u0094> (1, 4) \u00e2\u0080\u0094> (1, 5) \u00e2\u0080\u0094> (2, 5) \u00e2\u0080\u0094> (2, 4) \u00e2\u0080\u0094> (3, 4) \u00e2\u0080\u0094> (4, 4) \u00e2\u0080\u0094> (5, 4) \u00e2\u0080\u0094> (5, 5) \u00e2\u0080\u0094> (5, 6) \u00e2\u0080\u0094> (4, 6) \u00e2\u0080\u0094> (4, 7) \u00e2\u0080\u0094> (4, 8) \u00e2\u0080\u0094> (5, 8) \u00e2\u0080\u0094> (5, 7)\r\n\r\nNote: The solution should return 0 if no path is possible.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Search Matrix",
    "link": "https://www.techiedelight.com/?problem=SearchMatrix",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SearchMatrix/SearchMatrix.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix, which is row-wise and column-wise sorted (with all strictly increasing elements in any row or column), report the coordinates of all occurrences of a given element in it in linear time.\r\n\r\nInput:\r\n\r\nmatrix =\r\n[\r\n\t[-4, -3, -1, 3, 5],\r\n\t[-3, -2, 2, 4, 6],\r\n\t[-1, 1, 3, 5, 8],\r\n\t[3, 4, 7, 8, 9]\r\n]\r\n\r\ntarget = 3\r\n\r\nOutput: {(0, 3), (2, 2), (3, 0)}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Search Matrix II",
    "link": "https://www.techiedelight.com/?problem=SearchMatrixII",
    "category": "Backtracking, Matrix, String",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/SearchMatrixII/SearchMatrixII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` matrix of characters, find all occurrences of a given string in it and return a set of its coordinates. You are allowed to search the string in all eight possible directions, i.e., North, West, South, East, North-East, North-West, South-East, South-West. There should not be any cycles in the output path.\r\n\r\nInput:\r\n\r\n[\r\n\t['D', 'E', 'M', 'X', 'B'],\r\n\t['A', 'O', 'E', 'P', 'E'],\r\n\t['D', 'D', 'C', 'O', 'D'],\r\n\t['E', 'B', 'E', 'D', 'S'],\r\n\t['C', 'P', 'Y', 'E', 'N']\r\n]\r\n\r\nword = \"CODE\"\r\n\r\nOutput:\r\n\r\n{\r\n\t[(2, 2), (2, 3), (2, 4), (1, 4)],\r\n\t[(2, 2), (1, 1), (2, 1), (3, 2)],\r\n\t[(2, 2), (1, 1), (2, 1), (3, 0)],\r\n\t[(2, 2), (2, 3), (3, 3), (4, 3)],\r\n\t[(2, 2), (1, 1), (2, 1), (1, 2)],\r\n\t[(2, 2), (1, 1), (0, 0), (0, 1)],\r\n\t[(2, 2), (1, 1), (2, 0), (3, 0)],\r\n\t[(2, 2), (2, 3), (3, 3), (3, 2)]\r\n}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations",
    "link": "https://www.techiedelight.com/?problem=Combinations",
    "category": "Array, Sorting",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/Combinations/Combinations.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find all distinct combinations of a given length `k`. The solution should return a set containing all the distinct combinations, while preserving the relative order of elements as they appear in the array.\r\n\r\nInput : [2, 3, 4], k = 2\r\nOutput: {[2, 3], [2, 4], [3, 4]}\r\n\r\nInput : [1, 2, 1], k = 2\r\nOutput: {[1, 2], [1, 1], [2, 1]}\r\n\r\nInput : [1, 1, 1], k = 2\r\nOutput: {[1, 1]}\r\n\r\nInput : [1, 2, 3], k = 4\r\nOutput: {}\r\n\r\nInput : [1, 2], k = 0\r\nOutput: {[]}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations II",
    "link": "https://www.techiedelight.com/?problem=CombinationsII",
    "category": "Array",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/CombinationsII/CombinationsII.java",
    "problem": "/* START *//*\r\n\r\nFind all combinations of positive integers in increasing order that sum to a given positive number `N`.\r\n\r\nInput : N = 3\r\nOutput: {[1, 1, 1], [1, 2], [3]}\r\n\r\nInput : N = 4\r\nOutput: {[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2], [4]}\r\n\r\nInput : N = 5\r\nOutput: {[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 4], [2, 3], [5]}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations III",
    "link": "https://www.techiedelight.com/?problem=CombinationsIII",
    "category": "Array, Backtracking",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CombinationsIII/CombinationsIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number `n`, find all combinations of `2\u00c3\u0097n` elements such that every element from 1 to `n` appears exactly twice and the distance between its two appearances is exactly equal to the value of the element.\r\n\r\nInput : n = 3\r\nOutput: {[3, 1, 2, 1, 3, 2], [2, 3, 1, 2, 1, 3]}\r\n\r\nInput : n = 4\r\nOutput: {[4, 1, 3, 1, 2, 4, 3, 2], [2, 3, 4, 2, 1, 3, 1, 4]}\r\n\r\nInput : n = 5\r\nOutput: {}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations IV",
    "link": "https://www.techiedelight.com/?problem=CombinationsIV",
    "category": "Array, Backtracking, Sorting",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CombinationsIV/CombinationsIV.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find all distinct combinations of a given length `k`, where the repetition of elements is allowed.\r\n\r\nInput : [1, 2, 3], k = 2\r\nOutput: {[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]}\r\n\r\nInput : [1, 1, 1], k = 2\r\nOutput: {[1, 1]}\r\n\r\nInput : [1, 2], k = 0\r\nOutput: {[]}\r\n\r\nInput : [], k = 1\r\nOutput: {}\r\n\r\nThe solution should consider only distinct combinations. For example, either [1, 1, 2] or [1, 2, 1] or [2, 1, 1] should be considered for the below input. Same goes for [1, 2, 2] or [2, 1, 2] or [2, 2, 1].\r\n\r\nInput : [1, 2, 1], k = 3\r\nOutput: {[1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations V",
    "link": "https://www.techiedelight.com/?problem=CombinationsV",
    "category": "Array, Backtracking",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CombinationsV/CombinationsV.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive integer `n`, find all combinations of numbers between 1 and `n` having sum `n`.\r\n\r\nInput : n = 4\r\nOutput: {[4], [1, 3], [2, 2], [1, 1, 2], [1, 1, 1, 1]}\r\n\r\nInput : n = 5\r\nOutput: {[5], [1, 4], [2, 3], [1, 1, 3], [1, 2, 2], [1, 1, 1, 2], [1, 1, 1, 1, 1]}\r\n\r\nThe solution should return a set containing all the distinct combinations in increasing order.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations VI",
    "link": "https://www.techiedelight.com/?problem=CombinationsVI",
    "category": "String",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/CombinationsVI/CombinationsVI.java",
    "problem": "/* START *//*\r\n\r\nGiven a sequence of numbers between 2 and 9, print all possible combinations of words formed from the mobile keypad which has english alphabets associated with each key.\r\n\r\nkeypad = {\r\n\t2: ['A', 'B', 'C'],\r\n\t3: ['D', 'E', 'F'],\r\n\t4: ['G', 'H', 'I'],\r\n\t5: ['J', 'K', 'L'],\r\n\t6: ['M', 'N', 'O'],\r\n\t7: ['P', 'Q', 'R', 'S'],\r\n\t8: ['T', 'U', 'V'],\r\n\t9: ['W', 'X', 'Y', 'Z']\r\n}\r\n\r\nInput : [2, 3, 4]\r\n\r\nOutput: {\"CEG\", \"AEH\", \"CDH\", \"CFI\", \"CEH\", \"BEI\", \"AFH\", \"BFG\", \"BDI\", \"ADH\", \"AEG\", \"AEI\", \"BEH\", \"BFH\", \"BDH\", \"CEI\", \"AFG\", \"BFI\", \"ADG\", \"CDG\", \"BDG\", \"CDI\", \"BEG\", \"AFI\", \"CFG\", \"CFH\", \"ADI\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations VII",
    "link": "https://www.techiedelight.com/?problem=CombinationsVII",
    "category": "Backtracking, String",
    "tag": "Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/CombinationsVII/CombinationsVII.java",
    "problem": "/* START *//*\r\n\r\nGiven n lists of characters and a number whose digits lie between 1 and n, print all possible combinations by replacing its digits with the characters of the corresponding list. If any digit of the number gets repeated, it should be replaced by the same character considered in its previous occurrence.\r\n\r\nInput:\r\n\r\nlists =\r\n[\r\n\t['A', 'B', 'C', 'D'],\r\n\t['E', 'F', 'G', 'H', 'I', 'J', 'K'],\r\n\t['L', 'M', 'N', 'O', 'P', 'Q'],\r\n\t['R', 'S', 'T'],\r\n\t['U', 'V', 'W', 'X', 'Y', 'Z']\r\n]\r\n\r\nkeys = [0, 2, 0]\r\n\r\nOutput: {\"ALA\", \"AMA\", \"ANA\", \"AOA\", \"APA\", \"AQA\", \"BLB\", \"BMB\", \"BNB\", \"BOB\", \"BPB\", \"BQB\", \"CLC\", \"CMC\", \"CNC\", \"COC\", \"CPC\", \"CQC\", \"DLD\", \"DMD\", \"DND\", \"DOD\", \"DPD\", \"DQD\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations VIII",
    "link": "https://www.techiedelight.com/?problem=CombinationsVIII",
    "category": "Backtracking, String",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CombinationsVIII/CombinationsVIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, return all combinations of non-overlapping substrings of it.\r\n\r\nInput : \"ABC\"\r\nOutput: {[\"A\", \"B\", \"C\"], [\"A\", \"BC\"], [\"AB\", \"C\"], [\"ABC\"]}\r\n\r\nInput : \"ABCD\"\r\nOutput: {[\"A\", \"B\", \"C\", \"D\"], [\"A\", \"B\", \"CD\"], [\"A\", \"BC\", \"D\"], [\"A\", \"BCD\"], [\"AB\", \"C\", \"D\"], [\"AB\", \"CD\"], [\"ABC\", \"D\"], [\"ABCD\"]}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations IX",
    "link": "https://www.techiedelight.com/?problem=CombinationsIX",
    "category": "String",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CombinationsIX/CombinationsIX.java",
    "problem": "/* START *//*\r\n\r\nGiven a lists of words, print all combinations of phrases that can be formed by picking one word from each list.\r\n\r\nInput:\r\n\r\nlists =\r\n[\r\n\t[\"John\", \"Emma\"],\r\n\t[\"Plays\", \"Hates\", \"Watches\"],\r\n\t[\"Cricket\", \"Soccer\", \"Chess\"]\r\n]\r\n\r\nOutput:\r\n\r\n{\r\n\t\"John Plays Cricket\",\r\n\t\"John Plays Soccer\",\r\n\t\"John Plays Chess\",\r\n\t\"John Hates Cricket\",\r\n\t\"John Hates Soccer\",\r\n\t\"John Hates Chess\",\r\n\t\"John Watches Cricket\",\r\n\t\"John Watches Soccer\",\r\n\t\"John Watches Chess\",\r\n\t\"Emma Plays Cricket\",\r\n\t\"Emma Plays Soccer\",\r\n\t\"Emma Plays Chess\",\r\n\t\"Emma Hates Cricket\",\r\n\t\"Emma Hates Soccer\",\r\n\t\"Emma Hates Chess\",\r\n\t\"Emma Watches Cricket\",\r\n\t\"Emma Watches Soccer\",\r\n\t\"Emma Watches Chess\"\r\n}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations X",
    "link": "https://www.techiedelight.com/?problem=CombinationsX",
    "category": "Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CombinationsX/CombinationsX.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number `n` and a mobile keypad having digits from 0 to 9 associated with each key, count the total possible combinations of digits having length `n`. You can start with any digit and press only four adjacent keys of any digit. The keypad also contains `*` and `#` keys, which you're not allowed to press.\r\n\r\nkeypad = {\r\n\t{ '1', '2', '3' },\r\n\t{ '4', '5', '6' },\r\n\t{ '7', '8', '9' },\r\n\t{ '*', '0', '#' }\r\n};\r\n\r\nInput: n = 2\r\nOutput: 36\r\nExplanation: Total possible combinations are 36 [00, 08, 11, 12, 14, 21, 22, 23, 25, 32, 33, 36, 41, 44, 45, 47, \u00e2\u0080\u00a6 ,96, 98, 99]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Subset Sum",
    "link": "https://www.techiedelight.com/?problem=SubsetSum",
    "category": "Array, Backtracking, Dynamic Programming",
    "tag": "Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SubsetSum/SubsetSum.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, return the total number of ways to calculate the specified target from array elements using only the addition and subtraction operator. The use of any other operator is forbidden.\r\n\r\nInput: nums = [5, 3, -6, 2], target = 6\r\nOutput: 4\r\nExplanation: There are 4 ways to calculate the target of 6 using only + and - operators:\r\n\r\n(-)-6 = 6\r\n(+) 5 (+) 3 (-) 2 = 6\r\n(+) 5 (-) 3 (-) -6 (-) 2 = 6\r\n(-) 5 (+) 3 (-) -6 (+) 2 = 6\r\n\r\nInput: nums = [5, 3, -6, 2], target = 4\r\nOutput: 4\r\nExplanation: There are 4 ways to calculate the target of 4 using only + and - operators:\r\n\r\n(-)-6 (-) 2 = 4\r\n(-) 5 (+) 3 (-)-6 = 4\r\n(+) 5 (-) 3 (+) 2 = 4\r\n(+) 5 (+) 3 (+)-6 (+) 2 = 4\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Ball Arrangements",
    "link": "https://www.techiedelight.com/?problem=BallArrangements",
    "category": "Dynamic Programming",
    "tag": "Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/BallArrangements/BallArrangements.java",
    "problem": "/* START *//*\r\n\r\nGiven r red, b blue, and g green balls, find the total number of arrangements in a row such that no two balls of the same color end up together.\r\n\r\nInput: r = 1, b = 2, g = 1\r\nOutput: 6\r\nExplanation: The arrangements are [bgbr, bgrb, brbg, brgb, gbrb, rbgb]\r\n\r\nInput: r = 2, b = 3, g = 1\r\nOutput: 10\r\nExplanation: The arrangements are [bgbrbr, bgrbrb, brbgbr, brbgrb, brbrbg, brbrgb, brgbrb, gbrbrb, rbgbrb, rbrbgb]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Sum Subarray",
    "link": "https://www.techiedelight.com/?problem=MinimumSumSubarray",
    "category": "Array",
    "tag": "Sliding Window",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumSumSubarray/MinimumSumSubarray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array and a positive integer `k`, find the minimum sum contiguous subarray of size `k`.\r\n\r\nInput : nums[] = [10, 4, 2, 5, 6, 3, 8, 1], k = 3\r\nOutput: [4, 2, 5]\r\n\r\nInput : nums[] = [1, 4, 5, 3, 8], k = 6\r\nOutput: [1, 4, 5, 3, 8]\r\n\r\nNote: Since an input can contain several minimum sum subarrays of size `k`, the solution can return any one of them.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Product Subarray",
    "link": "https://www.techiedelight.com/?problem=MaximumProductSubarray",
    "category": "Array",
    "tag": "Algorithm",
    "lists": "TopClassic, TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumProductSubarray/MaximumProductSubarray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the contiguous subarray that has the maximum product of its elements. The solution should return the maximum product of elements among all possible subarrays.\r\n\r\nInput : [-6, 4, -5, 8, -10, 0, 8]\r\nOutput: 1600\r\nExplanation: The maximum product subarray is [4, -5, 8, -10] which has product 1600.\r\n\r\nInput : [40, 0, -20, -10]\r\nOutput: 200\r\nExplanation: The maximum product subarray is [-20, -10] which has product 200.\r\n\r\nInput : [10]\r\nOutput: 10\r\n\r\nInput : []\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "K Sum Subarray",
    "link": "https://www.techiedelight.com/?problem=KSumSubarray",
    "category": "Array",
    "tag": "Hashing, Sliding Window",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/KSumSubarray/KSumSubarray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find a contiguous subarray having sum `k` in it where `k` is an integer.\r\n\r\nInput : nums[] = [2, 6, 0, 9, 7, 3, 1, 4, 1, 10], k = 15\r\nOutput: [6, 0, 9]\r\n\r\nInput : nums[] = [0, 5, -7, 1, -4, 7, 6, 1, 4, 1, 10], k = -3\r\nOutput: [1, -4] or [-7, 1, -4, 7]\r\n\r\nNote: Since an input can contain several subarrays having sum `k`, the solution can return any one of them.\r\n\r\nInput : nums[] = [0, 5, -7, 1, -4, 7, 6, 1, 4, 1, 10], k = 15\r\nOutput: [1, -4, 7, 6, 1, 4] or [4, 1, 10]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "K Sum Subarray II",
    "link": "https://www.techiedelight.com/?problem=KSumSubarrayII",
    "category": "Array",
    "tag": "Hashing",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/KSumSubarrayII/KSumSubarrayII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find all contiguous subarrays with a given sum `k`.\r\n\r\nInput : nums[] = [3, 4, -7, 1, 3, 3, 1, -4], k = 7\r\nOutput: {[3, 4], [3, 4, -7, 1, 3, 3], [1, 3, 3], [3, 3, 1]}\r\n\r\nSince the input can have multiple subarrays with sum `k`, the solution should return a set containing all the distinct subarrays.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Smallest Subarray",
    "link": "https://www.techiedelight.com/?problem=SmallestSubarray",
    "category": "Array",
    "tag": "Sliding Window",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SmallestSubarray/SmallestSubarray.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of positive integers and a positive integer k, find the smallest contiguous subarray length whose sum of elements is greater than k.\r\n\r\nInput : [1, 2, 3, 4, 5, 6, 7, 8], k = 7\r\nOutput: 1\r\nExplanation: The smallest subarray with sum > 20 is [8]\r\n\r\nInput : [1, 2, 3, 4, 5, 6, 7, 8], k = 20\r\nOutput: 3\r\nExplanation: The smallest subarray with sum > 20 is [6, 7, 8]\r\n\r\nInput : [1, 2, 3, 4, 5, 6, 7, 8], k = 21\r\nOutput: 4\r\nExplanation: The smallest subarray with sum > 20 is [4, 5, 6, 7]\r\n\r\nInput : [1, 2, 3, 4, 5, 6, 7, 8], k = 40\r\nOutput: 0\r\nExplanation: No subarray exists\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Smallest Window to Sort Array",
    "link": "https://www.techiedelight.com/?problem=SmallestWindowToSortArray",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SmallestWindowToSortArray/SmallestWindowToSortArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the smallest window sorting which will make the entire array sorted in increasing order. The solution should return a pair consisting of the starting and ending index of the smallest window.\r\n\r\nInput : [1, 2, 3, 7, 5, 6, 4, 8]\r\nOutput: (3, 6)\r\nExplanation: The array can be sorted from index 3 to 6 to get sorted version.\r\n\r\nInput : [1, 3, 2, 7, 5, 6, 4, 8]\r\nOutput: (1, 6)\r\nExplanation: The array can be sorted from index 1 to 6 to get sorted version.\r\n\r\nIf the array is already sorted, the solution should return null.\r\n\r\nInput : [1, 2, 3, 4, 5]\r\nOutput: null\r\nExplanation: The array is already sorted.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Path Sum",
    "link": "https://www.techiedelight.com/?problem=MaximumPathSum",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumPathSum/MaximumPathSum.java",
    "problem": "/* START *//*\r\n\r\nGiven two sorted arrays of integers, find a maximum sum path involving elements of both arrays whose sum is maximum. You can start from either array, but can switch between arrays only through its common elements.\r\n\r\nInput:\r\n\r\nX = [3, 6, 7, 8, 10, 12, 15, 18, 100]\r\nY = [1, 2, 3, 5, 7, 9, 10, 11, 15, 16, 18, 25, 50]\r\n\r\nOutput: The maximum sum is 199\r\n\r\nExplanation: The maximum sum path is 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> 12 \u00e2\u0080\u0094> 15 \u00e2\u0080\u0094> 16 \u00e2\u0080\u0094> 18 \u00e2\u0080\u0094> 100\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Buy N Sell Shares",
    "link": "https://www.techiedelight.com/?problem=BuyNSellShares",
    "category": "Array",
    "tag": "",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/BuyNSellShares/BuyNSellShares.java",
    "problem": "/* START *//*\r\n\r\nGiven a list containing future prediction of share prices, find the maximum profit earned by buying and selling shares any number of times with the constraint, a new transaction can only start after the previous transaction is complete, i.e., you can only hold at most one share at a time.\r\n\r\nInput : [1, 5, 2, 3, 7, 6, 4, 5]\r\nOutput: 10\r\nExplanation: Total profit earned is 10\r\n\r\nBuy on day 1 and sell on day 2\r\nBuy on day 3 and sell on day 5\r\nBuy on day 7 and sell on day 8\r\n\r\n\r\nInput : [10, 8, 6, 5, 4, 2]\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Trapping Rain Water",
    "link": "https://www.techiedelight.com/?problem=TrappingRainWater",
    "category": "Array",
    "tag": "Algorithm",
    "lists": "TopClassic",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/TrappingRainWater/TrappingRainWater.java",
    "problem": "/* START *//*\r\n\r\nFind the maximum amount of water that can be trapped within a given set of bars where each bar\u00e2\u0080\u0099s width is 1 unit.\r\n\r\nInput : [7, 0, 4, 2, 5, 0, 6, 4, 0, 5]\r\nOutput: 25\r\nExplanation: The maximum amount of water that can be trapped is 25.\r\n\r\nPictorial representation: https://techiedelight.com/practice/images/TrappingRainWater.png\r\n\r\n\r\nInput : [10, 8, 6, 5, 4, 2]\r\nOutput: 0\r\n\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Platforms",
    "link": "https://www.techiedelight.com/?problem=MinimumPlatforms",
    "category": "Array, Sorting",
    "tag": "Greedy",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumPlatforms/MinimumPlatforms.java",
    "problem": "/* START *//*\r\n\r\nGiven a schedule containing the arrival and departure time of trains in a station, find the minimum number of platforms needed to avoid delay in any train\u00e2\u0080\u0099s arrival.\r\n\r\nInput:\r\n\r\narrival = [2.00, 2.10, 3.00, 3.20, 3.50, 5.00]\r\ndeparture = [2.30, 3.40, 3.20, 4.30, 4.00, 5.20]\r\n\r\nOutput: 2\r\n\r\nExplanation: The minimum platforms needed is 2\r\n\r\nThe train arrived at 2.00 on platform 1\r\nThe train arrived at 2.10 on platform 2\r\nThe train departed at 2.30 from platform 1\r\nThe train arrived at 3.00 on platform 1\r\nThe train departed at 3.20 from platform 1\r\nThe train arrived at 3.20 on platform 1\r\nThe train departed at 3.40 from platform 2\r\nThe train arrived at 3.50 on platform 2\r\nThe train departed at 4.00 from platform 2\r\nThe train departed at 4.30 from platform 1\r\nThe train arrived at 5.00 on platform 1\r\nThe train departed at 5.20 from platform 1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Decode Array",
    "link": "https://www.techiedelight.com/?problem=DecodeArray",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DecodeArray/DecodeArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array `X`, which is constructed by taking the sum of every distinct pair from another array `Y`, decode `X` to get the original array back. If the original array is `Y[0], Y[1], \u00e2\u0080\u00a6 , Y[n-1]`, then the input array `X` is:\r\n\r\n[\r\n  (Y[0] + Y[1]), (Y[0] + Y[2]), \u00e2\u0080\u00a6 (Y[0] + Y[n-1]),\r\n  (Y[1] + Y[2]), (Y[1] + Y[3]), \u00e2\u0080\u00a6 (Y[1] + Y[n-1]),\r\n  \u00e2\u0080\u00a6\r\n  \u00e2\u0080\u00a6\r\n  (Y[i] + Y[i+1]), (Y[i] + Y[i+2]), \u00e2\u0080\u00a6 (Y[i] + Y[n-1]),\r\n  \u00e2\u0080\u00a6\r\n  \u00e2\u0080\u00a6\r\n  (Y[n-2] + Y[n-1])\r\n]\r\n\r\nInput : [3, 4, 5, 5, 6, 7]\r\nOutput: [1, 2, 3, 4]\r\nExplanation: The input array [3, 4, 5, 5, 6, 7] is formed by the sum of every distinct pair of the output array [(1 + 2), (1 + 3), (1 + 4), (2 + 3), (2 + 4), (3 + 4)]\r\n\r\nInput : [3, 4, 5, 6, 5, 6, 7, 7, 8, 9]\r\nOutput: [1, 2, 3, 4, 5]\r\n\r\nInput : [3, 4, 5]\r\nOutput: [1, 2, 3]\r\n\r\n\r\nNote: Assume valid input and input size > 2\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sort Array Single Swap",
    "link": "https://www.techiedelight.com/?problem=SortArraySingleSwap",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SortArraySingleSwap/SortArraySingleSwap.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array where all its elements are sorted in increasing order except two swapped elements, in-place sort it in linear time. Assume there are no duplicates in the array.\r\n\r\nInput : [3, 8, 6, 7, 5, 9] or [3, 5, 6, 9, 8, 7] or [3, 5, 7, 6, 8, 9]\r\nOutput: [3, 5, 6, 7, 8, 9]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "3 Sum",
    "link": "https://www.techiedelight.com/?problem=3Sum",
    "category": "Array",
    "tag": "Hashing, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/3Sum/3Sum.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array, find a triplet that sum to zero.\r\n\r\nInput : [4, -1, 1, 2, -1]\r\nOutput: [-1, 2, -1]\r\n\r\nInput : [4, 5, 4, -1, 3]\r\nOutput: []\r\nExplanation: No triplet exists with zero-sum.\r\n\r\nIf the input contains several triplets with zero-sum, the solution can return any one of them.\r\n\r\nInput : nums[] = [-5, 2, 4, 0, 9, 5, 1, -3]\r\nOutput: [0, -5, 5] or [-5, 4, 1] or [1, 2, -3]\r\n\r\nNote: The solution can return the triplet in any order, not necessarily as they appear in the array.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "3 Sum II",
    "link": "https://www.techiedelight.com/?problem=3SumII",
    "category": "Array, Sorting",
    "tag": "Hashing, Recursive",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/3SumII/3SumII.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array, find a triplet with a given sum `k` in it.\r\n\r\nInput : [4, -1, 1, 2, -1], k = 0\r\nOutput: [-1, 2, -1]\r\n\r\nInput : [4, 5, 4, -1, 3], k = 10\r\nOutput: []\r\nExplanation: No triplet exists with sum 10.\r\n\r\nIf the input contains several triplets with sum `k`, the solution can return any one of them.\r\n\r\nInput : nums[] = [2, 7, 4, 0, 9, 5, 1, 3], k = 6\r\nOutput: [0, 1, 5] or [0, 2, 4] or [1, 2, 3]\r\n\r\nNote: The solution can return the triplet in any order, not necessarily as they appear in the array.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "3 Sum III",
    "link": "https://www.techiedelight.com/?problem=3SumIII",
    "category": "Array, Backtracking, Sorting",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/3SumIII/3SumIII.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array, find all triplets in it with sum less than or equal to a given number.\r\n\r\nInput : nums[] = [2, 7, 4, 9, 5, 1, 3], target = 10\r\nOutput: {[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 2, 7], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5]}\r\n\r\nInput : nums[] = [3, 5, 7, 3, 2, 1], target = 5\r\nOutput: {}\r\n\r\nSince the input can have multiple triplets with sum less than or equal to the target, the solution should return a set containing all the distinct triplets in any order.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Continuous Sequence",
    "link": "https://www.techiedelight.com/?problem=LongestContinuousSequence",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LongestContinuousSequence/LongestContinuousSequence.java",
    "problem": "/* START *//*\r\n\r\nGiven two binary arrays, `X` and `Y`, find the length of the longest continuous sequence that starts and ends at the same index in both arrays and have the same sum. In other words, find `max(j-i+1)` for every `j >= i`, where the sum of subarray `X[i, j]` is equal to the sum of subarray `Y[i, j]`.\r\n\r\nInput:\r\n\r\nX[]: [0, 0, 1, 1, 1, 1]\r\nY[]: [0, 1, 1, 0, 1, 0]\r\n\r\nOutput: 5\r\nExplanation: The length of the longest continuous sequence with the same sum is 5 as\r\n\r\nX[0, 4]: [0, 0, 1, 1, 1]\t(sum = 3)\r\nY[0, 4]: [0, 1, 1, 0, 1]\t(sum = 3)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Consecutive Elements",
    "link": "https://www.techiedelight.com/?problem=ReverseConsecutiveElements",
    "category": "Array",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseConsecutiveElements/ReverseConsecutiveElements.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array `nums` and non-negative integers i, j, and m, reverse every group of consecutive `m` elements in subarray `[i, j]`.\r\n\r\nInput : nums[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], m = 3, i = 1, j = 7\r\nOutput: [1, 4, 3, 2, 7, 6, 5, 8, 9, 10]\r\n\r\nInput : nums[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], m = 3, i = 1, j = 9\r\nOutput: [1, 4, 3, 2, 7, 6, 5, 10, 9, 8]\r\n\r\nInput : nums[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], m = 3, i = 3, j = 5\r\nOutput: [1, 2, 3, 6, 5, 4, 7, 8, 9, 10]\r\n\r\nInput : nums[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], m = 3, i = 3, j = 4\r\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Product Subset",
    "link": "https://www.techiedelight.com/?problem=MaximumProductSubset",
    "category": "Array",
    "tag": "Algorithm, Recursive",
    "lists": "TopClassic",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumProductSubset/MaximumProductSubset.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the maximum product of its elements among all its subsets.\r\n\r\nInput : [-6, 4, -5, 8, -10, 0, 8]\r\nOutput: 15360\r\nExplanation: The subset with the maximum product of its elements is [-6, 4, 8, -10, 8]\r\n\r\nInput : [4, -8, 0, 8]\r\nOutput: 32\r\nExplanation: The subset with the maximum product of its elements is [4, 8]\r\n\r\nInput : []\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "2 Diff",
    "link": "https://www.techiedelight.com/?problem=2Diff",
    "category": "Array, Divide & Conquer, Sorting",
    "tag": "Hashing",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/2Diff/2Diff.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array, find all pairs with a given difference `k` in it using constant space.\r\n\r\nInput : nums = [1, 5, 2, 2, 2, 5, 5, 4], k = 3\r\nOutput: {(2, 5), (1, 4)}\r\n\r\nNote:\r\n\r\n\u00e2\u0080\u00a2 The solution should return the pair in sorted order. For instance, among pairs (5, 2) and (2, 5), only pair (2, 5) appeared in the output.\r\n\r\n\u00e2\u0080\u00a2 Since the input can contain multiple pairs with a given difference, the solution should return a set containing all the distinct pairs. For instance, the pair (2, 5) appeared only once in the output.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "4 Sum",
    "link": "https://www.techiedelight.com/?problem=4Sum",
    "category": "Array, Sorting",
    "tag": "Algorithm, Hashing, Recursive",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/4Sum/4Sum.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array, find all quadruplets (i.e., four elements tuple) having a given sum.\r\n\r\nInput : nums = [2, 7, 4, 0, 9, 5, 1, 3], target = 7\r\nOutput: {[0, 1, 2, 4]}\r\n\r\nSince the input can contain multiple quadruplets that sum to a given target, the solution should return a set containing all the quadruplets.\r\n\r\nInput : nums = [2, 7, 4, 0, 9, 5, 1, 3], target = 20\r\nOutput: {[0, 4, 7, 9], [1, 3, 7, 9], [2, 4, 5, 9]}\r\n\r\nNote: The order of elements doesn't matter in a quadruplet, and any permutation is allowed in the output. For example, the output set can contain quadruplets [9, 1, 7, 3] and [9, 3, 7, 1], but system treats them the same.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Arithmetic Triplets",
    "link": "https://www.techiedelight.com/?problem=ArithmeticTriplets",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ArithmeticTriplets/ArithmeticTriplets.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted array of distinct positive integers, return all triplets that forms an arithmetic progression with an integral common difference. An arithmetic progression is a sequence of numbers such that the difference between the consecutive terms is constant.\r\n\r\nInput : [5, 8, 9, 11, 12, 15]\r\nOutput: {[5, 8, 11], [9, 12, 15]}\r\n\r\nInput : [1, 3, 5, 6, 8, 9, 15]\r\nOutput: {[1, 3, 5], [1, 5, 9], [3, 6, 9], [1, 8, 15], [3, 9, 15]}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Geometric Triplets",
    "link": "https://www.techiedelight.com/?problem=GeometricTriplets",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/GeometricTriplets/GeometricTriplets.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted array of distinct positive integers, return all triplets that forms a geometric progression with an integral common ratio. A geometric progression is a sequence of numbers where each term after the first is found by multiplying the previous one by a fixed, non-zero number called the common ratio.\r\n\r\nInput : [1, 2, 6, 10, 18, 54]\r\nOutput: {[2, 6, 18], [6, 18, 54]}\r\n\r\nInput : [2, 8, 10, 15, 16, 30, 32, 64]\r\nOutput: {[2, 8, 32], [8, 16, 32], [16, 32, 64]}\r\n\r\nInput : [1, 2, 6, 18, 36, 54]\r\nOutput: {[2, 6, 18], [1, 6, 36], [6, 18, 54]}\r\n\r\nInput : [1, 2, 4, 16]\r\nOutput: {[1, 2, 4], [1, 4, 16]}\r\n\r\nInput : [1, 2, 3, 6, 18, 22]\r\nOutput: {[2, 6, 18]}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Buy and Sell Stock",
    "link": "https://www.techiedelight.com/?problem=BuyAndSellStock",
    "category": "Array, Dynamic Programming",
    "tag": "Bottom-up",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/BuyAndSellStock/BuyAndSellStock.java",
    "problem": "/* START *//*\r\n\r\nGiven a list containing future predictions of share prices and a positive integer `k`, find the maximum profit earned by buying and selling shares at most `k` times with a constraint that a new transaction can only start after the previous transaction is complete, i.e., you can only hold at most one share at a time.\r\n\r\nInput: price[]: [2, 4, 7, 5, 4, 3, 5], k = 2\r\nOutput: 7\r\nExplanation: The maximum profit is 7 (sum of 5 and 2)\r\n\r\n\u00e2\u0080\u00a2 Buy at a price 2 and sell at a price 7\r\n\u00e2\u0080\u00a2 Buy at a price 3 and sell at a price 5\r\n\r\n\r\nInput: price[]: [1, 5, 2, 3, 7, 6, 4, 5], k = 3\r\nOutput: 10\r\nExplanation: The maximum profit is 10 (sum of 4, 5, and 1).\r\n\r\n\u00e2\u0080\u00a2 Buy at a price 1 and sell at a price 5\r\n\u00e2\u0080\u00a2 Buy at a price 2 and sell at a price 7\r\n\u00e2\u0080\u00a2 Buy at a price 4 and sell at a price 5\r\n\r\n\r\nInput: price[]: [10, 6, 8, 4, 2], k = 2\r\nOutput: 2\r\nExplanation: The maximum profit is 2. Buy at a price 6 and sell at a price 8.\r\n\r\n\r\nInput: price[]: [10, 8, 6, 5, 4, 2], k = 1\r\nOutput: 0\r\nExplanation: Prices are given in descending order.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Buy and Sell Stock II",
    "link": "https://www.techiedelight.com/?problem=BuyAndSellStockII",
    "category": "Array, Dynamic Programming",
    "tag": "Bottom-up",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/BuyAndSellStockII/BuyAndSellStockII.java",
    "problem": "/* START *//*\r\n\r\nGiven a list containing future predictions of share prices, find the maximum profit earned by buying and selling shares at most twice with a constraint that a new transaction can only start after the previous transaction complete, i.e., we can only hold at most one share at a time.\r\n\r\nInput: [2, 4, 7, 5, 4, 3, 5]\r\nOutput: 7\r\nExplanation: The maximum profit is 7. You can buy at a price 2 and sell at a price 7. Then, buy at a price 3 and sell at a price 5.\r\n\r\nInput: [10, 6, 8, 4, 2]\r\nOutput: 2\r\nExplanation: The maximum profit is 2. You can buy at a price 6 and sell at a price 8.\r\n\r\nInput: [8, 7, 6, 4]\r\nOutput: 0\r\nExplanation: The maximum profit is 0 as buying and selling stock will result in loss.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Buy and Sell Stock III",
    "link": "https://www.techiedelight.com/?problem=BuyAndSellStockIII",
    "category": "Array, Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/BuyAndSellStockIII/BuyAndSellStockIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a list containing future price predictions of two different stocks for the next n\u00e2\u0080\u0093days, find the maximum profit earned by selling the stocks with a constraint that the second stock can be sold, only if no transaction happened on the previous day for any of the stock.\r\n\r\nAssume that the given prices are relative to the buying price. Each day, we can either sell a single share of the first stock or a single share of the second stock or sell nothing.\r\n\r\nInput: X = [5, 3, 4, 6, 3], Y = [8, 4, 3, 5, 10]\r\n\r\nDay\t Price(X)  Price(Y)\r\n1\t\t5\t\t 8\r\n2\t\t3\t\t 4\r\n3\t\t4\t\t 3\r\n4\t\t6\t\t 5\r\n5\t\t3\t\t 10\r\n\r\nOutput: 25\r\n\r\nExplanation:\r\n\r\nDay 1: Sell stock Y at a price of 8\r\nDay 2: Sell stock X at a price of 3\r\nDay 3: Sell stock X at a price of 4\r\nDay 4: Don't sell anything\r\nDay 5: Sell stock Y at a price of 10\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Group Elements",
    "link": "https://www.techiedelight.com/?problem=GroupElements",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/GroupElements/GroupElements.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array containing many duplicate elements, rearrange it such that the same element appears together and the relative order of the first occurrence of each element remains unchanged.\r\n\r\nInput : [1, 2, 3, 1, 2, 1]\r\nOutput: [1, 1, 1, 2, 2, 3]\r\n\r\nInput : [5, 4, 5, 5, 3, 1, 2, 2, 4]\r\nOutput: [5, 5, 5, 4, 4, 3, 1, 2, 2]\r\n\r\nInput : [7, 0, 4, 2, 5, 0, 6, 4, 0, 5]\r\nOutput: [7, 0, 0, 0, 4, 4, 2, 5, 5, 6]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Absolute Difference",
    "link": "https://www.techiedelight.com/?problem=MinimumAbsoluteDifference",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumAbsoluteDifference/MinimumAbsoluteDifference.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array `nums` and two integers `x` and `y` present in it, find the minimum absolute difference between indices of `x` and `y` in a single traversal of the array.\r\n\r\nInput : nums[] = [1, 3, 5, 4, 8, 2, 4, 3, 6, 5], x = 3, y = 2\r\nOutput: 2\r\nExplanation: Element 3 is present at index 1 and 7, and element 2 is present at index 5. Their minimum absolute difference is min(abs(1-5), abs(7-5)) = 2\r\n\r\nInput : nums[] = [1, 3, 5, 4, 8, 2, 4, 3, 6, 5], x = 2, y = 5\r\nOutput: 3\r\nExplanation: Element 2 is present at index 5, and element 5 is present at index 2 and 9. Their minimum absolute difference is min(abs(5-2), abs(5-9)) = 3\r\n\r\nInput : nums[] = [], x = 0, y = 1\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Absolute Difference II",
    "link": "https://www.techiedelight.com/?problem=MinimumAbsoluteDifferenceII",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumAbsoluteDifferenceII/MinimumAbsoluteDifferenceII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the maximum absolute difference between the sum of elements of two non-overlapping contiguous subarrays in linear time.\r\n\r\nInput : [-3, -2, 6, -3, 5, -9, 3, 4, -1, -8, 2]\r\nOutput: 19\r\nExplanation: The two subarrays are [6, -3, 5] and [-9, 3, 4, -1, -8] whose sum of elements are 8 and -11, respectively. So, abs(8-(-11)) or abs(-11-8) = 19.\r\n\r\nInput : [6, 1, 3, 7]\r\nOutput: 9\r\nExplanation: The two subarrays are [1] and [3, 7] whose sum of elements are 1 and 10, respectively. The maximum absolute difference is abs(10-1) = 9.\r\n\r\nInput : [2]\r\nOutput: 2\r\n\r\nInput : []\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Symmetric Pairs",
    "link": "https://www.techiedelight.com/?problem=SymmetricPairs",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SymmetricPairs/SymmetricPairs.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of pairs of integers, find all symmetric pairs, i.e., pairs that mirror each other. For instance, pairs `(x, y)` and `(y, x)` are mirrors of each other.\r\n\r\nInput : {(1, 2), (5, 2), (3, 4), (7, 10), (4, 3), (2, 5)}\r\nOutput: {{(2, 5), (5, 2)}, {(3, 4), (4, 3)}}\r\nExplanation: The pairs (2, 5) and (5, 2) mirror each other. Similarly, pairs (3, 4) and (4, 3) are symmetric.\r\n\r\nInput : {(1, 2), (5, 2), (3, 4)}\r\nOutput: {}\r\nExplanation: No pairs mirror each other\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Closest Pair",
    "link": "https://www.techiedelight.com/?problem=ClosestPair",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ClosestPair/ClosestPair.java",
    "problem": "/* START *//*\r\n\r\nGiven two sorted integer arrays, `X[]` and `Y[]`, and an integer `k`, find a pair `(x, y)` whose sum is closest to `k`, where the pair consists of elements from each array. The solution should return the pair `(x, y)` `x` is taken from the first array, and `y` from the second array.\r\n\r\nInput:\r\n\r\nX[] = [1, 8, 10, 12]\r\nY[] = [2, 4, 9, 15]\r\nk = 11\r\n\r\nOutput: (1, 9)\r\n\r\n\r\n\u00e2\u0080\u00a2 For some inputs, the multiple pairs are feasible. For such cases, the solution can return any matching pair. For example,\r\n\r\nInput:\r\n\r\nX[] = [2, 4, 6, 8, 10]\r\nY[] = [1, 3, 5, 7, 9]\r\nk = 4\r\n\r\nOutput: (2, 1) or (2, 3)\r\n\r\n\r\n\u00e2\u0080\u00a2 If no pair exists, the solution should return null.\r\n\r\nInput:\r\n\r\nX[] = [1, 2, 3]\r\nY[] = []\r\nk = 4\r\n\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Partition Array Equal Sum",
    "link": "https://www.techiedelight.com/?problem=PartitionArrayEqualSum",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/PartitionArrayEqualSum/PartitionArrayEqualSum.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, partition it into two contiguous subarrays having the same sum of elements and return the index that points to the starting of the second subarray. Return -1 if no partition is possible.\r\n\r\nInput : [6, -4, -3, 2, 3]\r\nOutput: 2\r\nExplanation: The subarrays [6, -4] and [-3, 2, 3] have equal sum of 2. The second subarray starts from index 2.\r\n\r\nInput : [6, -5, 2, -4, 1]\r\nOutput: -1\r\nExplanation: No equal sum partition possible.\r\n\r\nIn case multiple solutions is possible, return the index of the first occurrence. For example,\r\n\r\nInput : [1, -1, 1, -1, 1, -1]\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Distinct Elements Count",
    "link": "https://www.techiedelight.com/?problem=DistinctElementsCount",
    "category": "Array",
    "tag": "Hashing, Sliding Window",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DistinctElementsCount/DistinctElementsCount.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array and a positive integer `k`, find the count of distinct elements in every contiguous subarray of size `k`.\r\n\r\nInput : nums[] = [2, 1, 2, 3, 2, 1, 4, 5], k = 5\r\nOutput: [3, 3, 4, 5]\r\nExplanation:\r\n\r\nThe count of distinct elements in subarray [2, 1, 2, 3, 2] is 3\r\nThe count of distinct elements in subarray [1, 2, 3, 2, 1] is 3\r\nThe count of distinct elements in subarray [2, 3, 2, 1, 4] is 4\r\nThe count of distinct elements in subarray [3, 2, 1, 4, 5] is 5\r\n\r\n\r\nInput : nums[] = [1, 1, 2, 1, 3], k = 3\r\nOutput: [2, 2, 3]\r\nExplanation:\r\n\r\nThe count of distinct elements in subarray [1, 1, 2] is 2\r\nThe count of distinct elements in subarray [1, 2, 1] is 2\r\nThe count of distinct elements in subarray [2, 1, 3] is 3\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Sum Number",
    "link": "https://www.techiedelight.com/?problem=MaximumSumNumber",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumSumNumber/MaximumSumNumber.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array between 0 and 9, generate a pair using all the array digits that has the maximum sum. The difference in the number of digits of the two numbers should be \u00c2\u00b1 1.\r\n\r\nInput : [4, 6, 2, 7, 9, 8]\r\nOutput: (974, 862)\r\n\r\nInput : [9, 2, 5, 6, 0, 4]\r\nOutput: (952, 640)\r\n\r\nThe solution can return pair in any order. If a pair cannot be formed, the solution should return null.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Largest Distinct Subarrays",
    "link": "https://www.techiedelight.com/?problem=LargestDistinctSubarrays",
    "category": "Array",
    "tag": "Hashing, Sliding Window",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LargestDistinctSubarrays/LargestDistinctSubarrays.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find all maximum size contiguous subarrays having all distinct elements in them.\r\n\r\nInput : [5, 2, 3, 5, 4, 3]\r\nOutput: {[5, 2, 3], [2, 3, 5, 4], [5, 4, 3]}\r\n\r\nInput : [1, 2, 3, 3]\r\nOutput: {[1, 2, 3], [3]}\r\n\r\nInput : [1, 2, 3, 4]\r\nOutput: {[1, 2, 3, 4]}\r\n\r\nNote: Since an input can have multiple subarrays with all distinct elements, the solution should return a set containing all the distinct subarrays.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Product Triplet",
    "link": "https://www.techiedelight.com/?problem=MaximumProductTriplet",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumProductTriplet/MaximumProductTriplet.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find a triplet having the maximum product.\r\n\r\nInput : [-4, 1, -8, 9, 6]\r\nOutput: [-4, -8, 9]\r\n\r\nIf the input contains several triplets with maximum product, the solution can return any one of them.\r\n\r\nInput : [5, 2, -10, 4, 5, 1, -2]\r\nOutput: [5, 4, 5] or [5, -10, -2]\r\n\r\nNote: The solution can return the triplet in any order, not necessarily as they appear in the array.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Repeating Element Index",
    "link": "https://www.techiedelight.com/?problem=RepeatingElementIndex",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RepeatingElementIndex/RepeatingElementIndex.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the minimum index of a repeating element in linear time and doing just a single traversal of the array.\r\n\r\nInput : [5, 6, 3, 4, 3, 6, 4]\r\nOutput: 1\r\nExplanation: The minimum index of the repeating element is 1\r\n\r\nInput : [1, 2, 3, 4, 5, 6]\r\nOutput: -1\r\nExplanation: Input doesn't contain any repeating element\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Absolute Sum Pair",
    "link": "https://www.techiedelight.com/?problem=MinimumAbsoluteSumPair",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumAbsoluteSumPair/MinimumAbsoluteSumPair.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted integer array, find a pair in it having an absolute minimum sum.\r\n\r\nInput : [-6, -5, -3, 0, 2, 4, 9]\r\nOutput: (-5, 4)\r\nExplanation: (-5, 4) = abs(-5 + 4) = abs(-1) = 1, which is minimum among all pairs.\r\n\r\n\u00e2\u0080\u00a2 Each input can have multiple solutions. The output should match with either one of them.\r\n\r\nInput : [-6, -2, 0, 1, 5]\r\nOutput: (-6, 5) or (-2, 1) or (0, 1)\r\n\r\n\u00e2\u0080\u00a2 The solution can return pair in any order. If no pair exists, the solution should return null.\r\n\r\nInput : [1]\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Consecutive Numbers",
    "link": "https://www.techiedelight.com/?problem=ConsecutiveNumbers",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ConsecutiveNumbers/ConsecutiveNumbers.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, check if only consecutive integers form the array.\r\n\r\nInput : [-1, 5, 4, 2, 0, 3, 1]\r\nOutput: true\r\nExplanation: The array contains consecutive integers from -1 to 5.\r\n\r\nInput : [4, 2, 4, 3, 1]\r\nOutput: false\r\nExplanation: The array does not contain consecutive integers as element 4 is repeated.\r\n\r\nInput : [2, 5, 3, 1]\r\nOutput: false\r\nExplanation: The array does not contain consecutive integers as element 4 is missing.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Non Overlapping Pairs",
    "link": "https://www.techiedelight.com/?problem=NonOverlappingPairs",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/NonOverlappingPairs/NonOverlappingPairs.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array, find all non-overlapping pairs in it having the same sum.\r\n\r\nInput : [3, 7, 6, 2]\r\nOutput: {{(7, 2), (3, 6)}}\r\nExplanation: The pairs (7, 2) and (3, 6) are non-overlapping (having different indices) and have the same sum.\r\n\r\nInput : [3, 4, 7, 4]\r\nOutput: {}\r\nExplanation: No non-overlapping pairs are present in the array. The pairs (3, 4) and (3, 4) are overlapping as the index of 3 is the same in both pairs.\r\n\r\n\u00e2\u0080\u00a2 The input can contain multiple non-overlapping pairs with the same sum, the solution should return a set containing all the distinct pairs.\r\n\r\nInput : [3, 4, 7, 6, 1]\r\nOutput: {{(6, 1), (3, 4)}, {(4, 6), (3, 7)}}\r\n\r\nInput : [3, 7, 6, 2, 4, 5]\r\nOutput: {{(7, 2), (3, 6)}, {(6, 2), (3, 5)}, {(6, 4), (3, 7)}, {(6, 5), (7, 4)}, {(2, 5), (3, 4)}, {(4, 5), (3, 6)}, {(4, 5), (7, 2)}}\r\n\r\nNote: The solution should return all pairs in the same order as they appear in the array.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Add Arrays",
    "link": "https://www.techiedelight.com/?problem=AddArrays",
    "category": "Array",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/AddArrays/AddArrays.java",
    "problem": "/* START *//*\r\n\r\nGiven two arrays of positive integers, add their elements into a new array. The solution should add both arrays, one by one starting from the 0'th index, and split the sum into individual digits if it is a 2\u00e2\u0080\u0093digit number.\r\n\r\nInput : [23, 5, 2, 7, 87], [4, 67, 2, 8]\r\nOutput: [2, 7, 7, 2, 4, 1, 5, 8, 7]\r\n\r\nInput : [], [4, 67, 2, 8]\r\nOutput: [4, 6, 7, 2, 8]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Product Triplet",
    "link": "https://www.techiedelight.com/?problem=MinimumProductTriplet",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumProductTriplet/MinimumProductTriplet.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the minimum product among all combinations of triplets in the array.\r\n\r\nInput : [4, -1, 3, 5, 9]\r\nOutput: -45\r\nExplanation: The minimum product triplet is (-1, 5, 9)\r\n\r\nInput : [1, 4, 10, -2, 4]\r\nOutput: -80\r\nExplanation: The minimum product triplet is (10, 4, -2)\r\n\r\nInput : [3, 4, 1, 2, 5]\r\nOutput: 6\r\nExplanation: The minimum product triplet is (3, 1, 2)\r\n\r\nInput : [1, 2]\r\nOutput: 0\r\nExplanation: Invalid input\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Distinct Absolute Count",
    "link": "https://www.techiedelight.com/?problem=DistinctAbsoluteCount",
    "category": "Array",
    "tag": "Hashing, Sliding Window",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DistinctAbsoluteCount/DistinctAbsoluteCount.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of sorted integers that may contain several duplicate elements, count the total number of distinct absolute values in it.\r\n\r\nInput : [-1, -1, 0, 1, 1, 1]\r\nOutput: 2\r\nExplanation: There are 2 distinct absolutes in the array [0, 1]\r\n\r\nInput : [-2, -1, 0, 1, 2, 3]\r\nOutput: 4\r\nExplanation: There are 4 distinct absolutes in the array [0, 1, 2, 3]\r\n\r\nInput : [-1, -1, -1, -1]\r\nOutput: 1\r\nExplanation: There is only 1 distinct absolute in the array [1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Break Point Index",
    "link": "https://www.techiedelight.com/?problem=BreakPointIndex",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/BreakPointIndex/BreakPointIndex.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find an index that divides it into two non-empty contiguous subarrays having an equal sum.\r\n\r\nInput : [-1, 6, 3, 1, -2, 3, 3]\r\nOutput: 2\r\nExplanation: The element 3 at index 2 divides the array into two non-empty subarrays `[-1, 6]` and `[1, -2, 3, 3]` having the same sum.\r\n\r\n\u00e2\u0080\u00a2 The solution should return -1 if no partition is possible.\r\n\r\nInput : [6, -5, 2, -4, 1]\r\nOutput: -1\r\nExplanation: No equal sum partition possible.\r\n\r\n\u00e2\u0080\u00a2 In case multiple partitions is possible, return the index of the first partition.\r\n\r\nInput : [-1, -2, 2, -3]\r\nOutput: 1\r\nExplanation: The index 1 and 2 divides the array into two equal sum subarrays. The solution should return index 1.\r\n\r\nInput : [4, 2, -3, 4, -1, 0, 4]\r\nOutput: 1\r\nExplanation: The index 1 and 3 divides the array into two equal sum subarrays. The solution should return index 1.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Frequency Map",
    "link": "https://www.techiedelight.com/?problem=FrequencyMap",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/FrequencyMap/FrequencyMap.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array whose elements lie in the range 0 to `n-1` where `n` is the array size, calculate the frequency of all array elements in linear time and using constant space.\r\n\r\nInput : [2, 3, 1, 3, 1, 1]\r\nOutput: {1: 3, 2: 1, 3: 2}\r\n\r\nExplanation:\r\n\r\nElement 1 appears thrice.\r\nElement 2 appears once.\r\nElement 3 appears twice.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Frequency Map II",
    "link": "https://www.techiedelight.com/?problem=FrequencyMapII",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search, Hashing, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/FrequencyMapII/FrequencyMapII.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted array containing duplicates, efficiently find each element's frequency without traversing the whole array.\r\n\r\nInput: [2, 2, 2, 4, 4, 4, 5, 5, 6, 8, 8, 9]\r\nOutput: {2: 3, 4: 3, 5: 2, 6: 1, 8: 2, 9: 1}\r\n\r\nExplanation:\r\n\r\n2 and 4 occurs thrice\r\n5 and 8 occurs twice\r\n6 and 9 occurs once\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sorted Triplet",
    "link": "https://www.techiedelight.com/?problem=SortedTriplet",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortedTriplet/SortedTriplet.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array `nums`, efficiently find a sorted triplet such that `nums[i] < nums[j] < nums[k]` where `i < j < k`.\r\n\r\nInput : [7, 3, 4, 2, 6]\r\nOutput: (3, 4, 6)\r\n\r\n\u00e2\u0080\u00a2 If the input contains several sorted triplets, the solution can return any one of them.\r\n\r\nInput : [5, 4, 3, 7, 6, 1, 9]\r\nOutput: (5, 7, 9) or (4, 7, 9) or (3, 7, 9) or (5, 6, 9) or (4, 6, 9) or (3, 6, 9)\r\n\r\n\u00e2\u0080\u00a2 If no triplet exists, return null.\r\n\r\nInput : [5, 4, 3]\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shuffle Array",
    "link": "https://www.techiedelight.com/?problem=ShuffleArray",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ShuffleArray/ShuffleArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of distinct integers `nums`, in-place shuffle it according to order specified by another array `pos`. For every index `i` in `nums`, the solution should update `nums[pos[i]] = nums[i]`.\r\n\r\nInput:\r\n\r\nnums[] = [1, 2, 3, 4, 5]\r\n pos[] = [3, 2, 4, 1, 0]\r\n\r\nOutput: [5, 4, 2, 1, 3]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shuffle Array II",
    "link": "https://www.techiedelight.com/?problem=ShuffleArrayII",
    "category": "Array, Sorting",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ShuffleArrayII/ShuffleArrayII.java",
    "problem": "/* START *//*\r\n\r\nGiven two integer arrays, reorder elements of the first array by the order of elements defined by the second array.\r\n\r\nThe elements that are not present in the second array but present in the first array should be appended at the end in sorted order. The second array can contain some extra elements which are not part of the first array.\r\n\r\nInput:\r\n\r\nnums[] = [5, 8, 9, 3, 5, 7, 1, 3, 4, 9, 3, 5, 1, 8, 4]\r\n pos[] = [3, 5, 7, 2]\r\n\r\nOutput : [3, 3, 3, 5, 5, 5, 7, 1, 1, 4, 4, 8, 8, 9, 9]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shuffle Array III",
    "link": "https://www.techiedelight.com/?problem=ShuffleArrayIII",
    "category": "Array",
    "tag": "Algorithm",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ShuffleArrayIII/ShuffleArrayIII.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of distinct integer, in-place shuffle the array. The solution should produce an unbiased permutation, i.e., every permutation is equally likely.\r\n\r\nInput: [1, 2, 3, 4, 5]\r\nOutput: [5, 4, 2, 1, 3] or [4, 1, 5, 3, 2] or any other unbiased permutation.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Strictly Increasing Subarrays",
    "link": "https://www.techiedelight.com/?problem=StrictlyIncreasingSubarrays",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/StrictlyIncreasingSubarrays/StrictlyIncreasingSubarrays.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, count the total number of strictly increasing contiguous subarrays in it.\r\n\r\nInput: [1, 2, 4, 4, 5]\r\nOutput: 4\r\nExplanation: The total number of strictly increasing subarrays are [1, 2], [1, 2, 4], [2, 4], [4, 5]\r\n\r\nInput: [1, 3, 2]\r\nOutput: 1\r\nExplanation: The total number of strictly increasing subarrays is [1, 3]\r\n\r\nInput: [5, 4, 3, 2, 1]\r\nOutput: 0\r\nExplanation: The total number of strictly increasing subarrays is 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Duplicates in Range K",
    "link": "https://www.techiedelight.com/?problem=DuplicatesInRangeK",
    "category": "Array",
    "tag": "Hashing, Sliding Window",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/DuplicatesInRangeK/DuplicatesInRangeK.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array and a positive number `k`, check whether the array contains any duplicate elements within the range `k`. If `k` is more than the array\u00e2\u0080\u0099s size, the solution should check for duplicates in the complete array.\r\n\r\nInput: nums[] = [5, 6, 8, 2, 4, 6, 9], k = 4\r\nOutput: true\r\nExplanation: Element 6 repeats at distance 4 which is <= k\r\n\r\nInput: nums[] = [5, 6, 8, 2, 4, 6, 9], k = 2\r\nOutput: false\r\nExplanation: Element 6 repeats at distance 4 which is > k\r\n\r\nInput: nums[] = [1, 2, 3, 2, 1], k = 7\r\nOutput: true\r\nExplanation: Element 1 and 2 repeats at distance 4 and 2, respectively which are both <= k\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Range",
    "link": "https://www.techiedelight.com/?problem=MinimumRange",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumRange/MinimumRange.java",
    "problem": "/* START *//*\r\n\r\nGiven three sorted arrays of variable length, efficiently compute the minimum range with at least one element from each array.\r\n\r\nInput : [[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16]]\r\nOutput: (3, 5)\r\n\r\nInput : [[2, 3, 4, 8, 10, 15], [1, 5, 12], [7, 8, 15, 16]]\r\nOutput: (4, 7)\r\n\r\nInput : [[1], [1, 2], [0, 1]]\r\nOutput: (1, 1)\r\n\r\nIf minimum range doesn't exist, the solution should return null.\r\n\r\nInput : [[], [], []]\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Range II",
    "link": "https://www.techiedelight.com/?problem=MinimumRangeII",
    "category": "Array, Heap",
    "tag": "Priority Queue",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumRangeII/MinimumRangeII.java",
    "problem": "/* START *//*\r\nGiven M sorted lists of variable length, efficiently compute the smallest range, including at least one element from each list.\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[3, 6, 8, 10, 15],\r\n\t[1, 5, 12],\r\n\t[4, 8, 15, 16],\r\n\t[2, 6],\r\n]\r\n\r\nOutput: (4, 6)\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[2, 3, 4, 8, 10, 15],\r\n\t[1, 5, 12],\r\n\t[7, 8, 15, 16],\r\n\t[3, 6],\r\n]\r\n\r\nOutput: (4, 7)\r\n\r\n\r\nIf minimum range doesn't exist, the solution should return null.\r\n\r\nInput : [[], [], []]\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Consecutive Subsequence",
    "link": "https://www.techiedelight.com/?problem=LongestConsecutiveSubsequence",
    "category": "Array",
    "tag": "Hashing",
    "lists": "TopClassic",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestConsecutiveSubsequence/LongestConsecutiveSubsequence.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the length of the longest subsequence formed by the consecutive integers. The subsequence should contain all distinct values, and the character set should be consecutive, irrespective of its order.\r\n\r\nInput : [2, 0, 6, 1, 5, 3, 7]\r\nOutput: 4\r\nExplanation: The longest subsequence formed by the consecutive integers is [2, 0, 1, 3]. It has distinct values and length 4.\r\n\r\nInput : [1, 4, 4, 0, 2, 3]\r\nOutput: 5\r\nExplanation: The longest subsequence formed by the consecutive integers is [1, 4, 4, 0, 2, 3]. The distinct subsequence is [1, 4, 0, 2, 3] having length 5.\r\n\r\nInput : [2, 4, 6, 3, 7, 4, 8, 1]\r\nOutput: 4\r\nExplanation: The longest subsequence formed by the consecutive integers is [2, 4, 3, 4, 1]. The distinct subsequence is [2, 4, 3, 1] having length 4.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Determine Index",
    "link": "https://www.techiedelight.com/?problem=DetermineIndex",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/DetermineIndex/DetermineIndex.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, determine the index of an element before which all elements are smaller and after which all are greater.\r\n\r\nInput: [4, 2, 3, 5, 1, 6, 9, 7]\r\nOutput: 5\r\nExplanation: All elements before index 5 are smaller, and all elements after index 5 are greater.\r\n\r\n\u00e2\u0080\u00a2 In case multiple indices satisfies the problem constraints, the solution should return the minimum index.\r\n\r\nInput: [1, 2, 3, 4, 5]\r\nOutput: 1\r\nExplanation: Index 1, 2, and 3 satisfies the problem constraints. The solution should return the minimum index, i.e., 1.\r\n\r\n\u00e2\u0080\u00a2 For invalid inputs, the solution should return -1.\r\n\r\nInput: [] or [1] or [1, 2] or [5, 4, 3, 2, 1]\r\nOutput: -1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Moves to Convert Array",
    "link": "https://www.techiedelight.com/?problem=MinimumMovesToConvertArray",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumMovesToConvertArray/MinimumMovesToConvertArray.java",
    "problem": "/* START *//*\r\n\r\nFind the minimum number of moves required for converting an array of zeroes to a given array of non-negative integers using only increment and double operations. The increment operation increases the value of an array element by 1 and the double operation doubles the value of each array element.\r\n\r\nInput: [8, 9, 8]\r\nOutput: 7\r\n\r\nExplanation: The optimal sequence to convert an array [0, 0, 0] to [8, 9, 8] requires 3 increment operations, followed by 3 double operations, and a single increment operation:\r\n\r\n[0, 0, 0] \u00e2\u0080\u0094> [1, 0, 0] \u00e2\u0080\u0094> [1, 1, 0] \u00e2\u0080\u0094> [1, 1, 1] \u00e2\u0080\u0094> [2, 2, 2] \u00e2\u0080\u0094> [4, 4, 4] \u00e2\u0080\u0094> [8, 8, 8] \u00e2\u0080\u0094> [8, 9, 8]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Left Rotate Array",
    "link": "https://www.techiedelight.com/?problem=LeftRotateArray",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/LeftRotateArray/LeftRotateArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, left-rotate it by `k` positions, where `k` is a postive integer.\r\n\r\nInput: nums[] = [1, 2, 3, 4, 5], k = 2\r\nOutput: [3, 4, 5, 1, 2]\r\n\r\nInput: nums[] = [1, 2, 3, 4, 5], k = 6\r\nOutput: [1, 2, 3, 4, 5]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Right Rotate Array",
    "link": "https://www.techiedelight.com/?problem=RightRotateArray",
    "category": "Array",
    "tag": "",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RightRotateArray/RightRotateArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, right-rotate it by `k` positions, where `k` is a postive integer.\r\n\r\nInput: nums[] = [1, 2, 3, 4, 5], k = 2\r\nOutput: [4, 5, 1, 2, 3]\r\n\r\nInput: nums[] = [1, 2, 3, 4, 5, 6, 7], k = 3\r\nOutput: [5, 6, 7, 1, 2, 3, 4]\r\n\r\nInput: nums[] = [1, 2, 3, 4, 5], k = 6\r\nOutput: [1, 2, 3, 4, 5]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Activity Selection Problem",
    "link": "https://www.techiedelight.com/?problem=ActivitySelectionProblem",
    "category": "Array, Dynamic Programming, Sorting",
    "tag": "Algorithm, Greedy, Bottom-up",
    "lists": "TopClassic, TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ActivitySelectionProblem/ActivitySelectionProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of activities, along with the starting and finishing time of each activity, find the maximum number of activities performed by a single person assuming that a person can only work on a single activity at a time.\r\n\r\nInput : [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11), (8, 12), (2, 13), (12, 14)]\r\nOutput: {(1, 4), (5, 7), (8, 11), (12, 14)}\r\n\r\nInput : [(3, 7), (1, 3), (2, 9), (2, 7), (1, 2), (7, 8)]\r\nOutput: {(1, 3), (3, 7), (7, 8)} or {(1, 2), (3, 7), (7, 8)} or {(1, 2), (2, 7), (7, 8)}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "K Divisible Pairs",
    "link": "https://www.techiedelight.com/?problem=KDivisiblePairs",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/KDivisiblePairs/KDivisiblePairs.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, determine whether it can be divided into pairs such that the sum of elements in each pair is divisible by a given positive integer `k`.\r\n\r\nInput: nums[] = [3, 1, 2, 6, 9, 4], k = 5\r\nOutput: true\r\nExplanation: Array can be divided into pairs {(3, 2), (1, 9), (4, 6)}, where the sum of elements in each pair is divisible by 5.\r\n\r\nInput: nums[] = [2, 9, 4, 1, 3, 5], k = 6\r\nOutput: true\r\nExplanation: Array can be divided into pairs {(2, 4), (9, 3), (1, 5)}, where the sum of elements in each pair is divisible by 6.\r\n\r\nInput: nums[] = [3, 1, 2, 6, 9, 4], k = 6\r\nOutput: false\r\nExplanation: Array cannot be divided into pairs where the sum of elements in each pair is divisible by 6.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Removals",
    "link": "https://www.techiedelight.com/?problem=MinimumRemovals",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumRemovals/MinimumRemovals.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, trim it such that its maximum element becomes less than twice the minimum, return the minimum number of removals required for the conversion.\r\n\r\nInput : [4, 6, 1, 7, 5, 9, 2]\r\nOutput: 4\r\nExplanation: The trimmed array is [7, 5, 9] where 9 < 2 \u00c3\u0097 5.\r\n\r\nInput : [4, 2, 6, 4, 9]\r\nOutput: 3\r\nExplanation: The trimmed array is [6, 4] where 6 < 2 \u00c3\u0097 4.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Two Sum II",
    "link": "https://www.techiedelight.com/?problem=TwoSumII",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TwoSumII/TwoSumII.java",
    "problem": "/* START *//*\r\n\r\nGiven a circularly sorted integer array, find a pair with a given sum. Assume there are no duplicates in the array, and the rotation is in an anti-clockwise direction around an unknown pivot.\r\n\r\n\u00e2\u0080\u00a2 The solution can return pair in any order.\r\n\r\nInput : nums[] = [10, 12, 15, 3, 6, 8, 9], target = 18\r\nOutput: (3, 15) or (15, 3)\r\n\r\nInput : nums[] = [5, 8, 3, 2, 4], target = 12\r\nOutput: (4, 8) or (8, 4)\r\n\r\n\u00e2\u0080\u00a2 If no pair with the given sum exists, the solution should return null\r\n\r\nInput : nums[] = [9, 15, 2, 3, 7], target = 20\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Greater Elements",
    "link": "https://www.techiedelight.com/?problem=GreaterElements",
    "category": "Array, Stack",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/GreaterElements/GreaterElements.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted integer array, print all greater elements than all elements present to their right.\r\n\r\nInput : [10, 4, 6, 3, 5]\r\nOutput: [10, 6, 5]\r\nExplanation: The elements that are greater than all elements to their right are 10, 6, and 5.\r\n\r\nNote: The solution should return the elements in the same order as they appear in the input array.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sort Array",
    "link": "https://www.techiedelight.com/?problem=SortArray",
    "category": "Array, Sorting, Divide & Conquer, Heap",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SortArray/SortArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, in-place sort it without using any inbuilt functions.\r\n\r\nInput : [6, 3, 4, 8, 2, 9]\r\nOutput: [2, 3, 4, 6, 8, 9]\r\n\r\nInput : [9, -3, 5, -2, -8, -6]\r\nOutput: [-8, -6, -3, -2, 5, 9]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Counting Sort",
    "link": "https://www.techiedelight.com/?problem=CountingSort",
    "category": "Array, Sorting",
    "tag": "Algorithm",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CountingSort/CountingSort.java",
    "problem": "/* START *//*\r\n\r\nGiven a collection of `n` items, each of which has a non-negative integer key whose maximum value is at most `k`, effectively sort it using the counting sort algorithm.\r\n\r\nInput : nums[] = [4, 2, 10, 10, 1, 4, 2, 1, 10], k = 10\r\nOutput: [1, 1, 2, 2, 4, 4, 10, 10, 10]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Inversion Count",
    "link": "https://www.techiedelight.com/?problem=InversionCount",
    "category": "Array, Divide & Conquer, Sorting",
    "tag": "Algorithm, Recursive",
    "lists": "TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/InversionCount/InversionCount.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the total number of inversions of it. If `(i < j)` and `(nums[i] > nums[j])`, then pair `(i, j)` is called an inversion of an array `nums`. The solution should provide count of all such pairs in the array.\r\n\r\nInput : [1, 9, 6, 4, 5]\r\nOutput: 5\r\nExplanation: There are 5 inversions in the array: (9, 6), (9, 4), (9, 5), (6, 4), (6, 5)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Inversion Count II",
    "link": "https://www.techiedelight.com/?problem=InversionCountII",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/InversionCountII/InversionCountII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, count the total number of triplets, which leads to an inversion. If (i < j < k) and (nums[i] > nums[j] > nums[k]), then the triplet (i, j, k) has formed an inversion in array `nums`.\r\n\r\nInput : [1, 9, 6, 4, 5]\r\nOutput: 2\r\nExplanation: There are two inversions of size three in the array: (9, 6, 4) and (9, 6, 5).\r\n\r\nInput : [9, 4, 3, 5, 1]\r\nOutput: 5\r\nExplanation: There are five inversions of size three in the array: (9, 4, 3), (9, 4, 1), (9, 3, 1), (4, 3, 1), and (9, 5, 1).\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sort by Frequency and Index",
    "link": "https://www.techiedelight.com/?problem=SortByFrequencyAndIndex",
    "category": "Array, Sorting",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortByFrequencyAndIndex/SortByFrequencyAndIndex.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, in-place sort its element by their frequency and index. If two elements have different frequencies, then the one which has more frequency should come first; otherwise, the one which has less index should come first, i.e., the solution should preserve the relative order of the equal frequency elements.\r\n\r\nInput : [3, 3, 1, 1, 1, 8, 3, 6, 8, 7, 8]\r\nOutput: [3, 3, 3, 1, 1, 1, 8, 8, 8, 6, 7]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sort with Duplicates",
    "link": "https://www.techiedelight.com/?problem=SortWithDuplicates",
    "category": "Array, Divide & Conquer, Sorting",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortWithDuplicates/SortWithDuplicates.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array with many duplicated elements, efficiently sort it in linear time.\r\n\r\nInput : [4, 2, 40, 10, 10, 1, 4, 2, 1, 10, 40]\r\nOutput: [1, 1, 2, 2, 4, 4, 10, 10, 10, 40, 40]\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The input elements lie in the range [0, 1000].\r\n\u00e2\u0080\u00a2 The relative order of equal elements doesn't matter.\r\n\u00e2\u0080\u00a2 The sorting should be done in-place.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Largest Number",
    "link": "https://www.techiedelight.com/?problem=LargestNumber",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LargestNumber/LargestNumber.java",
    "problem": "/* START *//*\r\n\r\nFind the largest number possible from a set of given numbers, where the numbers append to each other in any order to form the largest number. The solution should return the string representation of the largest number.\r\n\r\nInput : [10, 68, 75, 7, 21, 12]\r\nOutput: 77568211210\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Surpasser Count",
    "link": "https://www.techiedelight.com/?problem=SurpasserCount",
    "category": "Array, Sorting",
    "tag": "Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/SurpasserCount/SurpasserCount.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array having distinct elements, find the surpasser count for each element in it. In other words, for each array element, find the total number of elements to its right, which are greater than it.\r\n\r\nInput : [4, 6, 3, 9, 7, 10]\r\nOutput: [4, 3, 3, 1, 1, 0]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "3 Partition Problem",
    "link": "https://www.techiedelight.com/?problem=3PartitionProblem",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Hashing, Recursive, Top-down",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/3PartitionProblem/3PartitionProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a set S of positive integers, determine if it can be partitioned into three disjoint subsets that all have the same sum, and they cover S.\r\n\r\nInput: S = [7, 3, 2, 1, 5, 4, 8]\r\nOutput: true\r\nExplanation: S can be partitioned into three partitions [[7, 3], [5, 4, 1], [8, 2]], each having a sum of 10.\r\n\r\nNote that there can be multiple solutions to a single set.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "3 Partition Problem II",
    "link": "https://www.techiedelight.com/?problem=3PartitionProblemII",
    "category": "Array",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/3PartitionProblemII/3PartitionProblemII.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of positive integers, which can be partitioned into three disjoint subsets having the same sum, return the partitions.\r\n\r\nInput: S = [7, 3, 2, 1, 5, 4, 8]\r\nOutput: [[7, 3], [5, 4, 1], [8, 2]]\r\nExplanation: S can be partitioned into three partitions, each having a sum of 10.\r\n\r\nNote that there can be multiple solutions to a single set, the procedure can return any one of them.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "K Partition Problem",
    "link": "https://www.techiedelight.com/?problem=KPartitionProblem",
    "category": "Array, Backtracking",
    "tag": "Algorithm, Recursive",
    "lists": "TopClassic, TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/KPartitionProblem/KPartitionProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of positive integers, partition it into `k` disjoint subsets that all have an equal sum, and they completely cover the array.\r\n\r\nInput : S[] = [7, 3, 5, 12, 2, 1, 5, 3, 8, 4, 6, 4], k = 2\r\nOutput: [[5, 3, 8, 4, 6, 4], [7, 3, 5, 12, 2, 1]] or [[4, 5, 6, 7, 8], [1, 2, 3, 3, 4, 5, 12]]\r\nExplanation: S can be partitioned into 2 partitions, each having a sum of 30.\r\n\r\nInput : S[] = [7, 3, 5, 12, 2, 1, 5, 3, 8, 4, 6, 4], k = 3\r\nOutput: [[2, 1, 3, 4, 6, 4], [7, 5, 8], [3, 5, 12]]\r\nExplanation: S can be partitioned into 3 partitions, each having a sum of 20.\r\n\r\nInput : S[] = [7, 3, 5, 12, 2, 1, 5, 3, 8, 4, 6, 4], k = 4\r\nOutput: [[1, 4, 6, 4], [2, 5, 8], [12, 3], [7, 3, 5]]\r\nExplanation: S can be partitioned into 4 partitions, each having a sum of 15.\r\n\r\nInput : S[] = [7, 3, 5, 12, 2, 1, 5, 3, 8, 4, 6, 4], k = 5\r\nOutput: [[2, 6, 4], [8, 4], [3, 1, 5, 3], [12], [7, 5]]\r\nExplanation: S can be partitioned into 5 partitions, each having a sum of 12.\r\n\r\nInput : S[] = [3, 5, 7, 3, 2, 1], k = 2\r\nOutput: []\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Merge Operations",
    "link": "https://www.techiedelight.com/?problem=MinimumMergeOperations",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumMergeOperations/MinimumMergeOperations.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of non-negative integers, find the minimum number of merge operations to make it a palindrome.\r\n\r\nInput : [6, 1, 3, 7]\r\nOutput: 1\r\nExplanation: [6, 1, 3, 7] \u00e2\u0080\u0094> Merge 6 and 1 \u00e2\u0080\u0094> [7, 3, 7]\r\n\r\nInput : [6, 1, 4, 3, 1, 7]\r\nOutput: 2\r\nExplanation: [6, 1, 4, 3, 1, 7] \u00e2\u0080\u0094> Merge 6 and 1 \u00e2\u0080\u0094> [7, 4, 3, 1, 7] \u00e2\u0080\u0094> Merge 3 and 1 \u00e2\u0080\u0094> [7, 4, 4, 7]\r\n\r\nInput : [1, 3, 3, 1]\r\nOutput: 0\r\nExplanation: The list is already a palindrome\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Coin Change Problem",
    "link": "https://www.techiedelight.com/?problem=CoinChangeProblem",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopDP",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CoinChangeProblem/CoinChangeProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven an unlimited supply of coins of given denominations, find the minimum number of coins required to get the desired change.\r\n\r\nInput: S = [1, 3, 5, 7], target = 15\r\nOutput: 3\r\nExplanation: The minimum number of coins required is 3 (7 + 7 + 1) or (5 + 5 + 5) or (3 + 5 + 7)\r\n\r\nInput: S = [1, 3, 5, 7], target = 18\r\nOutput: 4\r\nExplanation: The minimum number of coins required is 4 (7 + 7 + 3 + 1) or (5 + 5 + 5 + 3) or (7 + 5 + 5 + 1)\r\n\r\nIf desired change is not possible, the solution should return -1.\r\n\r\nInput: S = [2, 4, 6, 8], target = 15\r\nOutput: -1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Coin Change Problem II",
    "link": "https://www.techiedelight.com/?problem=CoinChangeProblemII",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/CoinChangeProblemII/CoinChangeProblemII.java",
    "problem": "/* START *//*\r\n\r\nGiven an unlimited supply of coins of given denominations, find the total number of distinct ways to get the desired change.\r\n\r\nInput: S = [1, 3, 5, 7], target = 8\r\nOutput: 6\r\nExplanation: The total number of ways is 6\r\n\r\n[1, 7]\r\n[3, 5]\r\n[1, 1, 3, 3]\r\n[1, 1, 1, 5]\r\n[1, 1, 1, 1, 1, 3]\r\n[1, 1, 1, 1, 1, 1, 1, 1]\r\n\r\n\r\nInput: S = [1, 2, 3], target = 4\r\nOutput: 4\r\nExplanation: The total number of ways is 4\r\n\r\n[1, 3]\r\n[2, 2]\r\n[1, 1, 2]\r\n[1, 1, 1, 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Next Greater Element",
    "link": "https://www.techiedelight.com/?problem=NextGreaterElement",
    "category": "Array, Stack",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/NextGreaterElement/NextGreaterElement.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the next greater element for every array element. The next greater element of a number x is the first greater number to the right of x in the array.\r\n\r\nIn other words, for each element A[i] in the array A, find an element A[j] such that j > i and A[j] > A[i] and the value of j should be as minimum as possible. If the next greater element doesn't exist in the array for any element, consider it -1.\r\n\r\nInput:  [2, 7, 3, 5, 4, 6, 8]\r\nOutput: [7, 8, 5, 6, 6, 8, -1]\r\n\r\nInput:  [5, 4, 3, 2, 1]\r\nOutput: [-1, -1, -1, -1, -1]\r\n\r\nNote that the next greater element for the last array element is always -1.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Next Greater Element II",
    "link": "https://www.techiedelight.com/?problem=NextGreaterElementII",
    "category": "Array, Stack",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/NextGreaterElementII/NextGreaterElementII.java",
    "problem": "/* START *//*\r\n\r\nGiven a circular integer array, find the next greater element for every element in it. The next greater element of an element `x` in the array is the first larger number to the next of `x`.\r\n\r\nIn a circular array, the indices will wrap around as if it were connected end-to-end. In other words, the end of the array wraps around to the start of the array. This facilitate searching circularly to find the next greater number. If the next greater element doesn't exist, consider it to be -1.\r\n\r\nInput : [3, 5, 2, 4]\r\nOutput: [5, -1, 4, 5]\r\n\r\nInput : [7, 5, 3, 4]\r\nOutput: [-1, 7, 4, 7]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Previous Smaller Element",
    "link": "https://www.techiedelight.com/?problem=PreviousSmallerElement",
    "category": "Array, Stack",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PreviousSmallerElement/PreviousSmallerElement.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the previous smaller element for every array element. The previous smaller element of a number `x` is the first smaller number to the left of `x` in the array.\r\n\r\nIn other words, for each element A[i] in the array A, find an element A[j] such that j < i and A[j] < A[i] and value of j should be as maximum as possible. If the previous smaller element doesn't in the array for any element, consider it -1.\r\n\r\nInput : [2, 5, 3, 7, 8, 1, 9]\r\nOutput: [-1, 2, 2, 3, 7, -1, 1]\r\n\r\nInput : [5, 7, 4, 9, 8, 10]\r\nOutput: [-1, 5, -1, 4, 4, 8]\r\n\r\nNote that the first element always has a previous smaller element as -1.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Increasing Subsequence",
    "link": "https://www.techiedelight.com/?problem=LongestIncreasingSubsequence",
    "category": "Array, Dynamic Programming, Sorting, Stack",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LongestIncreasingSubsequence/LongestIncreasingSubsequence.java",
    "problem": "/* START *//*\r\n\r\nGiven a given sequence, find the length of the longest increasing subsequence (LIS) in it.\r\n\r\nThe longest increasing subsequence is a subsequence of a given sequence in which the subsequence's elements are in sorted order, lowest to highest, and in which the subsequence is as long as possible.\r\n\r\nInput : [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\r\nOutput: 6\r\nExplanation: The longest increasing subsequence is [0, 2, 6, 9, 11, 15] having length 6; the input sequence has no 7\u00e2\u0080\u0093member increasing subsequences.\r\n\r\nThe longest increasing subsequence is not necessarily unique. For instance, [0, 4, 6, 9, 11, 15] and [0, 4, 6, 9, 13, 15] are other increasing subsequences of equal length in the same input sequence.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Increasing Subsequence II",
    "link": "https://www.techiedelight.com/?problem=LongestIncreasingSubsequenceII",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopLiked, TopDP",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LongestIncreasingSubsequenceII/LongestIncreasingSubsequenceII.java",
    "problem": "/* START *//*\r\n\r\nGiven a given sequence, find the longest increasing subsequence (LIS) in it.\r\n\r\nThe longest increasing subsequence is a subsequence of a given sequence in which the subsequence's elements are in sorted order, lowest to highest, and in which the subsequence is as long as possible.\r\n\r\nThe longest increasing subsequence is not necessarily unique, the solution can return any valid subsequence.\r\n\r\nInput : [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\r\nOutput: [0, 2, 6, 9, 11, 15] or [0, 4, 6, 9, 11, 15] or [0, 4, 6, 9, 13, 15]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Merging Overlapping Intervals",
    "link": "https://www.techiedelight.com/?problem=MergingOverlappingIntervals",
    "category": "Array, Sorting, Stack",
    "tag": "Algorithm",
    "lists": "TopClassic",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MergingOverlappingIntervals/MergingOverlappingIntervals.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of intervals, return all non-overlapping intervals after merging the overlapping intervals.\r\n\r\nInput : [(1, 5), (2, 3), (4, 6), (7, 8), (8, 10), (12, 15)]\r\nOutput: {(1, 6), (7, 10), (12, 15)}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Overlapping Intervals",
    "link": "https://www.techiedelight.com/?problem=MaximumOverlappingIntervals",
    "category": "Array, Sorting",
    "tag": "Algorithm",
    "lists": "TopClassic",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumOverlappingIntervals/MaximumOverlappingIntervals.java",
    "problem": "/* START *//*\r\n\r\nConsider an event where a log register is maintained containing the guest's arrival and departure times. Given an array of arrival and departure times from entries in the log register, find the first occurrence when maximum guests were present in the event.\r\n\r\nInput:\r\n\r\narrival = [1, 2, 4, 7, 8, 12]\r\ndeparture = [2, 7, 8, 12, 10, 15]\r\n\r\nOutput: 7\r\n\r\nExplanation: Maximum number of guests is 3, present at time 7 as shown below:\r\n\r\nhttps://techiedelight.com/practice/images/Maximum-Overlapping-Interval.png\r\n\r\n\r\nNote: If an arrival and departure event coincides, the arrival time is preferred over the departure time.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Unattended Customers Count",
    "link": "https://www.techiedelight.com/?problem=UnattendedCustomersCount",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/UnattendedCustomersCount/UnattendedCustomersCount.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer representing the capacity of a cyber cafe and a sequence representing entry/exit logs of customers, find the total number of customers who could not get any computer.\r\n\r\nThe first occurrence in the given sequence indicates the arrival, and the second occurrence indicates the departure for a customer. A customer cannot be serviced when the cafe capacity is full (when all computers are allocated).\r\n\r\nInput:\r\n\r\nsequence = \"ABCDDCEFFEBGAG\"\r\ncapacity = 3\r\n\r\nOutput: 2\r\n\r\nExplanation: Customers 'D' and 'F' left unattended\r\n\r\n\r\nInput:\r\n\r\nsequence = \"ABCDDCBEFFEGAG\"\r\ncapacity = 2\r\n\r\nOutput: 3\r\n\r\nExplanation: Customers 'C', 'D', and 'F' left unattended\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Number K Swaps",
    "link": "https://www.techiedelight.com/?problem=MinimumNumberKSwaps",
    "category": "Backtracking, String",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumNumberKSwaps/MinimumNumberKSwaps.java",
    "problem": "/* START *//*\r\n\r\nGiven string representation of a positive integer, find the minimum number possible by doing at-most `k` swap operations upon its digits.\r\n\r\nInput : s = \"934651\", k = 1\r\nOutput: 134659\r\n\r\nInput : s = \"934651\", k = 2\r\nOutput: 134569\r\n\r\nInput : s = \"52341\", k = 2\r\nOutput: 12345 (Only 1 swap needed)\r\n\r\nInput : s = \"12345\", k = 2\r\nOutput: 12345 (no change as all digits are already sorted in increasing order)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rod Cutting",
    "link": "https://www.techiedelight.com/?problem=RodCutting",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked, TopDP",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RodCutting/RodCutting.java",
    "problem": "/* START *//*\r\n\r\nGiven a rod of length `n` and a list of rod prices of length `i`, where `1 <= i <= n`, find the optimal way to cut the rod into smaller rods to maximize profit.\r\n\r\nInput:\r\n\r\nn = 4 \t\t\t\t\t\t\t\t\t(Rod length)\r\nprice = [1, 5, 8, 9, 10, 17, 17, 20]\t(Rod of length `i` has a cost price[i-1])\r\n\r\nOutput: 10\r\nExplanation: Cut the rod into two pieces of length 2 each to gain revenue of 5 + 5 = 10\r\n\r\nCut\t\t  \t\tProfit\r\n\r\n4\t\t\t\t9\r\n1, 3\t\t\t(1 + 8) = 9\r\n2, 2\t\t\t(5 + 5) = 10\t  <-- optimal way\r\n3, 1\t\t\t(8 + 1) = 9\r\n1, 1, 2\t\t\t(1 + 1 + 5) = 7\r\n1, 2, 1\t\t\t(1 + 5 + 1) = 7\r\n2, 1, 1\t\t\t(5 + 1 + 1) = 7\r\n1, 1, 1, 1\t\t(1 + 1 + 1 + 1) = 4\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rod Cutting II",
    "link": "https://www.techiedelight.com/?problem=RodCuttingII",
    "category": "Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RodCuttingII/RodCuttingII.java",
    "problem": "/* START *//*\r\n\r\nGiven a rod of length n, find the optimal way to cut the rod into smaller rods to maximize the product of each of the smaller rod's price. Assume that each rod of length i has price i.\r\n\r\nInput: n = 4 (rod length)\r\nOutput: 4\r\nExplanation: Cut the rod into two pieces of length 2 each to gain revenue of 2\u00c3\u00972 = 4\r\n\r\nCut\t\t\t\tProfit\r\n4\t\t\t\t4\r\n1, 3\t\t\t(1 \u00c3\u0097 3) = 3\r\n2, 2\t\t\t(2 \u00c3\u0097 2) = 4\t  <-- optimal way\r\n3, 1\t\t\t(3 \u00c3\u0097 1) = 3\r\n1, 1, 2\t\t\t(1 \u00c3\u0097 1 \u00c3\u0097 2) = 2\r\n1, 2, 1\t\t\t(1 \u00c3\u0097 2 \u00c3\u0097 1) = 2\r\n2, 1, 1\t\t\t(2 \u00c3\u0097 1 \u00c3\u0097 1) = 2\r\n1, 1, 1, 1\t\t(1 \u00c3\u0097 1 \u00c3\u0097 1 \u00c3\u0097 1) = 1\r\n\r\nSimilarly, for n = 6, (3 \u00c3\u0097 3) = 9\r\nFor n = 8, (2 \u00c3\u0097 3 \u00c3\u0097 3) = 18\r\nFor n = 15, (3 \u00c3\u0097 3 \u00c3\u0097 3 \u00c3\u0097 3 \u00c3\u0097 3) = 243\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shrink Array",
    "link": "https://www.techiedelight.com/?problem=ShrinkArray",
    "category": "Array, Dynamic Programming",
    "tag": "Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ShrinkArray/ShrinkArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array and an integer k, shrink it by removing adjacent triplets that satisfy the given constraints and return the total number of elements in the resultant array.\r\n\r\nA triplet (x, y, z) can only be removed if, for the number k, the second element y of the triplet is precise k more than the first element x. The third element, z, is precise k more than the second element y. The total number of elements in the final array should be as few as possible.\r\n\r\nInput: nums = [1, 2, 3, 5, 7, 8], k = 2\r\nOutput: 3\r\nExplanation: The adjacent triplet (3, 5, 7) can be removed from the array. The resultant array is [1, 2, 8] cannot be reduced further.\r\n\r\nInput: nums = [-1, 0, 1, 2, 3, 4], k = 1\r\nOutput: 0\r\nExplanation: The result is 0 since all elements can be removed from the array. First, the adjacent triplet (2, 3, 4) is removed. The array is now reduced to [-1, 0, 1], which forms another valid triplet and can be removed from the array.\r\n\r\nNote that if the adjacent triplet (1, 2, 3) is removed from the array first, the resultant array [-1, 0, 4] cannot be reduced further.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sort K Sorted Array",
    "link": "https://www.techiedelight.com/?problem=SortKSortedArray",
    "category": "Array, Heap",
    "tag": "Priority Queue",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortKSortedArray/SortKSortedArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array whose elements may be misplaced by no more than `k` positions from the correct sorted order, efficiently sort it in linear time and constant space.\r\n\r\nInput: nums[] = [1, 4, 5, 2, 3, 7, 8, 6, 10, 9], k = 2\r\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Job Sequencing Problem",
    "link": "https://www.techiedelight.com/?problem=JobSequencingProblem",
    "category": "Array, Sorting",
    "tag": "Algorithm, Greedy",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/JobSequencingProblem/JobSequencingProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of tasks with deadlines and total profit earned on completing a task, find the maximum profit earned by executing the tasks within the specified deadlines. Assume that each task takes one unit of time to complete, and a task can't execute beyond its deadline.\r\n\r\nInput: (Task Id, Deadline, Profit)\r\n\r\n[(1, 9, 15), (2, 2, 2), (3, 5, 18), (4, 7, 1), (5, 4, 25), (6, 2, 20), (7, 5, 8), (8, 7, 10), (9, 4, 12), (10, 3, 5)]\r\n\r\nOutput: {1, 3, 4, 5, 6, 7, 8, 9}\r\nExplanation: The maximum profit that can be achieved is 109 by leaving tasks 2 and 10 out.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 Only a single task can be executed at a time.\r\n\u00e2\u0080\u00a2 The maximum number of tasks are 100.\r\n\u00e2\u0080\u00a2 The maximum deadline that can be associated with a job is 1000.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Employees Manager Mapping",
    "link": "https://www.techiedelight.com/?problem=EmployeesManagerMapping",
    "category": "Dynamic Programming",
    "tag": "Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/EmployeesManagerMapping/EmployeesManagerMapping.java",
    "problem": "/* START *//*\r\n\r\nGiven a map containing employee to manager mappings, find all employees under each manager who directly or indirectly reports him.\r\n\r\nInput : {'A': 'A', 'B': 'A', 'C': 'B', 'D': 'B', 'E': 'D', 'F': 'E'}\r\nOutput: {'A': ['E', 'C', 'B', 'D', 'F'], 'B': ['D', 'E', 'C', 'F'], 'C': [], 'D': ['E', 'F'], 'E': ['F'], 'F': []}\r\nExplanation: The input represents the following employee-manager pairs:\r\n\r\n'A' \u00e2\u0080\u0094> 'A'\r\n'B' \u00e2\u0080\u0094> 'A'\r\n'C' \u00e2\u0080\u0094> 'B'\r\n'D' \u00e2\u0080\u0094> 'B'\r\n'E' \u00e2\u0080\u0094> 'D'\r\n'F' \u00e2\u0080\u0094> 'E'\r\n\r\nHere, 'A' reports to himself, i.e., 'A' is head of the company and is the manager of employee 'B'. 'B' is the manager of employees 'C' and 'D', 'D' is the manager of employee 'E', 'E' is the manager of employee 'F', 'C', and 'F' is not managers of any employee. i.e.,\r\n\r\n'A' \u00e2\u0080\u0094> ['B', 'D', 'C', 'E', 'F']\r\n'B' \u00e2\u0080\u0094> ['D', 'C', 'E', 'F']\r\n'C' \u00e2\u0080\u0094> []\r\n'D' \u00e2\u0080\u0094> ['E', 'F']\r\n'E' \u00e2\u0080\u0094> ['F']\r\n'F' \u00e2\u0080\u0094> []\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Largest Square Submatrix",
    "link": "https://www.techiedelight.com/?problem=LargestSquareSubmatrix",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LargestSquareSubmatrix/LargestSquareSubmatrix.java",
    "problem": "/* START *//*\r\n\r\nGiven a binary matrix, find size of the largest square submatrix, which is surrounded by all 1\u00e2\u0080\u0099s.\r\n\r\nInput:\r\n[\r\n\t[1, 1, 1, 1, 1, 1],\r\n\t[1, 0, 1, 1, 0, 1],\r\n\t[0, 1, 1, 0, 0, 1],\r\n\t[1, 1, 1, 1, 1, 1],\r\n\t[1, 0, 0, 1, 0, 1],\r\n\t[1, 0, 1, 1, 0, 0],\r\n\t[1, 0, 1, 0, 1, 1],\r\n\t[1, 1, 1, 0, 1, 1]\r\n]\r\n\r\nOutput: 4\r\n\r\nExplanation: The size of the largest square submatrix in the following binary matrix is 4. The largest square submatrix is formed by cells (0, 2), (3, 2), (0, 5), and (3, 5).\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Largest Square Submatrix II",
    "link": "https://www.techiedelight.com/?problem=LargestSquareSubmatrixII",
    "category": "Dynamic Programming, Matrix",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LargestSquareSubmatrixII/LargestSquareSubmatrixII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` binary matrix, find the size of the largest square submatrix of 1\u00e2\u0080\u0099s in it.\r\n\r\nInput:\r\n\r\n[\r\n\t[0, 0, 1, 0, 1, 1],\r\n\t[0, 1, 1, 1, 0, 0],\r\n\t[0, 0, 1, 1, 1, 1],\r\n\t[1, 1, 0, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 0, 1, 0, 1],\r\n\t[1, 0, 1, 1, 1, 1],\r\n\t[1, 1, 1, 0, 1, 1]\r\n]\r\n\r\nOutput: 3\r\n\r\nExplanation: The largest square submatrix of 1\u00e2\u0080\u0099s is marked below by `x`.\r\n\r\n\t0  0  1  0  1  1\r\n\t0  1  1  1  0  0\r\n\t0  0  1  x  x  x\r\n\t1  1  0  x  x  x\r\n\t1  1  1  x  x  x\r\n\t1  1  0  1  0  1\r\n\t1  0  1  1  1  1\r\n\t1  1  1  0  1  1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Largest Rectangle Area",
    "link": "https://www.techiedelight.com/?problem=LargestRectangleArea",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LargestRectangleArea/LargestRectangleArea.java",
    "problem": "/* START *//*\r\n\r\nGiven a rectangular binary matrix, calculate the area of the largest rectangle of 1\u00e2\u0080\u0099s in it. Assume that a rectangle can be formed by swapping any number of columns with each other.\r\n\r\nInput:\r\n\r\n[\r\n\t[0, 1, 0, 1, 1],\r\n\t[1, 1, 0, 0, 1],\r\n\t[1, 1, 0, 1, 1],\r\n\t[1, 1, 1, 1, 1]\r\n]\r\n\r\nOutput: 9\r\n\r\nExplanation: The area of the largest rectangle of 1\u00e2\u0080\u0099s is 9. The largest rectangle of 1\u00e2\u0080\u0099s can be formed by swapping column 3 with column 5.\r\n\r\n[0, 1, 1, 1, 0]\r\n[1, 1, 1, 0, 0]\r\n[1, 1, 1, 1, 0]\r\n[1, 1, 1, 1, 1]\r\n\r\n\r\nInput:\r\n\r\n[\r\n\t[0, 1, 1, 0],\r\n\t[1, 0, 0, 1],\r\n\t[1, 1, 0, 1],\r\n\t[1, 1, 1, 1]\r\n]\r\n\r\nOutput: 6\r\n\r\nExplanation: The area of the largest rectangle of 1\u00e2\u0080\u0099s is 6. The largest rectangle of 1\u00e2\u0080\u0099s can be formed by swapping column 2 with column 4 or swapping column 3 with column 4.\r\n\r\n[0, 0, 1, 1]\r\n[1, 1, 0, 0]\r\n[1, 1, 0, 1]\r\n[1, 1, 1, 1]\r\n\r\nOR\r\n\r\n[0, 1, 0, 1]\r\n[1, 0, 1, 0]\r\n[1, 1, 1, 0]\r\n[1, 1, 1, 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Difference Pair II",
    "link": "https://www.techiedelight.com/?problem=MaximumDifferencePairII",
    "category": "Matrix",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumDifferencePairII/MaximumDifferencePairII.java",
    "problem": "/* START *//*\r\n\r\nGiven a square matrix of integers, find the maximum value of `M[c][d] - M[a][b]` over every choice of indexes such that `c > a` and `d > b` in a single traversal of the matrix.\r\n\r\nInput:\r\n\r\n[\r\n\t[ 1,  2, -1, -4, -20],\r\n\t[-8, -3,  4,  2,  1],\r\n\t[ 3,  8,  6,  1,  3],\r\n\t[-4, -1,  1,  7, -6],\r\n\t[ 0, -4, 10, -5,  1]\r\n]\r\n\r\nOutput: 18\r\n\r\nExplanation: The maximum value is 18 as M[4][2] \u00e2\u0080\u0093 M[1][0] has maximum difference.\r\n\r\nAssume: matrix size > 1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shortest Path II",
    "link": "https://www.techiedelight.com/?problem=ShortestPathII",
    "category": "Matrix, Queue",
    "tag": "Breadth-First Search",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ShortestPathII/ShortestPathII.java",
    "problem": "/* START *//*\r\n\r\nGiven a rectangular field with few sensors present, cross it by taking the shortest safe route without activating the sensors.\r\n\r\nThe rectangular field is in the form of an `M \u00c3\u0097 N` matrix, find the shortest path from any cell in the first column to any cell in the last column of the matrix. The sensors are marked by the value 0 in the matrix, and all its eight adjacent cells can also activate the sensors. The path can only be constructed out of cells having value 1, and at any given moment, you are only allowed to move one step in either of the 4 directions - Up, Left, Down, Right.\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[0, 1, 1, 1, 0, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 0, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 0, 1, 1, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\r\n\t[1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\r\n]\r\n\r\nOutput: 11\r\n\r\nThe shortest safe path has a length of 11, and the route is marked in green below.\r\n\r\nhttps://techiedelight.com/practice/images/Shortest-Path.png\r\n\r\nThe solution should return -1 if there is no safe route to reach the destination.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shortest Path III",
    "link": "https://www.techiedelight.com/?problem=ShortestPathIII",
    "category": "Matrix, Queue",
    "tag": "Breadth-First Search",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ShortestPathIII/ShortestPathIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a maze in the form of a rectangular matrix, filled with either 'O', 'X', or 'M', where 'O' represents an open cell, 'X' represents a blocked cell, and 'M' represents landmines in the maze, find the shortest distance of every open cell in the maze from its nearest mine.\r\n\r\nThe task is to find the shortest distance of every open cell in the maze from its nearest mine. You are only allowed to travel in either of the four directions, and diagonal moves are not allowed. The cells with landmines have a distance of 0, and blocked/unreachable cells have a distance of -1.\r\n\r\nInput:\r\n\r\nmat = [\r\n\t['O', 'M', 'O', 'O', 'X'],\r\n\t['O', 'X', 'X', 'O', 'M'],\r\n\t['O', 'O', 'O', 'O', 'O'],\r\n\t['O', 'X', 'X', 'X', 'O'],\r\n\t['O', 'O', 'M', 'O', 'O'],\r\n\t['O', 'X', 'X', 'M', 'O']\r\n]\r\n\r\nHere, O (Open cell), X (Blocked Cell), and M (Landmine).\r\n\r\nOutput:\r\n\r\n[\r\n\t[1,  0,  1,  2, -1],\r\n\t[2, -1, -1,  1,  0],\r\n\t[3,  4,  3,  2,  1],\r\n\t[3, -1, -1, -1,  2],\r\n\t[2,  1,  0,  1,  2],\r\n\t[3, -1, -1,  0,  1]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Matrix Path",
    "link": "https://www.techiedelight.com/?problem=MatrixPath",
    "category": "Backtracking, Matrix",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MatrixPath/MatrixPath.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix, return all paths that start at the first cell (0, 0) and ends at the last cell (M-1, N-1). You are allowed to move down, right, or diagonally (down-right), but not up or left.\r\n\r\nInput:\r\n[\r\n\t[1, 2, 3],\r\n\t[4, 5, 6],\r\n\t[7, 8, 9]\r\n]\r\n\r\nOutput:\r\n\r\n{\r\n\t[1, 4, 7, 8, 9],\r\n\t[1, 4, 5, 8, 9],\r\n\t[1, 4, 5, 6, 9],\r\n\t[1, 4, 5, 9],\r\n\t[1, 4, 8, 9],\r\n\t[1, 2, 5, 8, 9],\r\n\t[1, 2, 5, 6, 9],\r\n\t[1, 2, 5, 9],\r\n\t[1, 2, 3, 6, 9],\r\n\t[1, 2, 6, 9],\r\n\t[1, 5, 8, 9],\r\n\t[1, 5, 6, 9],\r\n\t[1, 5, 9]\r\n}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Matrix Path II",
    "link": "https://www.techiedelight.com/?problem=MatrixPathII",
    "category": "Backtracking, Matrix, Queue",
    "tag": "Depth-First Search, Breadth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MatrixPathII/MatrixPathII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `N \u00c3\u0097 N` matrix of positive integers, find a path from the first cell of the matrix to its last.\r\n\r\nYou are allowed to move exactly `k` steps from any cell in the matrix where `k` is the cell's value, i.e., from a cell (i, j) having value `k` in a matrix `M`, you can move to (i+k, j), (i-k, j), (i, j+k), or (i, j-k). The diagonal moves are not allowed.\r\n\r\nIn case multiple paths exists, the solution can return any one of them.\r\n\r\nInput:\r\n\r\nM = [\r\n\t[7, 1, 3, 5, 3, 6, 1, 1, 7, 5],\r\n\t[2, 3, 6, 1, 1, 6, 6, 6, 1, 2],\r\n\t[6, 1, 7, 2, 1, 4, 7, 6, 6, 2],\r\n\t[6, 6, 7, 1, 3, 3, 5, 1, 3, 4],\r\n\t[5, 5, 6, 1, 5, 4, 6, 1, 7, 4],\r\n\t[3, 5, 5, 2, 7, 5, 3, 4, 3, 6],\r\n\t[4, 1, 4, 3, 6, 4, 5, 3, 2, 6],\r\n\t[4, 4, 1, 7, 4, 3, 3, 1, 4, 2],\r\n\t[4, 4, 5, 1, 5, 2, 3, 5, 3, 5],\r\n\t[3, 6, 3, 5, 2, 2, 6, 4, 2, 1]\r\n]\r\n\r\nOutput: [(0, 0) (7, 0) (3, 0) (9, 0) (6, 0) (2, 0) (8, 0) (4, 0) (4, 5) (0, 5) (6, 5) (2, 5) (2, 1) (1, 1) (4, 1) (9, 1) (3, 1) (3, 7) (2, 7) (8, 7) (8, 2) (3, 2) (3, 9) (7, 9) (9, 9)]\r\n\r\nor\r\n\r\n[(0, 0) (7, 0) (3, 0) (9, 0) (6, 0) (2, 0) (8, 0) (4, 0) (4, 5) (8, 5) (6, 5) (2, 5) (2, 9) (4, 9) (8, 9) (3, 9) (7, 9) (9, 9)]\r\n\r\nor any other valid path from first cell to last cell.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Matrix Path III",
    "link": "https://www.techiedelight.com/?problem=MatrixPathIII",
    "category": "Backtracking, Matrix",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MatrixPathIII/MatrixPathIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a `N \u00c3\u0097 N` binary matrix, find the total number of unique paths that a robot can take to reach a given destination from a given source.\r\n\r\nPositions in the matrix will either be open or blocked with an obstacle. The value 0 represents a blocked cell and 1 represents an open cell. The robot can only move to positions without obstacles, i.e., the solution should find paths that contain only open cells. Retracing the one or more cells back and forth is not considered a new path. The set of all cells covered in a single path should be unique from other paths. At any given moment, the robot can only move one step in either of the four directions (Top, Down, Left, Right).\r\n\r\nInput:\r\n\r\nmatrix = [\r\n\t[1, 1, 1, 1],\r\n\t[1, 1, 0, 1],\r\n\t[0, 1, 0, 1],\r\n\t[1, 1, 1, 1]\r\n]\r\n\r\nsrc  = (0, 0)\r\ndest = (3, 3)\r\n\r\nOutput: 4\r\n\r\nExplanation: The above matrix contains 4 unique paths from source to destination (Marked with x).\r\n\r\n[x  x  x  x]\t[x  x  1  1]\t[x  1  1  1]\t[x  x  x  x]\r\n[1  1  0  x]\t[1  x  0  1]\t[x  x  0  1]\t[x  x  0  x]\r\n[0  1  0  x]\t[0  x  0  1]\t[0  x  0  1]\t[0  1  0  x]\r\n[1  1  1  x]\t[1  x  x  x]\t[1  x  x  x]\t[1  1  1  x]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Matrix Path IV",
    "link": "https://www.techiedelight.com/?problem=MatrixPathIV",
    "category": "Backtracking, Matrix",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MatrixPathIV/MatrixPathIV.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix, find all paths from the first cell to the last cell. You are only allowed to move down or to the right from the current cell.\r\n\r\nInput:\r\n\r\n[\r\n\t[1, 2, 3],\r\n\t[4, 5, 6],\r\n\t[7, 8, 9]\r\n]\r\n\r\nOutput:\r\n\r\n{\r\n\t[1, 2, 3, 6, 9],\r\n\t[1, 2, 5, 6, 9],\r\n\t[1, 2, 5, 8, 9],\r\n\t[1, 4, 5, 6, 9],\r\n\t[1, 4, 5, 8, 9],\r\n\t[1, 4, 7, 8, 9]\r\n}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Matrix Path V",
    "link": "https://www.techiedelight.com/?problem=MatrixPathV",
    "category": "Dynamic Programming, Matrix",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MatrixPathV/MatrixPathV.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` matrix of integers, count the number of different ways to reach the bottom-right corner of a matrix from its top-left corner with exactly `k` turn allowed and using only the directions right or down.\r\n\r\nA turn is defined as a down move immediately followed by a right move, or a right move immediately followed by a down move.\r\n\r\nInput : M = 3, N = 3, k = 1\r\nOutput: 2\r\nExplanation: Total number of paths are 2, as shown below:\r\n\r\n(0, 0) \u00e2\u0080\u0094> (0, 1) \u00e2\u0080\u0094> (0, 2) \u00e2\u0080\u0094> (1, 2) \u00e2\u0080\u0094> (2, 2)\r\n(0, 0) \u00e2\u0080\u0094> (1, 0) \u00e2\u0080\u0094> (2, 0) \u00e2\u0080\u0094> (2, 1) \u00e2\u0080\u0094> (2, 2)\r\n\r\n\r\nInput : M = 3, N = 3, k = 2\r\nOutput: 2\r\nExplanation: Total number of paths are 2, as shown below:\r\n\r\n(0, 0) \u00e2\u0080\u0094> (0, 1) \u00e2\u0080\u0094> (1, 1) \u00e2\u0080\u0094> (2, 1) \u00e2\u0080\u0094> (2, 2)\r\n(0, 0) \u00e2\u0080\u0094> (1, 0) \u00e2\u0080\u0094> (1, 1) \u00e2\u0080\u0094> (1, 2) \u00e2\u0080\u0094> (2, 2)\r\n\r\n\r\nInput : M = 3, N = 3, k = 4\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Matrix Path VI",
    "link": "https://www.techiedelight.com/?problem=MatrixPathVI",
    "category": "Dynamic Programming, Matrix",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MatrixPathVI/MatrixPathVI.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` rectangular grid, efficiently count all paths starting from the first cell (0, 0) to the last cell (M-1, N-1). You can either move down or move towards right from a cell.\r\n\r\nInput : M = 3, N = 3\r\n\r\nOutput: 6\r\n\r\nExplanation: Total number of paths are 6, as shown below:\r\n\r\n(0, 0) \u00e2\u0080\u0094> (0, 1) \u00e2\u0080\u0094> (0, 2) \u00e2\u0080\u0094> (1, 2) \u00e2\u0080\u0094> (2, 2)\r\n(0, 0) \u00e2\u0080\u0094> (0, 1) \u00e2\u0080\u0094> (1, 1) \u00e2\u0080\u0094> (1, 2) \u00e2\u0080\u0094> (2, 2)\r\n(0, 0) \u00e2\u0080\u0094> (0, 1) \u00e2\u0080\u0094> (1, 1) \u00e2\u0080\u0094> (2, 1) \u00e2\u0080\u0094> (2, 2)\r\n(0, 0) \u00e2\u0080\u0094> (1, 0) \u00e2\u0080\u0094> (2, 0) \u00e2\u0080\u0094> (2, 1) \u00e2\u0080\u0094> (2, 2)\r\n(0, 0) \u00e2\u0080\u0094> (1, 0) \u00e2\u0080\u0094> (1, 1) \u00e2\u0080\u0094> (1, 2) \u00e2\u0080\u0094> (2, 2)\r\n(0, 0) \u00e2\u0080\u0094> (1, 0) \u00e2\u0080\u0094> (1, 1) \u00e2\u0080\u0094> (2, 1) \u00e2\u0080\u0094> (2, 2)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Matrix Path VII",
    "link": "https://www.techiedelight.com/?problem=MatrixPathVII",
    "category": "Dynamic Programming, Matrix",
    "tag": "Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MatrixPathVII/MatrixPathVII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix where each cell has a non-negative cost associated with it, count the number of paths to reach the last cell (M-1, N-1) of the matrix from its first cell (0, 0) such that the path has given cost. You can only move one unit right or one unit down from any cell, i.e., from cell (i, j), you can move to (i, j+1) or (i+1, j).\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[4, 7, 1, 6],\r\n\t[5, 7, 3, 9],\r\n\t[3, 2, 1, 2],\r\n\t[7, 1, 6, 3]\r\n]\r\n\r\ncost: 25\r\n\r\nOutput: 2\r\n\r\nExplanation: The following two paths have a cost of 25.\r\n\r\n\r\n\t4 \u00e2\u0080\u0094 7 \u00e2\u0080\u0094 1   6\t\t\t\t4   7   1   6\r\n\t\t\t|\t\t\t\t\t|\r\n\t5   7   3   9\t\t\t\t5 \u00e2\u0080\u0094 7 \u00e2\u0080\u0094 3   9\r\n\t\t\t|\t\t\t\t\t\t\t|\r\n\t3   2   1   2\t\t\t\t3   2   1 \u00e2\u0080\u0094 2\r\n\t\t\t|\t\t\t\t\t\t\t\t|\r\n\t7   1   6 \u00e2\u0080\u0094 3\t\t\t\t7   1   6   3\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Cost Path",
    "link": "https://www.techiedelight.com/?problem=MinimumCostPath",
    "category": "Dynamic Programming, Matrix",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumCostPath/MinimumCostPath.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` matrix of integers where each cell has a cost associated with it, find the minimum cost to reach the last cell (M-1, N-1) of the matrix from its first cell (0, 0). You can only move one unit right or one unit down from any cell, i.e., from cell (i, j), you can move to (i, j+1) or (i+1, j).\r\n\r\nInput:\r\n\r\n[\r\n\t[4, 7, 8, 6, 4],\r\n\t[6, 7, 3, 9, 2],\r\n\t[3, 8, 1, 2, 4],\r\n\t[7, 1, 7, 3, 7],\r\n\t[2, 9, 8, 9, 3]\r\n]\r\n\r\nOutput: 36\r\n\r\nExplanation: The highlighted path shows the minimum cost path having a cost of 36.\r\n\r\n\t4   7   8   6   4\r\n\t|\r\n\t6 \u00e2\u0080\u0094 7 \u00e2\u0080\u0094 3   9   2\r\n\t\t\t|\r\n\t3   8   1 \u00e2\u0080\u0094 2   4\r\n\t\t\t\t|\r\n\t7   1   7   3 \u00e2\u0080\u0094 7\r\n\t\t\t\t\t|\r\n\t2   9   8   9   3\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Cost Path II",
    "link": "https://www.techiedelight.com/?problem=MinimumCostPathII",
    "category": "Dynamic Programming, Matrix",
    "tag": "Bottom-up",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumCostPathII/MinimumCostPathII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `N \u00c3\u0097 N` matrix of non-negative integers, where each cell of the matrix (i, j) indicates the direct flight cost from the city `i` to city `j`. The task is to find the minimum cost to reach the destination city `N-1` from the source city 0.\r\n\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[0,   20, 30, 100],\r\n\t[20,  0,  15, 75 ],\r\n\t[30,  15, 0,  50 ],\r\n\t[100, 75, 50, 0  ]\r\n]\r\n\r\nOutput: 80\r\n\r\nExplanation: The minimum cost is 80 and the minimum cost path is:\r\n\r\ncity 0 \u00e2\u0080\u0094> city 2 (cost = 30)\r\ncity 2 \u00e2\u0080\u0094> city 3 (cost = 50)\r\n\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[0,  25, 20, 10, 105],\r\n\t[20, 0,  15, 80, 80 ],\r\n\t[30, 15, 0,  70, 90 ],\r\n\t[10, 10, 50, 0,  100],\r\n\t[40, 50, 5,  10, 0  ]\r\n]\r\n\r\nOutput: 100\r\n\r\nExplanation: The minimum cost is 100 and the minimum cost path is:\r\n\r\ncity 0 \u00e2\u0080\u0094> city 3 (cost = 10)\r\ncity 3 \u00e2\u0080\u0094> city 1 (cost = 10)\r\ncity 1 \u00e2\u0080\u0094> city 4 (cost = 80)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Continuous Sequence II",
    "link": "https://www.techiedelight.com/?problem=LongestContinuousSequenceII",
    "category": "Dynamic Programming, Matrix",
    "tag": "Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestContinuousSequenceII/LongestContinuousSequenceII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `N \u00c3\u0097 N` matrix where each cell has a distinct value in the 1 to `N \u00c3\u0097 N`. Find the longest sequence formed by adjacent numbers in the matrix such that for each number, the number on the adjacent neighbor is +1 in its value.\r\n\r\nFrom the location (x, y) in the matrix, you can move to (x, y+1), (x, y-1), (x+1, y), or (x-1, y) if the value at the destination cell is one more than the value at source cell.\r\n\r\nInput:\r\n\r\n[\r\n\t[10, 13, 14, 21, 23],\r\n\t[11, 9,  22, 2,  3],\r\n\t[12, 8,  1,  5,  4],\r\n\t[15, 24, 7,  6,  20],\r\n\t[16, 17, 18, 19, 25]\r\n]\r\n\r\nOutput: [2, 3, 4, 5, 6, 7]\r\n\r\nNote: Assume that the input contains a single longest sequence.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Continuous Sequence III",
    "link": "https://www.techiedelight.com/?problem=LongestContinuousSequenceIII",
    "category": "Dynamic Programming, Matrix",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestContinuousSequenceIII/LongestContinuousSequenceIII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` matrix of characters, find the length of the longest path in the matrix starting from a given character. All characters in the longest path should be increasing and consecutive to each other in alphabetical order.\r\n\r\nYou are allowed to search the string in all eight possible directions, i.e., North, West, South, East, North-East, North-West, South-East, South-West.\r\n\r\nInput:\r\n\r\nmat = [\r\n\t['D', 'E', 'H', 'X', 'B'],\r\n\t['A', 'O', 'G', 'P', 'E'],\r\n\t['D', 'D', 'C', 'F', 'D'],\r\n\t['E', 'B', 'E', 'A', 'S'],\r\n\t['C', 'D', 'Y', 'E', 'N']\r\n]\r\nch = 'C'\r\n\r\nOutput: 6\r\n\r\nExplanation: The longest path with consecutive characters starting from character `C` is: C(2, 2) \u00e2\u0080\u0094> D(2, 1) \u00e2\u0080\u0094> E(3, 2) \u00e2\u0080\u0094> F(2, 3) \u00e2\u0080\u0094> G(1, 2) \u00e2\u0080\u0094> H(0, 2)\r\n\r\n\r\nInput:\r\n\r\nmat = [\r\n\t['A', 'B', 'C'],\r\n\t['D', 'E', 'F']\r\n]\r\nch = 'I'\r\n\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Collect Maximum Points",
    "link": "https://www.techiedelight.com/?problem=CollectMaximumPoints",
    "category": "Dynamic Programming, Matrix",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/CollectMaximumPoints/CollectMaximumPoints.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` matrix where each cell can have a value of 1, 0, or -1, where -1 denotes an unsafe cell, collect the maximum number of ones starting from the first cell and by visiting only safe cells (i.e., 0 or 1). If the row is odd, you are only allowed to go left or down from the current cell; if the row is even, you can go right or down.\r\n\r\nInput:\r\n\r\n[\r\n\t[ 1,  1, -1,  1,  1],\r\n\t[ 1,  0,  0, -1,  1],\r\n\t[ 1,  1,  1,  1, -1],\r\n\t[-1, -1,  1,  1,  1],\r\n\t[ 1,  1, -1, -1,  1]\r\n]\r\n\r\nOutput: 9\r\n\r\nExplanation: The maximum value that can be collected is 9, as marked below.\r\n\r\n\r\n\t1 \u00e2\u0080\u0094 1  -1   1   1\r\n\t\t|\r\n\t1 \u00e2\u0080\u0094 0   0  -1   1\r\n\t|\r\n\t1 \u00e2\u0080\u0094 1 \u00e2\u0080\u0094 1 \u00e2\u0080\u0094 1  -1\r\n\t\t\t\t|\r\n   -1  -1   1 \u00e2\u0080\u0094 1   1\r\n\r\n\t1   1  -1  -1   1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Tiles Problem",
    "link": "https://www.techiedelight.com/?problem=TilesProblem",
    "category": "Dynamic Programming, Matrix",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TilesProblem/TilesProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven an `n \u00c3\u0097 4` matrix where `n` is a positive number, find the number of ways to fill the matrix with `1 \u00c3\u0097 4` tiles.\r\n\r\nInput: n = 5\r\nOutput: 3\r\nExplanation: There are three ways to place `1 \u00c3\u0097 4` tiles in a `5 \u00c3\u0097 4` matrix:\r\n\r\n\u00e2\u0080\u00a2 Place all 5 tiles horizontally.\r\n\u00e2\u0080\u00a2 Place 4 tiles vertically in the first four rows and 1 tile horizontally in the last row.\r\n\u00e2\u0080\u00a2 Place 1 tile horizontally in the first row and adjust 4 tiles vertically in the remaining rows.\r\n\r\n\r\nInput: n = 6\r\nOutput: 4\r\nExplanation: There are 4 ways to place `1 \u00c3\u0097 4` tiles in a `6 \u00c3\u0097 4` matrix:\r\n\r\n\u00e2\u0080\u00a2 Place all 6 tiles horizontally.\r\n\u00e2\u0080\u00a2 Place 4 tiles vertically in the first four rows and the remaining 2 tiles horizontally in the last two rows.\r\n\u00e2\u0080\u00a2 Place 2 tiles horizontally in the first two rows, and adjust the remaining 4 tiles vertically in the remaining rows.\r\n\u00e2\u0080\u00a2 Place 2 tiles horizontally in the first and last row, and adjust the remaining 4 tiles vertically in the middle rows.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Largest Plus",
    "link": "https://www.techiedelight.com/?problem=LargestPlus",
    "category": "Dynamic Programming, Matrix",
    "tag": "Bottom-up",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LargestPlus/LargestPlus.java",
    "problem": "/* START *//*\r\n\r\nGiven a square matrix of 0\u00e2\u0080\u0099s and 1\u00e2\u0080\u0099s, calculate the size of the largest plus formed by 1\u00e2\u0080\u0099s.\r\n\r\nInput:\r\n\r\ngrid = [\r\n\t[1, 0, 1, 1, 1, 1, 0, 1, 1, 1],\r\n\t[1, 0, 1, 0, 1, 1, 1, 0, 1, 1],\r\n\t[1, 1, 1, 0, 1, 1, 0, 1, 0, 1],\r\n\t[0, 0, 0, 0, 1, 0, 0, 1, 0, 0],\r\n\t[1, 1, 1, 0, 1, 1, 1, 1, 1, 1],\r\n\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\r\n\t[1, 0, 0, 0, 1, 0, 0, 1, 0, 1],\r\n\t[1, 0, 1, 1, 1, 1, 0, 0, 1, 1],\r\n\t[1, 1, 0, 0, 1, 0, 1, 0, 0, 1],\r\n\t[1, 0, 1, 1, 1, 1, 0, 1, 0, 0]\r\n]\r\n\r\nOutput: 17\r\n\r\nExplanation: The largest plus of 1\u00e2\u0080\u0099s is marked below, having size 17.\r\n\r\n\r\n\t1  0  1  1  1  1  0  1  1  1\r\n\t1  0  1  0  |  1  1  0  1  1\r\n\t1  1  1  0  |  1  0  1  0  1\r\n\t0  0  0  0  |  0  0  1  0  0\r\n\t1  1  1  0  |  1  1  1  1  1\r\n\t\u00e2\u0080\u0093  \u00e2\u0080\u0093  \u00e2\u0080\u0093  \u00e2\u0080\u0093  |  \u00e2\u0080\u0093  \u00e2\u0080\u0093  \u00e2\u0080\u0093  \u00e2\u0080\u0093  0\r\n\t1  0  0  0  |  0  0  1  0  1\r\n\t1  0  1  1  |  1  0  0  1  1\r\n\t1  1  0  0  |  0  1  0  0  1\r\n\t1  0  1  1  |  1  0  1  0  0\r\n\r\n\r\nInput:\r\n\r\n[\r\n\t[1, 1, 1, 1, 1, 1],\r\n\t[1, 0, 1, 1, 0, 1],\r\n\t[0, 1, 1, 0, 0, 1],\r\n\t[1, 1, 1, 1, 1, 1],\r\n\t[1, 0, 0, 1, 0, 1],\r\n\t[1, 0, 1, 1, 0, 0]\r\n]\r\n\r\nOutput: 0\r\n\r\nExplanation: No largest plus of 1\u00e2\u0080\u0099s can be constructed.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Collect Coins",
    "link": "https://www.techiedelight.com/?problem=CollectCoins",
    "category": "Dynamic Programming, Matrix",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/CollectCoins/CollectCoins.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` matrix of non-negative integers where each cell contains a coin of some denomination, collect the maximum value of coins by traversing the grid.\r\n\r\nThe first traversal starts from the top-left corner of the matrix and ends in the bottom-left corner, and the second traversal starts from the top-right corner and ends in the bottom-right corner. From any cell (i, j) in the matrix, you are allowed to move to cell (i+1, j+1) or (i+1, j-1) or (i+1, j). If both traversals pass through the same cell, only one can collect coins from that cell.\r\n\r\nInput:\r\n\r\n[\r\n\t[0, 2, 4, 1],\r\n\t[4, 8, 3, 7],\r\n\t[2, 3, 6, 2],\r\n\t[9, 7, 8, 3],\r\n\t[1, 5, 9, 4]\r\n]\r\n\r\nOutput: 47\r\n\r\nExplanation:\r\n\r\nFirst traversal : [0, 8, 3, 9, 1]\r\nSecond traversal: [1, 7, 6, 8, 4]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Duplicate Rows",
    "link": "https://www.techiedelight.com/?problem=DuplicateRows",
    "category": "Matrix, Trie",
    "tag": "Hashing, Trie",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DuplicateRows/DuplicateRows.java",
    "problem": "/* START *//*\r\n\r\nFind duplicate rows present in a given binary matrix by traversing the matrix only once.\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[1, 0, 0, 1, 0],\r\n\t[0, 1, 1, 0, 0],\r\n\t[1, 0, 0, 1, 0],\r\n\t[0, 0, 1, 1, 0],\r\n\t[0, 1, 1, 0, 0]\r\n]\r\n\r\nOutput: {3, 5}\r\n\r\nExplanation: Row #3 is duplicate of row #1 and row #5 is duplicate of row #2\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Boggle Search",
    "link": "https://www.techiedelight.com/?problem=BoggleSearch",
    "category": "Backtracking, Matrix, Trie",
    "tag": "Depth-First Search, Hashing, Recursive, Trie",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/BoggleSearch/BoggleSearch.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` boggle board, find a list of all possible words that can be formed by a sequence of adjacent characters on the board.\r\n\r\nYou are allowed to search a word in all eight possible directions, i.e., North, West, South, East, North-East, North-West, South-East, South-West, but a word should not have multiple instances of the same cell.\r\n\r\nInput:\r\n\r\nboard =\r\n[\r\n\t['M', 'S', 'E'],\r\n\t['R', 'A', 'T'],\r\n\t['L', 'O', 'N']\r\n]\r\n\r\nwords = [\"STAR\", \"NOTE\", \"SAND\", \"STONE\"]\r\n\r\nOutput: {\"STAR\", \"NOTE\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Submatrix Sum",
    "link": "https://www.techiedelight.com/?problem=SubmatrixSum",
    "category": "Dynamic Programming, Matrix",
    "tag": "Bottom-up",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SubmatrixSum/SubmatrixSum.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix and two coordinates (p, q) and (r, s) representing top-left and bottom-right coordinates of a submatrix of it, calculate the sum of all elements present in the submatrix.\r\n\r\nInput:\r\n\r\nmat =\r\n[\r\n\t[0, 2, 5, 4, 1],\r\n\t[4, 8, 2, 3, 7],\r\n\t[6, 3, 4, 6, 2],\r\n\t[7, 3, 1, 8, 3],\r\n\t[1, 5, 7, 9, 4]\r\n]\r\n\r\n(p, q) = (1, 1)\r\n(r, s) = (3, 3)\r\n\r\nOutput: 38\r\n\r\nExplanation: The submatrix formed by coordinates (p, q), (p, s), (r, q), and (r, s) is shown below, having the sum of elements equal to 38.\r\n\r\n 8  2  3\r\n 3  4  6\r\n 3  1  8\r\n\r\nAssume that `m` lookup calls are made to the matrix; the task is to achieve constant time lookups.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Sum Submatrix",
    "link": "https://www.techiedelight.com/?problem=MaximumSumSubmatrix",
    "category": "Dynamic Programming, Matrix",
    "tag": "Bottom-up",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumSumSubmatrix/MaximumSumSubmatrix.java",
    "problem": "/* START *//*\r\n\r\nGiven an `M \u00c3\u0097 N` integer matrix, calculate the maximum sum submatrix of size `k \u00c3\u0097 k` in it.\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[ 3, -4,  6, -5,  1],\r\n\t[ 1, -2,  8, -4, -2],\r\n\t[ 3, -8,  9,  3,  1],\r\n\t[-7,  3,  4,  2,  7],\r\n\t[-3,  7, -5,  7, -6]\r\n]\r\n\r\n\u00e2\u0080\u00a2 If k = 2, then\r\n\r\nOutput:\r\n[\r\n\t[9, 3],\r\n\t[4, 2]\r\n]\r\n\r\n\u00e2\u0080\u00a2 If k = 3, then\r\n\r\nOutput:\r\n[\r\n\t[8, -4, -2],\r\n\t[9,  3,  1],\r\n\t[4,  2,  7]\r\n]\r\n\r\nIn case the multiple `k \u00c3\u0097 k` submatrix exists with the maximum sum, the solution can return any one of them.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Sum Submatrix II",
    "link": "https://www.techiedelight.com/?problem=MaximumSumSubmatrixII",
    "category": "Dynamic Programming, Matrix",
    "tag": "Bottom-up",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumSumSubmatrixII/MaximumSumSubmatrixII.java",
    "problem": "/* START *//*\r\n\r\nGiven an `N \u00c3\u0097 N` matrix, find the maximum sum submatrix present in it.\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[-5, -6, 3, 1, 0],\r\n\t[9, 7, 8, 3, 7],\r\n\t[-6, -2, -1, 2, -4],\r\n\t[-7, 5, 5, 2, -6],\r\n\t[3, 2, 9, -5, 1]\r\n]\r\n\r\nOutput:\r\n\r\n[\r\n\t[7, 8, 3],\r\n\t[-2, -1, 2],\r\n\t[5, 5, 2],\r\n\t[2, 9, -5]\r\n]\r\n\r\nIn case the multiple maximum sum submatrix exists, the solution can return any one of them.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Alive Probability",
    "link": "https://www.techiedelight.com/?problem=AliveProbability",
    "category": "Dynamic Programming, Matrix",
    "tag": "Hashing, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/AliveProbability/AliveProbability.java",
    "problem": "/* START *//*\r\n\r\nAn island is in the form of an `N \u00c3\u0097 N` square matrix, and a person is standing inside the matrix. The person can move one step in any direction (right, left, top, down) in the matrix. Calculate the probability that the person is alive after walking `n` steps on the island, provided that he dies if he steps outside the matrix.\r\n\r\nThe following solution assumes all steps carry equal probability, i.e., 1/4 or 0.25. It can easily be modified to handle unequal probabilities.\r\n\r\nInput:\r\n\r\nN = 2\t\t\t(Matrix dimentions)\r\nn = 1\t\t\t(Total number of steps)\r\n(x, y) = (0, 0)\t(Starting coordinates)\r\n\r\nOutput: 0.5\t\t(Alive probability)\r\n\r\n\r\nInput: N = 3, n = 1, (x, y) = (1, 1)\r\nOutput: 1\r\n\r\nInput: N = 3, n = 3, (x, y) = (0, 0)\r\nOutput: 0.25\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Length Snake Sequence",
    "link": "https://www.techiedelight.com/?problem=MaximumLengthSnakeSequence",
    "category": "Dynamic Programming, Matrix",
    "tag": "Algorithm",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumLengthSnakeSequence/MaximumLengthSnakeSequence.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer square matrix, find the maximum length snake sequence in it and return its length. A snake sequence is defined as a sequence of numbers where each new number, which can only be located to the right or down of the current number, is either plus or minus one.\r\n\r\nYou are only allowed to move either right or down from any cell in the matrix, provided that the new cell has value `\u00c2\u00b11` relative to the current cell.\r\n\r\nInput:\r\n\r\ngrid = [\r\n\t[7, 5, 2, 3, 1],\r\n\t[3, 4, 1, 4, 4],\r\n\t[1, 5, 6, 7, 8],\r\n\t[3, 4, 5, 8, 9],\r\n\t[3, 2, 2, 7, 6]\r\n]\r\n\r\nOutput: 7\r\n\r\nExplanation: The maximum length snake sequence for the above matrix is [5, 4, 5, 6, 7, 8, 7, 6] or [3, 4, 5, 6, 7, 8, 7, 6].\r\n\r\nNote that the length of a snake sequence is one less than the count of numbers in it.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Flood Fill Algorithm",
    "link": "https://www.techiedelight.com/?problem=FloodFillAlgorithm",
    "category": "Matrix, Queue",
    "tag": "Algorithm, Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/FloodFillAlgorithm/FloodFillAlgorithm.java",
    "problem": "/* START *//*\r\n\r\nFlood fill is an algorithm that determines the area connected to a given node in a multi-dimensional array. It is used in the \"bucket\" fill tool of a paint program to fill connected, similarly colored areas with a different color and in games such as Go and Minesweeper for determining which pieces are cleared. When applied on an image to fill a particular bounded area with color, it is also known as boundary fill.\r\n\r\nThe flood fill algorithm takes three parameters: a start node, a target color, and a replacement color. The algorithm looks for all nodes in the matrix that are connected to the start node by a path of the target color and changes them to the replacement color.\r\n\r\nInput:\r\n\r\nMatrix = [\r\n\t[Y, Y, Y, G, G, G, G, G, G, G],\r\n\t[Y, Y, Y, Y, Y, Y, G, V, V, V],\r\n\t[G, G, G, G, G, G, G, V, V, V],\r\n\t[W, W, W, W, W, G, G, G, G, V],\r\n\t[W, R, R, R, R, R, G, V, V, V],\r\n\t[W, W, W, R, R, G, G, V, V, V],\r\n\t[W, B, W, R, R, R, R, R, R, V],\r\n\t[W, B, B, B, B, R, R, V, V, V],\r\n\t[W, B, B, V, B, B, B, B, V, V],\r\n\t[W, B, B, V, V, V, V, V, V, V]\r\n]\r\n\r\n(x, y) = (3, 9)\t\t\t\t(Start node, having a target color `V`)\r\nReplacement Color = O\r\n\r\nOutput:\r\n[\r\n\t[Y, Y, Y, G, G, G, G, G, G, G],\r\n\t[Y, Y, Y, Y, Y, Y, G, O, O, O],\r\n\t[G, G, G, G, G, G, G, O, O, O],\r\n\t[W, W, W, W, W, G, G, G, G, O],\r\n\t[W, R, R, R, R, R, G, O, O, O],\r\n\t[W, W, W, R, R, G, G, O, O, O],\r\n\t[W, B, W, R, R, R, R, R, R, O],\r\n\t[W, B, B, B, B, R, R, O, O, O],\r\n\t[W, B, B, O, B, B, B, B, O, O],\r\n\t[W, B, B, O, O, O, O, O, O, O]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Count Islands",
    "link": "https://www.techiedelight.com/?problem=CountIslands",
    "category": "Matrix, Queue",
    "tag": "Breadth-First Search",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CountIslands/CountIslands.java",
    "problem": "/* START *//*\r\n\r\nGiven a binary matrix where 0 represents water and 1 represents land, and connected ones form an island, count the total islands.\r\n\r\nInput:\r\n\r\n[\r\n\t[1, 0, 1, 0, 0, 0, 1, 1, 1, 1],\r\n\t[0, 0, 1, 0, 1, 0, 1, 0, 0, 0],\r\n\t[1, 1, 1, 1, 0, 0, 1, 0, 0, 0],\r\n\t[1, 0, 0, 1, 0, 1, 0, 0, 0, 0],\r\n\t[1, 1, 1, 1, 0, 0, 0, 1, 1, 1],\r\n\t[0, 1, 0, 1, 0, 0, 1, 1, 1, 1],\r\n\t[0, 0, 0, 0, 0, 1, 1, 1, 0, 0],\r\n\t[0, 0, 0, 1, 0, 0, 1, 1, 1, 0],\r\n\t[1, 0, 1, 0, 1, 0, 0, 1, 0, 0],\r\n\t[1, 1, 1, 1, 0, 0, 0, 1, 1, 1]\r\n]\r\n\r\nOutput: 5\r\n\r\nExplanation: There are a total of 5 islands present in the above matrix. They are marked by the numbers 1 to 5 in the matrix below.\r\n\r\n  1  0  2  0  0  0  3  3  3  3\r\n  0  0  2  0  2  0  3  0  0  0\r\n  2  2  2  2  0  0  3  0  0  0\r\n  2  0  0  2  0  3  0  0  0  0\r\n  2  2  2  2  0  0  0  5  5  5\r\n  0  2  0  2  0  0  5  5  5  5\r\n  0  0  0  0  0  5  5  5  0  0\r\n  0  0  0  4  0  0  5  5  5  0\r\n  4  0  4  0  4  0  0  5  0  0\r\n  4  4  4  4  0  0  0  5  5  5\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Young Tableau",
    "link": "https://www.techiedelight.com/?problem=ConstructYoungTableau",
    "category": "Matrix",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructYoungTableau/ConstructYoungTableau.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array containing n elements, construct an `N \u00c3\u0097 N` Young tableau from it where N is ceil of square root of n. i.e., N = ceil(sqrt(n)).\r\n\r\nAn `N \u00c3\u0097 N` Young tableau is an `N \u00c3\u0097 N` matrix such that the entries of each row are sorted from left to right and the entries of each column are sorted from top to bottom. Some entries of a Young tableau may be infinity, which indicates an empty entry.\r\n\r\nInput: [12, 10, 20, 22, 25, 30, 34, 11, 44, 27, 16, 40, 35, 15, 18, 45]\r\n\r\nOutput: [\r\n\t[10, 11, 12, 15],\r\n\t[16, 18, 20, 22],\r\n\t[25, 27, 30, 34],\r\n\t[35, 40, 44, 45]\r\n]\r\n\r\nOR [\r\n\t[10, 12, 15, 16],\r\n\t[11, 18, 20, 25],\r\n\t[22, 27, 30, 35],\r\n\t[34, 40, 44, 45]\r\n]\r\n\r\nOR, any other valid `N \u00c3\u0097 N` Young tableau.\r\n\r\n\r\nInput: [12, 10, 20, 22, 25, 30, 34, 11, 27, 16]\r\n\r\nOutput: [\r\n\t[10,  11,  12,  16],\r\n\t[20,  22,  25,  27],\r\n\t[30,  34,  inf, inf],\r\n\t[inf, inf, inf, inf]\r\n]\r\n\r\nHere, inf = Integer.MAX_VALUE\r\n\r\nOR, any other valid `N \u00c3\u0097 N` Young tableau.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Extract Min in Young Tableau",
    "link": "https://www.techiedelight.com/?problem=ExtractMinInYoungTableau",
    "category": "Matrix",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ExtractMinInYoungTableau/ExtractMinInYoungTableau.java",
    "problem": "/* START *//*\r\n\r\nGiven an `N \u00c3\u0097 N` Young tableau, extract and return the minimum element from it and in-place fix the Young tableau.\r\n\r\nAn `N \u00c3\u0097 N` Young tableau is an `N \u00c3\u0097 N` matrix such that the entries of each row are sorted from left to right and the entries of each column are sorted from top to bottom. Some entries of a Young tableau may be infinity, which indicates an empty entry.\r\n\r\nInput:\r\n\r\ntableau = [\r\n\t[10, 11, 12, 15],\r\n\t[16, 18, 20, 22],\r\n\t[25, 27, 30, 34],\r\n\t[35, 40, 44, 45]\r\n]\r\n\r\nOutput: 10\r\n\r\ntableau = [\r\n\t[11, 12, 15, 22],\r\n\t[16, 18, 20, 34],\r\n\t[25, 27, 30, 45],\r\n\t[35, 40, 44, inf]\r\n]\r\n\r\nOR, any other valid `N \u00c3\u0097 N` Young tableau.\r\n\r\nHere, inf = Integer.MAX_VALUE\r\n\r\nInput:\r\n\r\ntableau = [\r\n\t[11, 12, 25],\r\n\t[20, 22, 34],\r\n\t[27, 30, inf]\r\n]\r\n\r\nOutput: 11\r\n\r\ntableau = [\r\n\t[12, 22, 25],\r\n\t[20, 30, 34],\r\n\t[27, inf, inf]\r\n]\r\n\r\nOR, any other valid `N \u00c3\u0097 N` Young tableau.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Replace Element in Young Tableau",
    "link": "https://www.techiedelight.com/?problem=ReplaceElementInYoungTableau",
    "category": "Matrix",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ReplaceElementInYoungTableau/ReplaceElementInYoungTableau.java",
    "problem": "/* START *//*\r\n\r\nGiven an `N \u00c3\u0097 N` Young tableau and two integers x and y, replace x by y in the Young tableau and in-place fix the Young tableau property.\r\n\r\nAn `N \u00c3\u0097 N` Young tableau is an `N \u00c3\u0097 N` matrix such that the entries of each row are sorted from left to right and the entries of each column are sorted from top to bottom. Some entries of a Young tableau may be infinity, which indicates an empty entry.\r\n\r\nInput:\r\n\r\ntableau = [\r\n\t[10, 12, 15, 16],\r\n\t[11, 18, 20, 25],\r\n\t[22, 27, 30, 35],\r\n\t[34, 40, 44, 45]\r\n]\r\n\r\nx = 20, y = 14\t\t# replace 20 by 14\r\n\r\nOutput:\r\n\r\ntableau = [\r\n\t[10, 12, 14, 15]\r\n\t[11, 16, 18, 25]\r\n\t[22, 27, 30, 35]\r\n\t[34, 40, 44, 45]\r\n]\r\n\r\nOR, any other valid `N \u00c3\u0097 N` Young tableau.\r\n\r\nInput:\r\n\r\ntableau = [\r\n\t[11, 12, 25],\r\n\t[20, 22, 34],\r\n\t[27, 30, inf]\r\n]\r\n\r\nHere, inf = Integer.MAX_VALUE\r\n\r\nx = 20, y = 35\t\t# replace 20 by 35\r\n\r\nOutput:\r\n\r\ntableau = [\r\n\t[11, 12, 25],\r\n\t[22, 30, 34],\r\n\t[27, 35, inf]\r\n]\r\n\r\nOR, any other valid `N \u00c3\u0097 N` Young tableau.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sort with Young Tableau",
    "link": "https://www.techiedelight.com/?problem=SortWithYoungTableau",
    "category": "Array, Matrix, Sorting",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/SortWithYoungTableau/SortWithYoungTableau.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, in-place sort it using Young tableau. You are given a utility class YoungTableau with the following static public member functions:\r\n\r\n1. int[][] construct(int[] nums): Construct and return an `N \u00c3\u0097 N` Young tableau from the list `nums`. Note that `N` is determined dynamically by taking ceil of the square root of `nums` length.\r\n\r\n2. int extractMin(int[][] tableau): Extract the next minimum element from the Young tableau `tableau`.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Magnet Puzzle",
    "link": "https://www.techiedelight.com/?problem=MagnetPuzzle",
    "category": "Backtracking, Matrix",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MagnetPuzzle/MagnetPuzzle.java",
    "problem": "/* START *//*\r\n\r\nWe are given a set of bipolar magnets, each domino-shaped. The objective is to place magnets on an `M \u00c3\u0097 N` board, which satisfies a set of conditions where both M and N are not odd.\r\n\r\nFor instance, the following problem has the solution on its right:\r\n\r\nhttps://techiedelight.com/practice/images/Magnet-Puzzle.png\r\n\r\nEach `2 \u00c3\u0097 1` or `1 \u00c3\u0097 2` grid in the board can contain a magnet or empty. The blank entry will be indicated by X\u00e2\u0080\u0099s, and the magnet will be represented by `+` and `-` (For the positive and negative end, respectively). The digits along the board\u00e2\u0080\u0099s left and top sides represent the count of `+` squares in corresponding rows or columns. Similarly, those along the right and bottom show the total number of `-` signs in particular rows or columns. Rows and columns for which no number is mentioned can have any number of `+` or `-` signs. The puzzle solution must also satisfy the constraint that no two adjacent squares can have the same sign. But diagonally joined squares can have the same sign.\r\n\r\nExample 1:\r\n\r\nThe top[], bottom[], left[], right[] arrays indicates the count of `+` or `-` along the top (+), bottom (-), left (+), and right (-) edges, respectively. The value of -1 indicate any number of `+` or `-` signs.\r\n\r\ntop[] = [1, -1, -1, 2, 1, -1]\r\nbottom[] = [2, -1, -1, 2, -1, 3]\r\nleft[] = [2, 3, -1, -1, -1]\r\nright[] = [-1, -1, -1, 1, -1]\r\n\r\nThe rules[][] matrix can contain any T, B, L, or R character. T indicates its top end for a vertical slot in the board, and B indicates the bottom end. L indicates the left end, and R indicates the right end for a horizontal slot in the board.\r\n\r\nrules[][] =\r\n[\r\n\t[L, R, L, R, T, T],\r\n\t[L, R, L, R, B, B],\r\n\t[T, T, T, T, L, R],\r\n\t[B, B, B, B, T, T],\r\n\t[L, R, L, R, B, B]\r\n]\r\n\r\nOutput:\r\n[\r\n\t[+, -, +, -, X, -],\r\n\t[-, +, -, +, X, +],\r\n\t[X, X, +, -, +, -],\r\n\t[X, X, -, +, X, +],\r\n\t[-, +, X, X, X, -]\r\n]\r\n\r\n\r\nExample 2:\r\n\r\ntop[] = [2, -1, -1]\r\nbottom[] = [-1, -1, 2]\r\nleft[] = [-1, -1, 2, -1]\r\nright[] = [0, -1, -1, -1]\r\n\r\nrules[][] =\r\n[\r\n\t[T, T, T],\r\n\t[B, B, B],\r\n\t[T, L, R],\r\n\t[B, L, R]\r\n]\r\n\r\nOutput:\r\n[\r\n\t[+, X, +],\r\n\t[-, X, -],\r\n\t[+, -, +],\r\n\t[-, +, -]\r\n]\r\n\r\nThe solution should return null if the solution does not exist.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Check Circular Moves",
    "link": "https://www.techiedelight.com/?problem=CheckCircularMoves",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CheckCircularMoves/CheckCircularMoves.java",
    "problem": "/* START *//*\r\n\r\nCheck if a given set of moves is circular or not. A move is circular if its starting and ending coordinates are the same. The moves can contain instructions to move one unit in the same direction (M), to change direction to the left of current direction (L), and to change direction to the right of current direction (R).\r\n\r\nInput: \"MRMRMRM\"\r\nOutput: true\r\n\r\nInput: \"MRMLMRMRMMRMM\"\r\nOutput: true\r\n\r\nAssume that the initial direction is North.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Palindromic Substrings",
    "link": "https://www.techiedelight.com/?problem=PalindromicSubstrings",
    "category": "String",
    "tag": "",
    "lists": "TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/PalindromicSubstrings/PalindromicSubstrings.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find all possible distinct palindromic substrings in it.\r\n\r\nInput : \"google\"\r\nOutput: {\"e\", \"l\", \"g\", \"o\", \"oo\", \"goog\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Group Anagrams",
    "link": "https://www.techiedelight.com/?problem=GroupAnagrams",
    "category": "Sorting, String, Trie",
    "tag": "Hashing, Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/GroupAnagrams/GroupAnagrams.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of words, efficiently group all anagrams. The two strings, X and Y, are anagrams if by rearranging X's letters, we can get Y using all the original letters of X exactly once.\r\n\r\nInput : [\"CARS\", \"REPAID\", \"DUES\", \"NOSE\", \"SIGNED\", \"LANE\", \"PAIRED\", \"ARCS\", \"GRAB\", \"USED\", \"ONES\", \"BRAG\", \"SUED\", \"LEAN\", \"SCAR\", \"DESIGN\"]\r\n\r\nOutput:\r\n\r\n{\r\n\t[\"CARS\", \"ARCS\", \"SCAR\"],\r\n\t[\"REPAID\", \"PAIRED\"],\r\n\t[\"SIGNED\", \"DESIGN\"],\r\n\t[\"LANE\", \"LEAN\"],\r\n\t[\"GRAB\", \"BRAG\"],\r\n\t[\"NOSE\", \"ONES\"],\r\n\t[\"DUES\", \"USED\", \"SUED\"]\r\n}\r\n\r\n\r\nInput : [\"CARS\", \"LANE\", \"ONES\"]\r\nOutput: {}\r\n\r\nThe solution should return a set containing all the anagrams grouped together, irrespective of the order.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Transform String",
    "link": "https://www.techiedelight.com/?problem=TransformString",
    "category": "Sorting, String",
    "tag": "Hashing",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/TransformString/TransformString.java",
    "problem": "/* START *//*\r\n\r\nGiven two strings, determine if the first string can be transformed into the second string. The only operation allowed is moving a character from the first string to the front. If the string can be transformed, find the minimum number of operations required for the transformation.\r\n\r\nInput: X = \"ADCB\", Y = \"ABCD\"\r\nOutput: 3\r\nExplanation: The minimum number of operations required to convert the string \"ADCB\" to string \"ABCD\" is 3.\r\n\r\nADCB \u00e2\u0080\u0094> CADB (Move 'C' to the front)\r\nCADB \u00e2\u0080\u0094> BCAD (Move 'B' to the front)\r\nBCAD \u00e2\u0080\u0094> ABCD (Move 'A' to the front)\r\n\r\nThe solution should return -1 if the string cannot be transformed.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Transform String II",
    "link": "https://www.techiedelight.com/?problem=TransformStringII",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TransformStringII/TransformStringII.java",
    "problem": "/* START *//*\r\n\r\nGiven two strings, determine whether the first string can be transformed into the second string with a single edit operation. An edit operation can insert, remove, or replace a character in the first string.\r\n\r\nInput : X = \"xyz\", Y = \"xz\"\r\nOutput: true\r\nExplanation: The total number of edits required is 1 (remove 'y' from the first string)\r\n\r\nInput : X = \"xyz\", Y = \"xyyz\"\r\nOutput: true\r\nExplanation: The total number of edits required is 1 (add 'y' in the first string)\r\n\r\nInput : X = \"xyz\", Y = \"xyx\"\r\nOutput: true\r\nExplanation: The total number of edits required is 1 (replace 'z' in the first string by 'x')\r\n\r\nInput : X = \"xyz\", Y = \"xxx\"\r\nOutput: false\r\nExplanation: The total number of edits required are 2 (replace 'y' and 'z' in the first string by 'x')\r\n\r\nInput : X = \"xyz\", Y = \"xyz\"\r\nOutput: false\r\nExplanation: The total number of edits required is 0 (both strings are the same)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Transform String III",
    "link": "https://www.techiedelight.com/?problem=TransformStringIII",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/TransformStringIII/TransformStringIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, remove all occurrences of \"AB\" and \"C\" in a single traversal of it.\r\n\r\nInput: \"CBAABCAB\"\r\nOutput: \"BA\"\r\n\r\nThe solution should remove of all adjacent, as well as non-adjacent occurrences of string \"AB\" and \"C\".\r\n\r\nInput: \"ADAABCB\"\r\nOutput: \"AD\"\r\nExplanation: Removing the first adjacent occurrence of \"AB\" and \"C\" results in string \"ADAB\", which again needs to be processed for adjacent \"AB\". Therefore, the final output string will be \"AD\".\r\n\r\nInput: \"AACBBC\"\r\nOutput: \"\"\r\nExplanation: AACBBC -> AABB -> AB -> \"\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Balanced Expression",
    "link": "https://www.techiedelight.com/?problem=BalancedExpression",
    "category": "Stack, String",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/BalancedExpression/BalancedExpression.java",
    "problem": "/* START *//*\r\n\r\nGiven a string containing opening and closing braces, determine if it represents a balanced expression or not.\r\n\r\nInput: \"{[{}{}]}[()]\"\r\nOutput: true\r\n\r\nInput: \"{{}{}}\"\r\nOutput: true\r\n\r\nInput: \"[]{}()\"\r\nOutput: true\r\n\r\nInput: \"{()}[)\"\r\nOutput: false\r\n\r\nInput: \"{(})\"\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Palidromic Sum Substring",
    "link": "https://www.techiedelight.com/?problem=LongestPalidromicSumSubstring",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestPalidromicSumSubstring/LongestPalidromicSumSubstring.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find the length of the longest contiguous substring, such that the length of the substring is `2\u00c3\u0097n` digits and the sum of the leftmost `n` digits is equal to the sum of the rightmost `n` digits. If there is no such substring, return 0.\r\n\r\nInput : 13267224\r\nOutput: 6\r\nExplanation: 326722 = (3 + 2 + 6) = (7 + 2 + 2) = 11\r\n\r\nInput : 546374\r\nOutput: 4\r\nExplanation: 4637 = (4 + 6) = (3 + 7) = 10\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Print String Zig Zag",
    "link": "https://www.techiedelight.com/?problem=PrintStringZigZag",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PrintStringZigZag/PrintStringZigZag.java",
    "problem": "/* START *//*\r\n\r\nGiven a string and a positive integer `k`, print the string in `k` rows in the zigzag form.\r\n\r\nInput:\r\n\r\nstr = \"THISPROBLEMISAWESOME\"\r\nk = 3\r\n\r\nOutput: \"TOSMHRBIAOEIPLMWSSEE\"\r\n\r\nExplanation:\r\n\r\n(Row 1)\t\tT\t\t\t\tP\t\t\t\tL\t\t\t\tS\t\t\t\tS\r\n(Row 2)\t\t\tH\t\tS\t\tR\t\tB\t\tE\t\tI\t\tA\t\tE\t\tO\t\tE\r\n(Row 3)\t\t\t\tI\t\t\t\tO\t\t\t\tM\t\t\t\tW\t\t\t\tM\r\n\r\n\r\nNote: If `k` is more than length of the string, return the whole string.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Run Length Encoding",
    "link": "https://www.techiedelight.com/?problem=RunLengthEncoding",
    "category": "String",
    "tag": "Algorithm",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RunLengthEncoding/RunLengthEncoding.java",
    "problem": "/* START *//*\r\n\r\nRun\u00e2\u0080\u0093length encoding (RLE) is a simple form of lossless data compression that runs on sequences with the same value occurring many consecutive times. It encodes the sequence to store only a single value and its count.\r\n\r\nInput: \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\r\nOutput: \"12W1B12W3B24W1B14W\"\r\nExplanation: String can be interpreted as a sequence of twelve W\u00e2\u0080\u0099s, one B, twelve W\u00e2\u0080\u0099s, three B\u00e2\u0080\u0099s, and so on..\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Distinct Substring",
    "link": "https://www.techiedelight.com/?problem=LongestDistinctSubstring",
    "category": "String",
    "tag": "Hashing, Sliding Window",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LongestDistinctSubstring/LongestDistinctSubstring.java",
    "problem": "/* START *//*\r\n\r\nGiven a string and a positive number `k`, find the longest substring of the string containing `k` distinct characters. If `k` is more than the total number of distinct characters in the string, return the whole string.\r\n\r\nInput: s = \"abcbdbdbbdcdabd\", k = 2\r\nOutput: \"bdbdbbd\"\r\n\r\nInput: s = \"abcbdbdbbdcdabd\", k = 3\r\nOutput: \"bcbdbdbbdcd\"\r\n\r\nInput: s = \"abcbdbdbbdcdabd\", k = 5\r\nOutput: \"abcbdbdbbdcdabd\"\r\n\r\nThe longest distinct character substring is not guaranteed to be unique. If multiple longest distinct substring exists, the solution should return the one which appear first in the string.\r\n\r\nInput: s = \"abcd\", k = 3\r\nOutput: \"abc\"\r\nExplanation: There are two longest distinct substrings in \"abcd\" having 3 distinct characters, namely, \"abc\" and \"bcd\". The solution returns \"abc\" as it appears before \"bcd\" in the string.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Distinct Substring II",
    "link": "https://www.techiedelight.com/?problem=LongestDistinctSubstringII",
    "category": "String",
    "tag": "Sliding Window",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestDistinctSubstringII/LongestDistinctSubstringII.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find the longest substring containing distinct characters.\r\n\r\nInput : \"longestsubstr\"\r\nOutput: \"longest\"\r\n\r\nInput : \"abbcdafeegh\"\r\nOutput: \"bcdafe\"\r\n\r\nInput : \"aaaaaa\"\r\nOutput: \"a\"\r\n\r\nThe longest distinct character substring is not guaranteed to be unique. If multiple longest distinct substring exists, the solution should return the one which appear first in the string.\r\n\r\nInput: \"cbabc\"\r\nOutput: \"cba\"\r\nExplanation: There are two longest distinct substrings in \"cbaabc\" of length 3, namely, \"cba\" and \"abc\". The solution returns \"cba\" as it appears before \"abc\" in the string.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Palindromic Permutations",
    "link": "https://www.techiedelight.com/?problem=PalindromicPermutations",
    "category": "Sorting, String",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PalindromicPermutations/PalindromicPermutations.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find all palindromic permutations of it.\r\n\r\nInput : \"xyxzwxxyz\"\r\nOutput: {\"xxyzwzyxx\", \"xxzywyzxx\", \"xyxzwzxyx\", \"xyzxwxzyx\", \"xzxywyxzx\", \"xzyxwxyzx\", \"yxxzwzxxy\", \"yxzxwxzxy\", \"yzxxwxxzy\", \"zxxywyxxz\", \"zxyxwxyxz\", \"zyxxwxxyz\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Anagram Substring",
    "link": "https://www.techiedelight.com/?problem=AnagramSubstring",
    "category": "String",
    "tag": "Hashing, Sliding Window",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/AnagramSubstring/AnagramSubstring.java",
    "problem": "/* START *//*\r\n\r\nGiven two strings, find all substrings of the first string that are anagrams of the second string and return the list of their indices.\r\n\r\nTwo words, X and Y, are anagrams if by rearranging the letters of X, we can get Y using all the original letters of X exactly once.\r\n\r\nInput: X = \"XYYZXZYZXXYZ\", Y = \"XYZ\"\r\nOutput: [2, 4, 6, 9]\r\n\r\nExplanation:\r\n\r\nAnagram \"YZX\" present at index 2\r\nAnagram \"XZY\" present at index 4\r\nAnagram \"YZX\" present at index 6\r\nAnagram \"XYZ\" present at index 9\r\n\r\nNote: The solution should return the indices in ascending order.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Occurring Word",
    "link": "https://www.techiedelight.com/?problem=MaximumOccurringWord",
    "category": "String, Trie",
    "tag": "Depth-First Search, Recursive, Trie",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumOccurringWord/MaximumOccurringWord.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of strings with duplicates present, return the maximum occurring word in it. If two words have the same count, return any one of them.\r\n\r\nInput: [code, coder, coding, codable, codec, codecs, coded, codeless, codecs, codependence, codex, codify, codependents, codes, code, coder, codesign, codec, codeveloper, codrive, codec, codecs, codiscovered]\r\n\r\nOutput: codec or codecs\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Permutations",
    "link": "https://www.techiedelight.com/?problem=Permutations",
    "category": "Backtracking, String",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/Permutations/Permutations.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find all permutations of it.\r\n\r\nInput : \"ABC\"\r\nOutput: [\"ABC\", \"ACB\", \"BAC\", \"BCA\", \"CAB\", \"CBA\"]\r\n\r\nThere are exacly n! permutations for a string of length n, and the solution should return all permutations in any order. For strings containing duplicate characters, the solution should return duplicate permutations.\r\n\r\nInput : \"ABA\"\r\nOutput: [\"ABA\", \"AAB\", \"BAA\", \"BAA\", \"AAB\", \"ABA\"]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Permutations II",
    "link": "https://www.techiedelight.com/?problem=PermutationsII",
    "category": "Java, Sorting, String",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/PermutationsII/PermutationsII.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find all permutations of it.\r\n\r\nInput : \"ABC\"\r\nOutput: [\"ABC\", \"ACB\", \"BAC\", \"BCA\", \"CAB\", \"CBA\"]\r\n\r\nThe solution should handle strings containing duplicate characters and don\"t repeat the permutations.\r\n\r\nInput : \"ABA\"\r\nOutput: [\"ABA\", \"AAB\", \"BAA\"]\r\n\r\nInput : \"AAA\"\r\nOutput: [\"AAA\"]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Next Permutations",
    "link": "https://www.techiedelight.com/?problem=NextPermutations",
    "category": "Sorting, String",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/NextPermutations/NextPermutations.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find all lexicographically next permutations of it.\r\n\r\nThe words are arranged in the same order in the lexicographic order as they are presumed to appear in a dictionary. For example, the lexicographically next permutation of string \"ABCD\" is \"ABDC\", for string \"ABDC\" is \"ACBD\", and for string \"ACBD\" is \"ACDB\".\r\n\r\nInput : \"ABCD\"\r\nOutput: [\"ABCD\", \"ABDC\", \"ACBD\", \"ACDB\", \"ADBC\", \"ADCB\", \"BACD\", \"BADC\", \"BCAD\", \"BCDA\", \"BDAC\", \"BDCA\", \"CABD\", \"CADB\", \"CBAD\", \"CBDA\", \"CDAB\", \"CDBA\", \"DABC\", \"DACB\", \"DBAC\", \"DBCA\", \"DCAB\", \"DCBA\"]\r\n\r\nInput : \"CABD\"\r\nOutput: [\"CABD\", \"CADB\", \"CBAD\", \"CBDA\", \"CDAB\", \"CDBA\", \"DABC\", \"DACB\", \"DBAC\", \"DBCA\", \"DCAB\", \"DCBA\"]\r\n\r\nInput : \"ABA\"\r\nOutput: [\"ABA\", \"BAA\"]\r\n\r\nInput : \"AAA\"\r\nOutput: [\"AAA\"]\r\n\r\nNote that the solution should not print duplicate permutations.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Lexical Minimal String Rotation",
    "link": "https://www.techiedelight.com/?problem=LexicalMinimalStringRotation",
    "category": "String",
    "tag": "Algorithm",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LexicalMinimalStringRotation/LexicalMinimalStringRotation.java",
    "problem": "/* START *//*\r\n\r\nThe lexicographically minimal string rotation (or lexicographically least circular substring) is the problem of finding a string's rotation possessing the lowest lexicographical order among all possible rotations.\r\n\r\nInput : \"bbaaccaadd\"\r\nOutput: \"aaccaaddbb\"\r\n\r\nNote that a string can have multiple lexicographically minimal rotations, but this doesn't matter \u00e2\u0080\u0093 rotations must be equivalent.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Balanced Parentheses",
    "link": "https://www.techiedelight.com/?problem=BalancedParentheses",
    "category": "String",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/BalancedParentheses/BalancedParentheses.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n, find all strings of length n containing balanced parentheses.\r\n\r\nInput : n = 4\r\nOutput: {\"(())\", \"()()\"}\r\n\r\nInput : n = 6\r\nOutput: {\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"}\r\n\r\nInput : n = 5\r\nOutput: {}\r\nExplanation: Since n is odd, balanced parentheses cannot be formed.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Duplicate Parenthesis",
    "link": "https://www.techiedelight.com/?problem=DuplicateParenthesis",
    "category": "Stack, String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DuplicateParenthesis/DuplicateParenthesis.java",
    "problem": "/* START *//*\r\n\r\nGiven a balanced expression that can contain opening and closing parenthesis, check if it contains any duplicate parenthesis or not.\r\n\r\nInput: \"((x+y))+z\"\r\nOutput: true\r\nExplanation: Duplicate () found in subexpression ((x+y))\r\n\r\nInput: \"(x+y)\"\r\nOutput: false\r\nExplanation: No duplicate () is found\r\n\r\nInput: \"((x+y)+((z)))\"\r\nOutput: true\r\nExplanation: Duplicate () found in subexpression ((z))\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Evaluate Postfix Expression",
    "link": "https://www.techiedelight.com/?problem=EvaluatePostfixExpression",
    "category": "Stack, String",
    "tag": "",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/EvaluatePostfixExpression/EvaluatePostfixExpression.java",
    "problem": "/* START *//*\r\n\r\nGiven a postfix expression, efficiently evaluate it. Assume that the postfix expression contains only single-digit numeric operands, without any whitespace.\r\n\r\nInput: \"82/\"\r\nOutput: 4\r\nExplanation: 82/ will evaluate to 4 (8/2)\r\n\r\nInput: \"138*+\"\r\nOutput: 4\r\nExplanation: 138*+ will evaluate to 25 (1+8*3)\r\n\r\nInput: \"545*+5/\"\r\nOutput: 5\r\nExplanation: 545*+5/ will evaluate to 5 ((5+4*5)/5)\r\n\r\n\r\nAssume valid postfix expression.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Infix to Postfix",
    "link": "https://www.techiedelight.com/?problem=InfixToPostfix",
    "category": "Stack, String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/InfixToPostfix/InfixToPostfix.java",
    "problem": "/* START *//*\r\n\r\nGiven an infix expression, convert it to the postfix expression. Assume that the infix expression is a string of tokens without any whitespace.\r\n\r\nInput: \"A*B+C\"\r\nOutput: \"AB*C+\"\r\n\r\nInput: \"(A+B)*(C/D)\"\r\nOutput: \"AB+CD/*\"\r\n\r\nInput: \"A*(B*C+D*E)+F\"\r\nOutput: \"ABC*DE*+*F+\"\r\n\r\nInput: \"(A+B)*C+(D-E)/F+G\"\r\nOutput: \"AB+C*DE-F/+G+\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Palindrome String",
    "link": "https://www.techiedelight.com/?problem=PalindromeString",
    "category": "Basic, String",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/PalindromeString/PalindromeString.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, check if it is a palindrome. A palindromic string is a string that remains the same with its characters reversed.\r\n\r\nInput : \"ABCBA\"\r\nOutput: true\r\n\r\nInput : \"ABCA\"\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Inversions",
    "link": "https://www.techiedelight.com/?problem=MinimumInversions",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumInversions/MinimumInversions.java",
    "problem": "/* START *//*\r\n\r\nGiven an expression consisting of an opening brace '{' and a closing brace '}', find the minimum number of inversions needed to balance the expression.\r\n\r\nInput : \"{{}{{}{{\"\r\nOutput: 2\r\nExplanation: Minimum number of inversions needed is 2, as shown below:\r\n\r\n{{}{{}{{ \u00e2\u0080\u0094\u00e2\u0080\u0094> {{}{{}}{ \u00e2\u0080\u0094\u00e2\u0080\u0094> {{}{{}}}\r\n\r\n\r\nInput : \"{{{{{{\"\r\nOutput: 3\r\nExplanation: Minimum number of inversions needed is 3, as shown below:\r\n\r\n{{{{{{ \u00e2\u0080\u0094\u00e2\u0080\u0094> {{{}{{ \u00e2\u0080\u0094\u00e2\u0080\u0094> {{{}}{ \u00e2\u0080\u0094\u00e2\u0080\u0094> {{{}}}\r\n\r\n\r\nThe solution should return -1 on invalid input.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Remove Adjacent Duplicates",
    "link": "https://www.techiedelight.com/?problem=RemoveAdjacentDuplicates",
    "category": "String",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RemoveAdjacentDuplicates/RemoveAdjacentDuplicates.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, remove adjacent duplicates characters from it. In other words, remove all consecutive same characters except one.\r\n\r\nInput : \"AABBBCDDD\"\r\nOutput: \"ABCD\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Remove Adjacent Duplicates II",
    "link": "https://www.techiedelight.com/?problem=RemoveAdjacentDuplicatesII",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RemoveAdjacentDuplicatesII/RemoveAdjacentDuplicatesII.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, remove all adjacent duplicates from it. The solution should continue removing adjacent duplicates from the string till no duplicate is present in the result.\r\n\r\nInput : \"DBAABDAB\"\r\nOutput: \"AB\"\r\nExplanation: \"DBAABDAB\" \u00e2\u0080\u0094> \"DBBDAB\" \u00e2\u0080\u0094> \"DDAB\" \u00e2\u0080\u0094> \"AB\"\r\n\r\nInput : \"ABDAADBDAABB\"\r\nOutput: \"AD\"\r\nExplanation: \"ABDAADBDAABB\" \u00e2\u0080\u0094> \"ABDDBD\" \u00e2\u0080\u0094> \"ABBD\" \u00e2\u0080\u0094> \"AD\"\r\n\r\nInput : \"ABADB\"\r\nOutput: \"ABADB\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "First Non Repeating Character",
    "link": "https://www.techiedelight.com/?problem=FirstNonRepeatingCharacter",
    "category": "String",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/FirstNonRepeatingCharacter/FirstNonRepeatingCharacter.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find the index of the first non-repeating character in it by doing only a single traversal of the string.\r\n\r\nInput : \"ABCDBAGHC\"\r\nOutput: 3\r\n\r\nThe solution should return -1 if the string has all characters repeating.\r\n\r\nInput : \"AAA\"\r\nOutput: -1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Lexicographic Permutations",
    "link": "https://www.techiedelight.com/?problem=LexicographicPermutations",
    "category": "Sorting, String",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LexicographicPermutations/LexicographicPermutations.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find all distinct lexicographic permutations of it where the repetition of characters is allowed.\r\n\r\nInput : \"AAB\"\r\nOutput: {\"AAA\", \"AAB\", \"ABA\", \"ABB\", \"BAA\", \"BAB\", \"BBA\", \"BBB\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Lexicographic Rank",
    "link": "https://www.techiedelight.com/?problem=LexicographicRank",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LexicographicRank/LexicographicRank.java",
    "problem": "/* START *//*\r\n\r\nGiven a string containing all distinct characters, calculate its rank among all its lexicographically sorted permutations.\r\n\r\nInput : \"CBA\"\r\nOutput: 6\r\nExplanation: The rank of string \"DCBA\" in the lexicographically sorted permutations [\"ABC\", \"ACB\", \"BAC\", \"BCA\", \"CAB\", \"CBA\"] is 6.\r\n\r\nInput : \"DCBA\"\r\nOutput: 24\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Decode Sequence",
    "link": "https://www.techiedelight.com/?problem=DecodeSequence",
    "category": "Stack, String",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/DecodeSequence/DecodeSequence.java",
    "problem": "/* START *//*\r\n\r\nGiven a sequence consisting of 'I' and 'D', where 'I' denotes the increasing sequence and 'D' denotes the decreasing sequence, decode the sequence to construct a minimum number without repeated digits.\r\n\r\nInput: \"IIDDIDID\"\r\nOutput: \"125437698\"\r\n\r\nInput: \"IDIDII\"\r\nOutput: \"1325467\"\r\n\r\nInput: \"DDDDDDDD\"\r\nOutput: \"987654321\"\r\n\r\nInput: \"IIIIIIII\"\r\nOutput: \"123456789\"\r\n\r\nAssume sequence length <= 8.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "K Distinct Substrings",
    "link": "https://www.techiedelight.com/?problem=KDistinctSubstrings",
    "category": "String",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/KDistinctSubstrings/KDistinctSubstrings.java",
    "problem": "/* START *//*\r\n\r\nGiven a string and a positive integer k, find all distinct substrings of any length containing exactly k distinct characters.\r\n\r\nInput:  str = \"abcbd\", k = 3\r\nOutput: {\"abc\", \"abcb\", \"bcbd\", \"cbd\"}\r\n\r\nInput:  str = \"abcadce\", k = 4\r\nOutput: {\"abcad\", \"abcadc\", \"bcad\", \"bcadc\", \"cadce\", \"adce\"}\r\n\r\nInput:  str = \"aa\", k = 1\r\nOutput: {\"a\", \"aa\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Pattern Match",
    "link": "https://www.techiedelight.com/?problem=PatternMatch",
    "category": "String",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PatternMatch/PatternMatch.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of words and a pattern, find all words in the list that follows the same order of characters as that of the pattern.\r\n\r\nInput:\r\n\r\nwords = [leet, abcd, loot, geek, cool, for, peer, dear, seed, meet, noon, otto, mess, loss]\r\npattern = moon\r\n\r\nOutput: {leet, loot, geek, cool, peer, seed, meet}\r\n\r\nExplanation: Pattern is 4 digits with distinct character at first and last index, and same character at 1st and 2nd index\r\n\r\n\r\nInput:\r\n\r\nwords = [leet, abcd, loot, geek, cool, for, peer, dear, seed, meet, noon, otto, mess, loss]\r\npattern = pqrs\r\n\r\nOutput: {abcd, dear}\r\n\r\nExplanation: Pattern is 4 digits and has all distinct characters\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Pattern Match II",
    "link": "https://www.techiedelight.com/?problem=PatternMatchII",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PatternMatchII/PatternMatchII.java",
    "problem": "/* START *//*\r\n\r\nGiven a string and a pattern, determine whether the string characters follow the specific order defined by the pattern\u00e2\u0080\u0099s characters. You may assume that the pattern contains all distinct characters.\r\n\r\nInput: word = \"Techie Delight\", pattern = \"el\"\r\nOutput: true\r\nExplanation: The pattern characters follow the order [e, e, e, l] in the input string. All e\u00e2\u0080\u0099s appear before 'l'.\r\n\r\nInput: word = \"Techie Delight\", pattern = \"ei\"\r\nOutput: false\r\nExplanation: The pattern characters follow the order [e, i, e, e, i] in the input string. All e\u00e2\u0080\u0099s doesn\u00e2\u0080\u0099t appear before all i\u00e2\u0080\u0099s.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Pattern Match III",
    "link": "https://www.techiedelight.com/?problem=PatternMatchIII",
    "category": "Backtracking, String",
    "tag": "Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/PatternMatchIII/PatternMatchIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a string and a pattern, determine whether a string matches with a given pattern.\r\n\r\nInput: word = \"codesleepcode\", pattern = \"XYX\"\r\nOutput: true\r\nExplanation: 'X' can be mapped to \"code\" and 'Y' can be mapped to \"sleep\"\r\n\r\nInput: word = \"codecodecode\", pattern = \"XXX\"\r\nOutput: true\r\nExplanation: 'X' can be mapped to \"code\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Pattern Match IV",
    "link": "https://www.techiedelight.com/?problem=PatternMatchIV",
    "category": "Dynamic Programming, String",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/PatternMatchIV/PatternMatchIV.java",
    "problem": "/* START *//*\r\n\r\nGiven a string and a pattern, count the number of times pattern appears in the string as a subsequence.\r\n\r\nInput: word = 'subsequence', pattern = 'sue'\r\nOutput: 7\r\nExplanation:\r\n\r\n'su' bs 'e' quence\r\n'su' bsequ 'e' nce\r\n'su' bsequenc 'e'\r\n's' ubseq 'ue' nce\r\n's' ubseq 'u' enc 'e'\r\nsub 's' eq 'ue' nce\r\nsub 's' eq 'u' enc 'e'\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Pattern Match V",
    "link": "https://www.techiedelight.com/?problem=PatternMatchV",
    "category": "String, Trie",
    "tag": "Recursive, Trie",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PatternMatchV/PatternMatchV.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of words where each word follows a CamelCase notation and a pattern containing all uppercase characters, find all words that matches the pattern.\r\n\r\nCamelCase Notation is the practice of writing compound words or phrases joined without spaces, where each word's first letter is capitalized. For example, PowerPoint, LibreOffice, CinemaScope, etc., are in CamelCase.\r\n\r\nInput: words = {Hi, HiTech, HiTechCity, Hello, HelloWorld, HiTechLab}, pattern = HT\r\nOutput: {HiTech, HiTechCity, HiTechLab}\r\n\r\nInput: words = {Hi, HiTech, HiTechCity, Hello, HelloWorld, HiTechLab}, pattern = HTC\r\nOutput: {HiTechCity}\r\n\r\nInput: words = {Hi, HiTech, HiTechCity, Hello, HelloWorld, HiTechLab}, pattern = H\r\nOutput: {Hi, HiTech, HiTechCity, Hello, HelloWorld, HiTechLab}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Wildcard Pattern Matching",
    "link": "https://www.techiedelight.com/?problem=WildcardPatternMatching",
    "category": "Backtracking, Stack, String",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/WildcardPatternMatching/WildcardPatternMatching.java",
    "problem": "/* START *//*\r\n\r\nGiven a binary pattern containing '?' wildcard character at a few positions, return all possible combinations of binary strings that can be formed by replacing the wildcard character by either '0' or '1'.\r\n\r\nInput: \"1?11?00?1?\"\r\nOutput: {\"1011000010\", \"1011000011\", \"1011000110\", \"1011000111\", \"1011100010\", \"1011100011\", \"1011100110\", \"1011100111\", \"1111000010\", \"1111000011\", \"1111000110\", \"1111000111\", \"1111100010\", \"1111100011\", \"1111100110\", \"1111100111\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Wildcard Pattern Matching II",
    "link": "https://www.techiedelight.com/?problem=WildcardPatternMatchingII",
    "category": "Dynamic Programming, String",
    "tag": "Algorithm, Recursive, Top-down, Bottom-up",
    "lists": "TopClassic, TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/WildcardPatternMatchingII/WildcardPatternMatchingII.java",
    "problem": "/* START *//*\r\n\r\nGiven a word and a pattern containing wildcard characters '*' and '?', check if the pattern matches with the complete string or not. Here, '?' can match to any single character in the string and '*' can match to any number of characters including zero characters.\r\n\r\nInput: word = \"xyxzzxy\", pattern = \"x***y\"\r\nOutput: true\r\n\r\nInput: word = \"xyxzzxy\", pattern = \"x***x\"\r\nOutput: false\r\n\r\nInput: word = \"xyxzzxy\", pattern = \"x***x?\"\r\nOutput: true\r\n\r\nInput: word = \"xyxzzxy\", pattern = \"*\"\r\nOutput: true\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Balanced Parenthesis",
    "link": "https://www.techiedelight.com/?problem=LongestBalancedParenthesis",
    "category": "Stack, String",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LongestBalancedParenthesis/LongestBalancedParenthesis.java",
    "problem": "/* START *//*\r\n\r\nGiven a string consisting of opening and closing parenthesis, find the length of the longest balanced parenthesis in it.\r\n\r\nInput: \"((()()\"\r\nOutput: 4\r\nExplanation: The longest balanced parenthesis is \"()()\"\r\n\r\nInput: \"(()())(()\"\r\nOutput: 6\r\nExplanation: The longest balanced parenthesis is \"(()())\"\r\n\r\nInput: \"(((()\"\r\nOutput: 2\r\nExplanation: The longest balanced parenthesis is \"()\"\r\n\r\nInput: \"((((\"\r\nOutput: 0\r\nExplanation: The longest balanced parenthesis is \"\"\r\n\r\nInput: \"()()\"\r\nOutput: 4\r\nExplanation: The longest balanced parenthesis is \"()()\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Palindrome",
    "link": "https://www.techiedelight.com/?problem=LongestPalindrome",
    "category": "String",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestPalindrome/LongestPalindrome.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find the length of the longest palindrome which can be constructed by shuffling or deleting characters in the string.\r\n\r\nInput: \"ABBDAB\"\r\nOutput: 5\r\nExplanation: The longest palindrome is \"BABAB\" (or \"BADAB\" or \"ABBBA\" or \"ABDBA\")\r\n\r\nInput: \"ABCDD\"\r\nOutput: 3\r\nExplanation: The longest palindrome is \"DAD\" (or \"DBD\" or \"DCD\")\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Text",
    "link": "https://www.techiedelight.com/?problem=ReverseText",
    "category": "Stack, String",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseText/ReverseText.java",
    "problem": "/* START *//*\r\n\r\nGiven a line of text, reverse the text without reversing the individual words.\r\n\r\nInput : \"Technical Interview Preparation\"\r\nOutput: \"Preparation Interview Technical\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "N Digit Numbers",
    "link": "https://www.techiedelight.com/?problem=NDigitNumbers",
    "category": "String",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/NDigitNumbers/NDigitNumbers.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n between 1 and 9, find all n\u00e2\u0080\u0093digit strictly increasing numbers. A number is strictly increasing if every digit is greater than its preceding digit.\r\n\r\nInput: n = 8\r\nOutput: {12345678, 12345679, 12345689, 12345789, 12346789, 12356789, 12456789, 13456789, 23456789}\r\n\r\nInput: n = 7\r\nOutput: {1234567, 1234568, 1234569, 1234578, 1234579, 1234589, 1234678, 1234679, 1234689, 1234789, 1235678, 1235679, 1235689, 1235789, 1236789, 1245678, 1245679, 1245689, 1245789, 1246789, 1256789, 1345678, 1345679, 1345689, 1345789, 1346789, 1356789, 1456789, 2345678, 2345679, 2345689, 2345789, 2346789, 2356789, 2456789, 3456789}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "N Digit Numbers II",
    "link": "https://www.techiedelight.com/?problem=NDigitNumbersII",
    "category": "String",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/NDigitNumbersII/NDigitNumbersII.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive integer n, find all n\u00e2\u0080\u0093digit binary numbers having more 1\u00e2\u0080\u0099s than 0\u00e2\u0080\u0099s for any prefix of the number.\r\n\r\nInput : n = 4\r\nOutput: {\"1111\", \"1110\", \"1101\", \"1100\", \"1011\", \"1010\"}\r\n\r\nNote that 1001 will not form part of the solution as it violates the problem constraints (1001 has 2 zeros and 1 one at third position). The same applies to all other 4\u00e2\u0080\u0093digit binary numbers.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "N Digit Numbers III",
    "link": "https://www.techiedelight.com/?problem=NDigitNumbersIII",
    "category": "String",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/NDigitNumbersIII/NDigitNumbersIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n between 1 and 9, find all n\u00e2\u0080\u0093digit numbers with a given sum where sum <= 81 (Maximum possible sum in a 9\u00e2\u0080\u0093digit number).\r\n\r\nInput: n = 3, target = 6\r\n\r\nOutput: {105, 114, 123, 132, 141, 150, 204, 213, 222, 231, 240, 303, 312, 321, 330, 402, 411, 420, 501, 510, 600}\r\n\r\n\r\nInput: n = 5, target = 42\r\n\r\nOutput: {69999, 78999, 79899, 79989, 79998, 87999, 88899, 88989, 88998, 89799, 89889, 89898, 89979, 89988, 89997, 96999, 97899, 97989, 97998, 98799, 98889, 98898, 98979, 98988, 98997, 99699, 99789, 99798, 99879, 99888, 99897, 99969, 99978, 99987, 99996}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "N Digit Numbers IV",
    "link": "https://www.techiedelight.com/?problem=NDigitNumbersIV",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/NDigitNumbersIV/NDigitNumbersIV.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n between 1 and 9, find all n\u00e2\u0080\u0093digit binary numbers with k\u00e2\u0080\u0093bits set where k ranges from 1 to n.\r\n\r\nInput: n = 4\r\n\r\nOutput: {\"0001\", \"0010\", \"0100\", \"1000\", \"0011\", \"0101\", \"0110\", \"1001\", \"1010\", \"1100\", \"0111\", \"1011\", \"1101\", \"1110\", \"1111\"}\r\n\r\nExplanation: 4\u00e2\u0080\u0093digit binary numbers are:\r\n\r\n(k = 1) 0001 0010 0100 1000\r\n(k = 2) 0011 0101 0110 1001 1010 1100\r\n(k = 3) 0111 1011 1101 1110\r\n(k = 4) 1111\r\n\r\n\r\nInput: n = 5\r\n\r\nOutput: {\"00001\", \"00010\", \"00100\", \"01000\", \"10000\", \"00011\", \"00101\", \"00110\", \"01001\", \"01010\", \"01100\", \"10001\", \"10010\", \"10100\", \"11000\", \"00111\", \"01011\", \"01101\", \"01110\", \"10011\", \"10101\", \"10110\", \"11001\", \"11010\", \"11100\", \"01111\", \"10111\", \"11011\", \"11101\", \"11110\", \"11111\"}\r\n\r\nExplanation: 5\u00e2\u0080\u0093digit binary numbers are:\r\n\r\n(k = 1) 00001 00010 00100 01000 10000\r\n(k = 2) 00011 00101 00110 01001 01010 01100 10001 10010 10100 11000\r\n(k = 3) 00111 01011 01101 01110 10011 10101 10110 11001 11010 11100\r\n(k = 4) 01111 10111 11011 11101 11110\r\n(k = 5) 11111\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "N Digit Numbers V",
    "link": "https://www.techiedelight.com/?problem=NDigitNumbersV",
    "category": "String",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/NDigitNumbersV/NDigitNumbersV.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n between 1 and 9, find all n\u00e2\u0080\u0093digit binary numbers with an equal sum of left and right half. The binary number should not start with 0 and for odd numbers, the middle element can be 0 or 1.\r\n\r\nInput: n = 6\r\nOutput: {\"100001\", \"100010\", \"101011\", \"110011\", \"100100\", \"101101\", \"101110\", \"110101\", \"110110\", \"111111\"}\r\n\r\nInput: n = 7\r\nOutput: {\"1000001\", \"1001001\", \"1000010\", \"1001010\", \"1010011\", \"1011011\", \"1100011\", \"1101011\", \"1000100\", \"1001100\", \"1010101\", \"1011101\", \"1010110\", \"1011110\", \"1100101\", \"1101101\", \"1100110\", \"1101110\", \"1110111\", \"1111111\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "N Digit Numbers VI",
    "link": "https://www.techiedelight.com/?problem=NDigitNumbersVI",
    "category": "Backtracking, String",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/NDigitNumbersVI/NDigitNumbersVI.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n between 2 and 9, find all n\u00e2\u0080\u0093digit numbers with an equal sum of digits at even and odd indices.\r\n\r\nInput: n = 3\r\nOutput: {110, 121, 132, 143, 154, 165, 176, 187, 198, 220, 231, 242, 253, 264, 275, 286, 297, 330, 341, 352, 363, 374, 385, 396, 440, 451, 462, 473, 484, 495, 550, 561, 572, 583, 594, 660, 671, 682, 693, 770, 781, 792, 880, 891, 990}\r\n\r\nInput: n = 5\r\nOutput: {10010, 10021, 10032, 10043, 10054, 10065, 10076, 10087, 10098, 10120, 10131, 10142, 10153, 10164, 10175, 10186, 10197, 10230, 10241, 10252, 10263, 10274, 10285, 10296, 10340, 10351, 10362, 10373, 10384, 10395, 10450, 10461, 10472, 10483, 10494, 10560, 10571, 10582, 10593, 10670, 10681, 10692, 10780, 10791, 10890, 11000, 11011, 11022, 11033, 11044, 11055, 11066, 11077, 11088, 11099, 11110, 11121, 11132, 11143, 11154, 11165, 11176, 11187, 11198, 11220}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "N Digit Numbers VII",
    "link": "https://www.techiedelight.com/?problem=NDigitNumbersVII",
    "category": "Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/NDigitNumbersVII/NDigitNumbersVII.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive integer n, return all n\u00e2\u0080\u0093digit binary numbers without any consecutive 1's.\r\n\r\nInput: n = 5\r\nOutput: {\"00000\", \"00001\", \"00010\", \"00100\", \"00101\", \"01000\", \"01001\", \"01010\", \"10000\", \"10001\", \"10010\", \"10100\", \"10101\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "First K Non Repeating",
    "link": "https://www.techiedelight.com/?problem=FirstKNonRepeating",
    "category": "Heap, String",
    "tag": "Hashing, Priority Queue",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/FirstKNonRepeating/FirstKNonRepeating.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find first `k` non-repeating characters in it by doing only a single traversal of it.\r\n\r\nInput: s = \"ABCDBAGHCHFAC\", k = 3\r\nOutput: ['D', 'G', 'F']\r\n\r\nInput: s = \"ABBCDAB\", k = 3\r\nOutput: ['C', 'D']\r\n\r\nIf `k` is more than the non-repeating characters count, return all possible non-repeating characters.\r\n\r\nInput: s = \"YYXBYX\", k = 2\r\nOutput: ['B']\r\n\r\nInput: s = \"YYXBYXB\", k = 3\r\nOutput: []\r\n\r\nNote: The solution should return non-repeating characters in the same order as they appear in the string.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "K Palindrome String",
    "link": "https://www.techiedelight.com/?problem=KPalindromeString",
    "category": "Dynamic Programming, String",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/KPalindromeString/KPalindromeString.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, check if it is k\u00e2\u0080\u0093palindrome or not. A string is k\u00e2\u0080\u0093palindrome if it becomes a palindrome on removing at-most k characters from it.\r\n\r\nInput: s = \"ABCDBA\", k = 1\r\nOutput: true\r\nExplanation: The string becomes a palindrome by removing either C or D from it.\r\n\r\nInput: s = \"ABCDECA\", k = 1\r\nOutput: false\r\nExplanation: The string needs at least 2\u00e2\u0080\u0093removals from it to become a palindrome.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Delete Operations",
    "link": "https://www.techiedelight.com/?problem=MinimumDeleteOperations",
    "category": "Dynamic Programming, String",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumDeleteOperations/MinimumDeleteOperations.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find the minimum number of deletions required to convert it into a palindrome.\r\n\r\nInput: s = \"ACBCDBAA\"\r\nOutput: 3\r\nExplanation: The minimum number of deletions required to convert \"ACBCDBAA\" into a palindrome string \"ABCBA\" is 3.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Cut Palindromic Partition",
    "link": "https://www.techiedelight.com/?problem=MinimumCutPalindromicPartition",
    "category": "Dynamic Programming, String",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumCutPalindromicPartition/MinimumCutPalindromicPartition.java",
    "problem": "/* START *//*\r\n\r\nGiven a string, find the minimum cuts needed to partition it such that each partition is a palindrome.\r\n\r\nInput: s = \"BABABCBADCD\"\r\nOutput: 2\r\nExplanation: The minimum cuts required are 2 as \"BAB|ABCBA|DCD\".\r\n\r\nInput: s = \"ABCBA\"\r\nOutput: 0\r\nExplanation: The minimum cuts required are 0 as \"ABCBA\" is already a palindrome.\r\n\r\nInput: s = \"ABCD\"\r\nOutput: 3\r\nExplanation: The minimum cuts required are 3 as \"A|B|C|D\".\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Lexicographic Sorting",
    "link": "https://www.techiedelight.com/?problem=LexicographicSorting",
    "category": "Sorting, String, Trie",
    "tag": "Depth-First Search, Recursive, Trie",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LexicographicSorting/LexicographicSorting.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of strings, return them in lexicographic order (dictionary/alphabetical order).\r\n\r\nInput: [code, coder, coding, coded, codex, codify, codependents, codes, codesign, codeveloper]\r\nOutput: [code, coded, codependents, coder, codes, codesign, codeveloper, codex, codify, coding]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shortest Unique Prefix",
    "link": "https://www.techiedelight.com/?problem=ShortestUniquePrefix",
    "category": "String, Trie",
    "tag": "Depth-First Search, Recursive, Trie",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ShortestUniquePrefix/ShortestUniquePrefix.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of words in lexicographic order where no word is the prefix of another, find the shortest unique prefix to identify each word in the array uniquely.\r\n\r\nInput: [\"AND\", \"BONFIRE\", \"BOOL\", \"CASE\", \"CATCH\", \"CHAR\"]\r\nOutput: [\"A\", \"BON\", \"BOO\", \"CAS\", \"CAT\", \"CH\"]\r\n\r\nExplanation:\r\n\r\n\"A\" can uniquely identify \"AND\"\r\n\"BON\" can uniquely identify \"BONFIRE\"\r\n\"BOO\" can uniquely identify \"BOOL\"\r\n\"CAS\" can uniquely identify \"CASE\"\r\n\"CAT\" can uniquely identify \"CATCH\"\r\n\"CH\" can uniquely identify \"CHAR\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Turn off Kth Bit",
    "link": "https://www.techiedelight.com/?problem=TurnOffKthBit",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/TurnOffKthBit/TurnOffKthBit.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer n and a positive number k, turn off k'th bit in n.\r\n\r\nInput: n = 20, k = 3\r\nOutput: 16\r\nExplanation:\r\n\r\n20 in binary is 00010100\r\n16 in binary is 00010000\r\n\r\nInput: n = -20, k = 3\r\nOutput: -24\r\nExplanation:\r\n\r\n-20 in binary is 1111111111101100\r\n-24 in binary is 1111111111101000\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Turn on Kth Bit",
    "link": "https://www.techiedelight.com/?problem=TurnOnKthBit",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/TurnOnKthBit/TurnOnKthBit.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer n and a positive number k, turn on k'th bit in n.\r\n\r\nInput: n = 20, k = 4\r\nOutput: 28\r\nExplanation:\r\n\r\n20 in binary is 00010100\r\n28 in binary is 00011100\r\n\r\n\r\nInput: n = -24, k = 3\r\nOutput: -20\r\nExplanation:\r\n\r\n-24 in binary is 1111111111101000\r\n-20 in binary is 1111111111101100\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Kth Bit Set",
    "link": "https://www.techiedelight.com/?problem=IsKthBitSet",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/IsKthBitSet/IsKthBitSet.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer n and a positive number k, check if k'th bit is set or not.\r\n\r\nInput: n = 20, k = 3\r\nOutput: true\r\nExplanation: 20 in binary is 00010100\r\n\r\nInput: n = 16, k = 3\r\nOutput: false\r\nExplanation: 16 in binary is 00010000\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Toggle Kth Bit",
    "link": "https://www.techiedelight.com/?problem=ToggleKthBit",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ToggleKthBit/ToggleKthBit.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer n and a positive number k, toggle k'th bit of n.\r\n\r\nInput: n = 20, k = 3\r\nOutput: 16\r\nExplanation: 20 in binary is 00010100 and 16 in binary is 00010000\r\n\r\nInput: n = 16, k = 3\r\nOutput: 20\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Unset Rightmost Set Bit",
    "link": "https://www.techiedelight.com/?problem=UnsetRightmostSetBit",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/UnsetRightmostSetBit/UnsetRightmostSetBit.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer, unset its rightmost set bit.\r\n\r\nInput: n = 20\r\nOutput: 16\r\nExplanation:\r\n\r\n20 in binary is 00010100\r\n16 in binary is 00010000\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Position of Rightmost Set Bit",
    "link": "https://www.techiedelight.com/?problem=PositionOfRightmostSetBit",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/PositionOfRightmostSetBit/PositionOfRightmostSetBit.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer, find position of the rightmost set bit in it.\r\n\r\nInput: n = 20\r\nOutput: 3\r\nExplanation: 20 in binary is 00010100\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Count Set Bits",
    "link": "https://www.techiedelight.com/?problem=CountSetBits",
    "category": "Bit Manipulation",
    "tag": "Algorithm",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CountSetBits/CountSetBits.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer, count its set bits.\r\n\r\nInput: n = 16\r\nOutput: 1\r\nExplanation: The binary representation of 16 is 00000000000000000000000000001000.\r\n\r\nInput: n = -1\r\nOutput: 32\r\nExplanation: The binary representation of -1 is 11111111111111111111111111111111.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Count Flipped Bits",
    "link": "https://www.techiedelight.com/?problem=CountFlippedBits",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CountFlippedBits/CountFlippedBits.java",
    "problem": "/* START *//*\r\n\r\nGiven two integers x and y, find the total number of bits needed to be flipped for converting x to y.\r\n\r\nInput: x = 65, y = 80\r\nOutput: 2\r\nExplanation: The total number of bits to be flipped is 2 since 65 is 01000001 in binary and 80 is 01010000 in binary.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Next Power of 2",
    "link": "https://www.techiedelight.com/?problem=NextPowerOf2",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/NextPowerOf2/NextPowerOf2.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n, find the next highest power of 2. If n itself is a power of 2, return n.\r\n\r\nInput: n = 20\r\nOutput: 32\r\n\r\nInput: n = 16\r\nOutput: 16\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Previous Power of 2",
    "link": "https://www.techiedelight.com/?problem=PreviousPowerOf2",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PreviousPowerOf2/PreviousPowerOf2.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n, find the previous power of 2. If n itself is a power of 2, return n.\r\n\r\nInput: n = 20\r\nOutput: 16\r\n\r\nInput: n = 16\r\nOutput: 16\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Parity of Number",
    "link": "https://www.techiedelight.com/?problem=ParityOfNumber",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ParityOfNumber/ParityOfNumber.java",
    "problem": "/* START *//*\r\n\r\nGiven a number n, compute its parity. The parity is related to the total number of 1's in the binary number. The odd parity (encoded as 1) means an odd number of 1's and even parity (encoded as 0) means an even number of 1's.\r\n\r\nThe solution should return true if the number has odd parity and false if the number has even parity.\r\n\r\nInput: 127\r\nOutput: true\r\nExplanation: 127 is 01111111 in binary and contains odd number of bits.\r\n\r\nInput: 17\r\nOutput: false\r\nExplanation: 17 is 00010001 in binary and contains even number of bits.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Swap Bits",
    "link": "https://www.techiedelight.com/?problem=SwapBits",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SwapBits/SwapBits.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer, swap two bits at given positions in a binary representation of it.\r\n\r\nInput:\r\n\r\nn = 31\r\np = 2, q = 6 (3rd and 7th bit from the right)\r\n\r\nOutput: 91\r\n\r\nExplanation:\r\n\r\n31 in binary is 00011111\r\n91 in binary is 01011011\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Swap Bits II",
    "link": "https://www.techiedelight.com/?problem=SwapBitsII",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/SwapBitsII/SwapBitsII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer `n`, swap consecutive `b` bits starting from the given positions `p` and `q` in a binary representation of an integer. The bits to be swapped should not overlap with each other.\r\n\r\nInput:\r\n\r\nn = 15\r\np = 2, q = 5\t(3rd and 6th bit from the right)\r\nb = 2\t\t\t(Total number of consecutive bits in each sequence)\r\n\r\nOutput: 99\r\n\r\nExplanation:\r\n\r\n15 in binary is 00001111\r\n99 in binary is 01100011\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Power of 4",
    "link": "https://www.techiedelight.com/?problem=PowerOf4",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PowerOf4/PowerOf4.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number, check if it is a power of 4 or not.\r\n\r\nInput: 256\r\nOutput: true\r\n\r\nInput: 25\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Power of 8",
    "link": "https://www.techiedelight.com/?problem=PowerOf8",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PowerOf8/PowerOf8.java",
    "problem": "/* START *//*\r\n\r\nGiven a number, check if it is a power of 8 or not.\r\n\r\nInput: 512\r\nOutput: true\r\n\r\nInput: 56\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Bits",
    "link": "https://www.techiedelight.com/?problem=ReverseBits",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseBits/ReverseBits.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer, reverse its bits using binary operators.\r\n\r\nInput: -100\r\nOutput: 973078527\r\nExplanation: -100 in binary is 11111111111111111111111110011100. Reversing its bits results in number 973078527, which is 00111001111111111111111111111111 in binary.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Swap Adjacent Bits",
    "link": "https://www.techiedelight.com/?problem=SwapAdjacentBits",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SwapAdjacentBits/SwapAdjacentBits.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer, swap adjacent bits of it. In other words, swap bits present at even positions with those present in odd positions.\r\n\r\nInput:  761622921\r\nOutput: 513454662\r\n\r\nExplanation:\r\n\r\n761622921 (00 10 11 01 01 10 01 01 01 11 00 01 10 00 10 01)\r\n513454662 (00 01 11 10 10 01 10 10 10 11 00 10 01 00 01 10)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Adjacent Set Bits",
    "link": "https://www.techiedelight.com/?problem=AdjacentSetBits",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/AdjacentSetBits/AdjacentSetBits.java",
    "problem": "/* START *//*\r\n\r\nGiven a number, check if adjacent bits are set in the binary representation of it.\r\n\r\nInput : 67\r\nOutput: true\r\nExplanation: 67 in binary is 01000011 and has adjacent pair of set bits.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Decimal to Binary",
    "link": "https://www.techiedelight.com/?problem=DecimalToBinary",
    "category": "Basic, Bit Manipulation, C, C++, Java, Python",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/DecimalToBinary/DecimalToBinary.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer, find its 32-bit binary representation without using built-in functions.\r\n\r\nInput:  20\r\nOutput: \"00000000000000000000000000010100\"\r\n\r\nInput:  64\r\nOutput: \"00000000000000000000000001000000\"\r\n\r\nInput:  127\r\nOutput: \"00000000000000000000000001111111\"\r\n\r\nInput:  -1\r\nOutput: \"11111111111111111111111111111111\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Add Binary",
    "link": "https://www.techiedelight.com/?problem=AddBinary",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/AddBinary/AddBinary.java",
    "problem": "/* START *//*\r\n\r\nGiven two integers, add their binary representation.\r\n\r\nInput: x = 12731, y = 38023\r\nOutput: \"00000000000000001100011001000010\"\r\n\r\nExplanation:\r\n\r\nx (12731) in binary is 00000000000000000011000110111011\r\ny (38023) in binary is 00000000000000001001010010000111\r\nx + y is 00000000000000001100011001000010\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Circular Shift",
    "link": "https://www.techiedelight.com/?problem=CircularShift",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CircularShift/CircularShift.java",
    "problem": "/* START *//*\r\n\r\nGiven two positive integers n and k, perform a circular shift on the binary representation of n by k positions.\r\n\r\nThe circular shift can be of two types:\r\n\r\n\u00e2\u0080\u00a2 Left circular shift (moving the final bit to the first position while shifting all other bits to the next position).\r\n\u00e2\u0080\u00a2 Right circular shift (moving the first bit to the last position while shifting all other bits to the previous position).\r\n\r\n\r\nInput: n = 127, k = 3, isLeftShift = true\r\nOutput: 1016\r\n\r\nExplanation:\r\n\r\nThe binary representation for n = 127 is: 00000000000000000000000001111111\r\nLeft shift 127 by 3 positions results in: 00000000000000000000001111111000\r\n\r\n\r\nInput: n = 127, k = 3, isLeftShift = false\r\nOutput: -536870897\r\n\r\nExplanation:\r\n\r\nThe binary representation for n = 127 is : 00000000000000000000000001111111\r\nRight shift 127 by 3 positions results in: 11100000000000000000000000001111\r\n\r\n\r\nAssume integer size to be 32 bits (4 bytes).\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "XOR Without XORing",
    "link": "https://www.techiedelight.com/?problem=XORWithoutXORing",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/XORWithoutXORing/XORWithoutXORing.java",
    "problem": "/* START *//*\r\n\r\nGiven two integers, find their XOR without using the XOR operator.\r\n\r\nInput: x = 65, y = 80\r\nOutput: 17\r\nExplanation: x in binary is 01000001 and y in binary is 01010000. Their XOR is 00010001, which is 17 in decimal.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Power Set",
    "link": "https://www.techiedelight.com/?problem=PowerSet",
    "category": "Array, Backtracking, Bit Manipulation",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PowerSet/PowerSet.java",
    "problem": "/* START *//*\r\n\r\nGiven a set S, return all subsets of it, i.e., find the power set of S. A power set of a set S is the set of all subsets of S, including the empty set and S itself.\r\n\r\nInput : S[] = [1, 2, 3]\r\nOutput: [[3, 2, 1], [3, 2], [3, 1], [3], [2, 1], [2], [1], []]\r\n\r\nInput : S[] = [1, 2, 1]\r\nOutput: [[1, 2, 1], [1, 2], [1, 1], [1], [2, 1], [2], [1], []]\r\n\r\nInput : S[] = [1, 1]\r\nOutput: [[1, 1], [1], [1], []]\r\n\r\nInput : S[] = []\r\nOutput: [[]]\r\n\r\nNote: The solution can return elements of a subsets in any order.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Power Set II",
    "link": "https://www.techiedelight.com/?problem=PowerSetII",
    "category": "Array, Backtracking, Bit Manipulation, Sorting",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/PowerSetII/PowerSetII.java",
    "problem": "/* START *//*\r\n\r\nGiven a set S, return all distinct subsets of it, i.e., find distinct power set of set S. A power set of any set S is the set of all subsets of S, including the empty set and S itself.\r\n\r\nInput : S[] = [1, 2, 3]\r\nOutput: [[1, 2, 3], [2, 3], [1, 3], [3], [1, 2], [2], [1], []]\r\n\r\nInput : S[] = [1, 2, 1]\r\nOutput: [[1, 1, 2], [1, 2], [2], [1, 1], [1], []]\r\n\r\nInput : S[] = [1, 1]\r\nOutput: [[1, 1], [1], []]\r\n\r\nInput : S[] = []\r\nOutput: [[]]\r\n\r\nNote: The solution can return elements of a subsets in any order.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Missing Number",
    "link": "https://www.techiedelight.com/?problem=MissingNumber",
    "category": "Array, Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MissingNumber/MissingNumber.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of `n-1` distinct integers in the range of 1 to `n`, find the missing number in it in linear time.\r\n\r\nInput: [1, 2, 3, 4, 5, 7, 8, 9, 10]\r\nOutput: 6\r\nExplanation: All elements are in the range 1 to 10. The missing number is 6.\r\n\r\nInput: [1, 2, 3, 4]\r\nOutput: 5\r\n\r\nAssume valid input.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Missing Number II",
    "link": "https://www.techiedelight.com/?problem=MissingNumberII",
    "category": "Array, Bit Manipulation",
    "tag": "",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MissingNumberII/MissingNumberII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array of size `n` and containing elements between 1 and `n+1` with one element missing, find the missing number using constant space.\r\n\r\nInput: [3, 2, 4, 6, 1]\r\nOutput: 5\r\n\r\nInput: [3, 2, 4, 5, 6]\r\nOutput: 1\r\n\r\nInput: [3, 2, 4, 5, 1]\r\nOutput: 6\r\n\r\nAssume valid input.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Missing Number III",
    "link": "https://www.techiedelight.com/?problem=MissingNumberIII",
    "category": "Array, Divide & Conquer",
    "tag": "Binary Search",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MissingNumberIII/MissingNumberIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a sequence of n numbers such that the difference between the consecutive terms is constant, find the missing term in logarithmic time.\r\n\r\nInput: [5, 7, 9, 11, 15]\r\nOutput: 13\r\n\r\nInput: [1, 4, 7, 13, 16]\r\nOutput: 10\r\n\r\nInput: [4, 8]\r\nOutput: 6\r\n\r\nAssume valid input and n >= 2. Also, assume that the first and last elements are always part of the input sequence and the missing number lies between index 1 to n-1.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Odd Occurring Element",
    "link": "https://www.techiedelight.com/?problem=OddOccurringElement",
    "category": "Array, Bit Manipulation",
    "tag": "Hashing",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/OddOccurringElement/OddOccurringElement.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, duplicates are present in it in a way that all duplicates appear an even number of times except one which appears an odd number of times. Find that odd appearing element in linear time and without using any extra memory.\r\n\r\nInput: [4, 3, 6, 2, 6, 4, 2, 3, 4, 3, 3]\r\nOutput: 4\r\n\r\nAssume valid input.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Odd Occurring Element II",
    "link": "https://www.techiedelight.com/?problem=OddOccurringElementII",
    "category": "Array, Bit Manipulation",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/OddOccurringElementII/OddOccurringElementII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, duplicates appear in it an even number of times except for two elements, which appear an odd number of times. Find both odd appearing elements without using any extra memory.\r\n\r\nInput: [4, 3, 6, 2, 4, 2, 3, 4, 3, 3]\r\nOutput: (4, 6)\r\nExplanation: The odd occurring elements are 4 and 6 as\r\n\r\n6 appears once.\r\n2 appears twice.\r\n4 appears thrice.\r\n3 appears 4 times.\r\n\r\nNote: The solution can return a pair of odd appearing elements in any order. Assume valid input.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Odd Occurring Element III",
    "link": "https://www.techiedelight.com/?problem=OddOccurringElementIII",
    "category": "Array, Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/OddOccurringElementIII/OddOccurringElementIII.java",
    "problem": "/* START *//*\r\n\r\nGiven an array having elements between 0 and 31, find elements that occur an odd number of times using constant space.\r\n\r\nInput : [5, 8, 2, 5, 8, 2, 8, 5, 1, 8, 2]\r\nOutput: {5, 2, 1}\r\n\r\nExplanation:\r\n\r\n1 occurs once.\r\n2 and 5 occurs thrice.\r\n8 occurs four times.\r\n\r\nAssume valid input.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Odd Occurring Element IV",
    "link": "https://www.techiedelight.com/?problem=OddOccurringElementIV",
    "category": "Array, Bit Manipulation, Divide & Conquer, Sorting",
    "tag": "Binary Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/OddOccurringElementIV/OddOccurringElementIV.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array where every element appears an even number of times, except one element which appears an odd number of times. If the identical elements appear in pairs in the array and there cannot be more than two consecutive occurrences of an element, find the odd occurring element in logarithmic time and constant space.\r\n\r\nInput: [2, 2, 3, 3, 2, 2, 4, 4, 3, 1, 1]\r\nOutput: 3\r\n\r\nAssume valid input. For instance, both arrays [1, 2, 1] and [1, 1, 2, 2, 2, 3, 3] are invalid. The first one doesn't have identical elements appear in pairs, and the second one contains three consecutive instances of an element.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Duplicate Element",
    "link": "https://www.techiedelight.com/?problem=DuplicateElement",
    "category": "Array, Bit Manipulation",
    "tag": "Hashing",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DuplicateElement/DuplicateElement.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array of size `n` containing elements between 1 and `n-1` with one element repeating, find the duplicate number in it using constant space.\r\n\r\nInput: [1, 2, 3, 4, 4]\r\nOutput: 4\r\n\r\nInput: [1, 2, 3, 4, 2]\r\nOutput: 2\r\n\r\nInput: [1, 1]\r\nOutput: 1\r\n\r\nAssume valid input.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Duplicate Element II",
    "link": "https://www.techiedelight.com/?problem=DuplicateElementII",
    "category": "Array, Bit Manipulation",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DuplicateElementII/DuplicateElementII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array of size `n+2` containing elements between 1 and `n` with two element repeating, find both duplicate elements without using any extra memory in linear time.\r\n\r\nInput: [4, 3, 6, 5, 2, 4, 1, 1]\r\nOutput: (1, 4)\r\n\r\nInput: [2, 1, 1, 2]\r\nOutput: (1, 2)\r\n\r\nNote: The solution can return a pair of duplicate elements in any order. Assume valid input.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Missing and Duplicate Element",
    "link": "https://www.techiedelight.com/?problem=MissingAndDuplicateElement",
    "category": "Array, Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MissingAndDuplicateElement/MissingAndDuplicateElement.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array of size `n`, with all its elements between 1 and `n` and one element occurring twice and one element missing. Find the missing number and the duplicate element in linear time and without using any extra memory.\r\n\r\nInput: [4, 3, 6, 5, 2, 4]\r\nOutput: (4, 1)\r\nExplanation: The duplicate element is 4 and the missing element is 1.\r\n\r\nInput: [4, 2, 2, 1]\r\nOutput: (2, 3)\r\nExplanation: The duplicate element is 2 and the missing element is 3.\r\n\r\nNote: The solution should return (duplicate element, missing element) pair. Assume valid input.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Check Min Heap",
    "link": "https://www.techiedelight.com/?problem=CheckMinHeap",
    "category": "Array, Heap",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CheckMinHeap/CheckMinHeap.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, check if it represents min-heap or not.\r\n\r\nInput : [2, 3, 4, 5, 10, 15]\r\nOutput: true\r\nExplanation: The input represents a min-heap.\r\n\r\n\t\t   2\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   3\t   4\r\n\t  / \\\t  /\r\n\t /   \\   /\r\n\t5\t 10 15\r\n\r\nInput : [2, 10, 4, 5, 3, 15]\r\nOutput: false\r\nExplanation: The input is not a min-heap, as it violate the heap property.\r\n\r\n\t\t   2\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   10\t   4\r\n\t  / \\\t  /\r\n\t /   \\   /\r\n\t5\t  3 15\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Max Heap to Min Heap",
    "link": "https://www.techiedelight.com/?problem=MaxHeapToMinHeap",
    "category": "Array, Heap",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MaxHeapToMinHeap/MaxHeapToMinHeap.java",
    "problem": "/* START *//*\r\n\r\nGiven an array representing a max-heap, in-place convert it into the min-heap in linear time.\r\n\r\nInput: [9, 4, 7, 1, -2, 6, 5]\r\n\r\n\t\t   9\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   4\t   7\r\n\t  / \\\t  / \\\r\n\t /   \\   /   \\\r\n\t1\t -2 6\t  5\r\n\r\n\r\nOutput: [-2, 1, 5, 9, 4, 6, 7]\r\n\r\n\t\t   -2\r\n\t\t /\t  \\\r\n\t\t/\t   \\\r\n\t   1\t\t5\r\n\t  / \\\t   / \\\r\n\t /   \\\t  /   \\\r\n\t9\t  4  6\t   7\t\tor, any other valid min-heap.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Kth Smallest Element",
    "link": "https://www.techiedelight.com/?problem=KthSmallestElement",
    "category": "Array",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/KthSmallestElement/KthSmallestElement.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find k'th smallest element in the array where k is a positive integer less than or equal to the length of array.\r\n\r\nInput : [7, 4, 6, 3, 9, 1], k = 3\r\nOutput: 4\r\nExplanation: The 3rd smallest array element is 4\r\n\r\nInput : [1, 5, 2, 2, 2, 5, 5, 4], k = 5\r\nOutput: 4\r\nExplanation: The 5th smallest array element is 4\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Kth Largest Element",
    "link": "https://www.techiedelight.com/?problem=KthLargestElement",
    "category": "Array, Heap",
    "tag": "Priority Queue",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/KthLargestElement/KthLargestElement.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find k'th largest element in the array where k is a positive integer less than or equal to the length of array.\r\n\r\nInput : [7, 4, 6, 3, 9, 1], k = 2\r\nOutput: 7\r\nExplanation: The 2nd largest array element is 7\r\n\r\nInput : [1, 5, 2, 2, 2, 5, 5, 4], k = 4\r\nOutput: 4\r\nExplanation: The 4th largest array element is 4\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Kth Largest Element II",
    "link": "https://www.techiedelight.com/?problem=KthLargestElementII",
    "category": "Heap",
    "tag": "Priority Queue",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/KthLargestElementII/KthLargestElementII.java",
    "problem": "/* START */\r\n/*\r\n\r\nGiven an infinite stream of integers, return the element representing the k'th largest element in the stream.\r\n\r\nInput: k = 3, nextInt = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]\r\nOutput : [-1, -1, 1, 2, 3, 4, 5, 6, 7, 8, ...]\r\n\r\nHere, `k` is constant for each run and `nextInt` is the next integer in the infinite stream. The solution should return the next k'th largest element, and return -1 when the stream has fewer elements than `k`.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Merge Sorted Lists",
    "link": "https://www.techiedelight.com/?problem=MergeSortedLists",
    "category": "Array, Heap, Sorting",
    "tag": "Priority Queue",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MergeSortedLists/MergeSortedLists.java",
    "problem": "/* START *//*\r\n\r\nGiven `M` sorted lists of variable length, merge them efficiently in sorted order.\r\n\r\nInput:\r\n\r\nmat = [\r\n\t[10, 20, 30, 40],\r\n\t[15, 25, 35],\r\n\t[27, 29, 37, 48, 93],\r\n\t[32, 33]\r\n]\r\n\r\nOutput: [10, 15, 20, 25, 27, 29, 30, 32, 33, 35, 37, 40, 48, 93]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Connect N Ropes",
    "link": "https://www.techiedelight.com/?problem=ConnectNRopes",
    "category": "Array, Heap",
    "tag": "Priority Queue",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ConnectNRopes/ConnectNRopes.java",
    "problem": "/* START *//*\r\n\r\nGiven n ropes of different lengths, connect them into a single rope with minimum cost. Assume that the cost to connect two ropes is the same as the sum of their lengths.\r\n\r\nInput: [5, 4, 2, 8]\r\nOutput: 36\r\nExplanation: The total cost for connecting all ropes is 6 + 11 + 19 = 36.\r\n\r\n[5, 4, 2, 8] \u00e2\u0080\u0093> First, connect ropes of lengths 4 and 2 that will cost 6.\r\n[5, 6, 8]    \u00e2\u0080\u0093> Next, connect ropes of lengths 5 and 6 that will cost 11.\r\n[11, 8]      \u00e2\u0080\u0093> Finally, connect the remaining two ropes that will cost 19.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Replace Elements with Rank",
    "link": "https://www.techiedelight.com/?problem=ReplaceElementsWithRank",
    "category": "Array, Heap",
    "tag": "Hashing, Priority Queue",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ReplaceElementsWithRank/ReplaceElementsWithRank.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of distinct integers, in-place replace each array element by its corresponding rank in the array. The minimum array element has the rank 1; the second minimum element has a rank of 2, and so on.\r\n\r\nInput : [10, 8, 15, 12, 6, 20, 1]\r\nOutput: [4, 3, 6, 5, 2, 7, 1]\r\n\r\nInput : [0, 1, -1]\r\nOutput: [2, 3, 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Common Subsequence",
    "link": "https://www.techiedelight.com/?problem=LongestCommonSubsequence",
    "category": "Dynamic Programming, String",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked, TopDP",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestCommonSubsequence/LongestCommonSubsequence.java",
    "problem": "/* START *//*\r\n\r\nGiven two sequences, find the length of the longest common subsequence (LCS) present in it. The LCS is the longest sequence which can be obtained from the first sequence by deleting some items and from the second sequence by deleting other items.\r\n\r\nInput: X = \"ABCBDAB\", Y = \"BDCABA\"\r\nOutput: 4\r\nExplanation: The LCS are \"BDAB\", \"BCAB\", and \"BCBA\", having length 4.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Common Subsequence II",
    "link": "https://www.techiedelight.com/?problem=LongestCommonSubsequenceII",
    "category": "Dynamic Programming, String",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LongestCommonSubsequenceII/LongestCommonSubsequenceII.java",
    "problem": "/* START *//*\r\n\r\nGiven two sequences, return the longest common subsequence (LCS) present in it. The LCS is the longest sequence which can be obtained from the first sequence by deleting some items and from the second sequence by deleting other items.\r\n\r\nInput: X = \"XMJYAUZ\", Y = \"MZJAWXU\"\r\nOutput: \"MJAU\"\r\n\r\nThe longest common subsequence is not guaranteed to be unique. If multiple longest common subsequence exists, the solution should return any one of them.\r\n\r\nInput: X = \"ABCBDAB\", Y = \"BDCABA\"\r\nOutput: \"BDAB\" or \"BCAB\" or \"BCBA\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Common Subsequence III",
    "link": "https://www.techiedelight.com/?problem=LongestCommonSubsequenceIII",
    "category": "Dynamic Programming, String",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestCommonSubsequenceIII/LongestCommonSubsequenceIII.java",
    "problem": "/* START *//*\r\n\r\nGiven three sequences, find the length of the longest common subsequence (LCS) present in it. The LCS is the longest subsequence that can be obtained from each of the given sequences by deleting zero or more characters.\r\n\r\nInput: X = \"ABCBDAB\", Y = \"BDCABA\", Z = \"BADACB\"\r\nOutput: 4\r\nExplanation: The longest subsequence present in the given sequences in the same order is \"BDAB\", having length 4.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Common Substring",
    "link": "https://www.techiedelight.com/?problem=LongestCommonSubstring",
    "category": "Dynamic Programming, String",
    "tag": "Algorithm, Bottom-up",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestCommonSubstring/LongestCommonSubstring.java",
    "problem": "/* START *//*\r\n\r\nGiven two strings, find the longest string that is a substring of both strings.\r\n\r\nInput: X = \"ABABC\", Y = \"BABCA\"\r\nOutput: \"BABC\"\r\nExplanation: The longest common substring of strings \"ABABC\" and \"BABCA\" is \"BABC\" having length 4. The other common substrings are \"ABC\", \"A\", \"AB\", \"B\", \"BA\", \"BC\", and \"C\".\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Palindromic Subsequence",
    "link": "https://www.techiedelight.com/?problem=LongestPalindromicSubsequence",
    "category": "Dynamic Programming, String",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestPalindromicSubsequence/LongestPalindromicSubsequence.java",
    "problem": "/* START *//*\r\n\r\nGiven a sequence, find the longest subsequences of it that is also a palindrome.\r\n\r\nInput: \"ABBDCACB\"\r\nOutput: 5\r\nExplanation: The longest palindromic subsequence is \"BCACB\", having length 5.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Repeated Subsequence",
    "link": "https://www.techiedelight.com/?problem=LongestRepeatedSubsequence",
    "category": "Dynamic Programming, String",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestRepeatedSubsequence/LongestRepeatedSubsequence.java",
    "problem": "/* START *//*\r\n\r\nGiven a sequence, find the length of the longest subsequence of it that occurs at least twice where the repeated characters should holds a different index in the sequence.\r\n\r\nInput: 'ATACTCGGA'\r\nOutput: 4\r\nExplanation: The longest repeating subsequence is 'ATCG', having length 4.\r\n\r\n'A' 'T'  A  'C'  T   C  'G'  G   A\r\n A   T  'A'  C  'T' 'C'  G  'G'  A\r\n\r\nInput: 'YBYXBXBB'\r\nOutput: 5\r\nExplanation: The longest repeating subsequence is 'YBXBB', having length 5.\r\n\r\n'Y' 'B'  Y  'X' 'B'  X  'B'  B\r\n Y   B  'Y'  X  'B' 'X' 'B' 'B'\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shortest Common Supersequence",
    "link": "https://www.techiedelight.com/?problem=ShortestCommonSupersequence",
    "category": "Dynamic Programming, String",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked, TopDP",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ShortestCommonSupersequence/ShortestCommonSupersequence.java",
    "problem": "/* START *//*\r\n\r\nGiven two sequences, find the length of the shortest supersequence 'Z' of given sequences 'X' and 'Y' such that both 'X' and 'Y' are subsequences of 'Z'.\r\n\r\nInput: X = \"ABCBDAB\", Y = \"BDCABA\"\r\nOutput: 9\r\nExplanation: The SCS are \"ABCBDCABA\", \"ABDCABDAB\", and \"ABDCBDABA\", having length 9.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shortest Common Supersequence II",
    "link": "https://www.techiedelight.com/?problem=ShortestCommonSupersequenceII",
    "category": "Dynamic Programming, String",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ShortestCommonSupersequenceII/ShortestCommonSupersequenceII.java",
    "problem": "/* START *//*\r\n\r\nGiven two sequences, find the length of the shortest supersequence 'Z' of given sequences 'X' and 'Y' such that both 'X' and 'Y' are subsequences of 'Z'.\r\n\r\nThe shortest common supersequence is not guaranteed to be unique. If multiple shortest common supersequence exists, the solution should return any one of them.\r\n\r\nInput: X = \"ABCBDAB\", Y = \"BDCABA\"\r\nOutput: \"ABCBDCABA\" or \"ABDCABDAB\" or \"ABDCBDABA\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Decreasing Subsequence",
    "link": "https://www.techiedelight.com/?problem=LongestDecreasingSubsequence",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LongestDecreasingSubsequence/LongestDecreasingSubsequence.java",
    "problem": "/* START *//*\r\n\r\nGiven a given sequence, find the length of the longest decreasing subsequence (LDS) in it.\r\n\r\nThe longest decreasing subsequence is a subsequence of a given sequence in which the subsequence's elements are in sorted order, highest to lowest, and in which the subsequence is as long as possible.\r\n\r\nInput : [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\r\nOutput: 6\r\nExplanation: The longest decreasing subsequence is [12, 10, 9, 5, 3] having length 5; the input sequence has no 6\u00e2\u0080\u0093member decreasing subsequences.\r\n\r\nThe longest decreasing subsequence is not necessarily unique. For instance, [12, 10, 6, 5, 3] is another decreasing subsequences of equal length in the same input sequence.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Bitonic Subsequence",
    "link": "https://www.techiedelight.com/?problem=LongestBitonicSubsequence",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestBitonicSubsequence/LongestBitonicSubsequence.java",
    "problem": "/* START *//*\r\n\r\nGiven a sequence, find the longest bitonic subsequence in which the subsequence's elements are first sorted in increasing order, then in decreasing order.\r\n\r\nInput: [4, 2, 5, 9, 7, 6, 10, 3, 1]\r\nOutput: 7\r\nExplanation: The longest bitonic subsequence is [4, 5, 9, 7, 6, 3, 1].\r\n\r\nFor sequences sorted in increasing or decreasing order, the output is the same as the input sequence, i.e.,\r\n\r\nInput: [1, 2, 3, 4, 5]\r\nOutput: 5\r\n\r\nInput: [5, 4, 3, 2, 1]\r\nOutput: 5\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Max Sum Increasing Subsequence",
    "link": "https://www.techiedelight.com/?problem=MaxSumIncreasingSubsequence",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaxSumIncreasingSubsequence/MaxSumIncreasingSubsequence.java",
    "problem": "/* START *//*\r\n\r\nGiven a sequence, find a subsequence of it such that the subsequence sum is as high as possible and the subsequence's elements are sorted in ascending order.\r\n\r\nInput: [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11]\r\nOutput: 34\r\nExplanation: The maximum sum increasing subsequence is [8, 12, 14] which has sum 34.\r\n\r\nInput: [-4, -3, -2, -1]\r\nOutput: 0\r\nExplanation: The maximum sum increasing subsequence is [] which has sum 0.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Edit Distance Problem",
    "link": "https://www.techiedelight.com/?problem=EditDistanceProblem",
    "category": "Dynamic Programming, String",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked, TopDP",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/EditDistanceProblem/EditDistanceProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven two words, find the minimum number of single-character edits required to transform one word into the other. An edit can be insertion, deletion, or substitution and each edit carries a unit cost.\r\n\r\nInput: X = \"kitten\", Y = \"sitting\"\r\nOutput: 3\r\nExplanation: A minimal edit script that transforms the 'kitten' into 'sitting' is:\r\n\r\nkitten \u00e2\u0080\u0094> sitten (substitution of 's' for 'k')\r\nsitten \u00e2\u0080\u0094> sittin (substitution of 'i' for 'e')\r\nsittin \u00e2\u0080\u0094> sitting (insertion of 'g' at the end)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximize Value",
    "link": "https://www.techiedelight.com/?problem=MaximizeValue",
    "category": "Array, Dynamic Programming",
    "tag": "Bottom-up",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MaximizeValue/MaximizeValue.java",
    "problem": "/* START *//*\r\n\r\nGiven an array `A`, maximize the value of expression `A[s] - A[r] + A[q] - A[p]`, where p, q, r, and s are indices of the array and s > r > q > p.\r\n\r\nInput: [3, 9, 10, 1, 30, 40]\r\nOutput: 46\r\nExplanation: The expression (40 - 1 + 10 - 3) results in maximum value.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "0/1 Knapsack Problem",
    "link": "https://www.techiedelight.com/?problem=01KnapsackProblem",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked, TopDP",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/01KnapsackProblem/01KnapsackProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. Note that the items are indivisible; we can either take an item or not (0-1 property).\r\n\r\nInput:\r\n\r\nvalue = [20, 5, 10, 40, 15, 25]\r\nweight = [1, 2, 3, 8, 7, 4]\r\nint W = 10\r\n\r\nOutput: 60\r\n\r\nExplanation: Knapsack value is 60\r\n\r\nvalue = 20 + 40 = 60\r\nweight = 1 + 8 = 9 <= W\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Partition Problem",
    "link": "https://www.techiedelight.com/?problem=PartitionProblem",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked, TopDP",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PartitionProblem/PartitionProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of positive integers, check if it can be divided into two subsets with equal sum.\r\n\r\nInput: S = [3, 1, 1, 2, 2, 1]\r\nOutput: true\r\nExplanation: S can be partitioned into two partitions, each having a sum of 5.\r\n\r\nS1 = [1, 1, 1, 2]\r\nS2 = [2, 3]\r\n\r\nNote that this solution is not unique. Here\u00e2\u0080\u0099s another solution.\r\n\r\nS1 = [3, 1, 1]\r\nS2 = [2, 2, 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Subset Sum Problem",
    "link": "https://www.techiedelight.com/?problem=SubsetSumProblem",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SubsetSumProblem/SubsetSumProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of positive integers and an integer `k`, check if there is any non-empty subset that sums to `k`.\r\n\r\nInput: nums = [7, 3, 2, 5, 8], k = 14\r\nOutput: true\r\nExplanation: Subset [7, 2, 5] sums to 14\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Sum Partition Problem",
    "link": "https://www.techiedelight.com/?problem=MinimumSumPartitionProblem",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumSumPartitionProblem/MinimumSumPartitionProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of positive integers S, partition it into two subsets, S1 and S2, such that the difference between the sum of elements in S1 and S2 is mininum. The solution should return the minimum absolute difference between the sum of elements of two partitions.\r\n\r\nInput: S = [10, 20, 15, 5, 25]\r\nOutput: 5\r\nExplanation: S can be partitioned into two partitions [[10, 20, 5], [15, 25]] where the minimum absolute difference between the sum of elements is 5. Note that this solution is not unique. Another solution is [[10, 25], [20, 15, 5]].\r\n\r\nInput: []\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Alternating Subsequence",
    "link": "https://www.techiedelight.com/?problem=LongestAlternatingSubsequence",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LongestAlternatingSubsequence/LongestAlternatingSubsequence.java",
    "problem": "/* START *//*\r\n\r\nThe longest alternating subsequence is a problem of finding a subsequence of a given sequence in which the elements are in alternating order and in which the sequence is as long as possible. In order words, we need to find the length of the longest subsequence with alternate low and high elements.\r\n\r\nInput: [8, 9, 6, 4, 5, 7, 3, 2, 4]\r\nOutput: 6\r\nExplanation: The longest alternating subsequence length is 6, and the subsequence is [8, 9, 6, 7, 3, 4] as (8 < 9 > 6 < 7 > 3 < 4).\r\n\r\nNote that the longest alternating subsequence is not unique. Following are a few more subsequences of length 6:\r\n\r\n(8, 9, 6, 7, 2, 4)\r\n(8, 9, 4, 7, 3, 4)\r\n(8, 9, 4, 7, 2, 4)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Linear Equation K Variables",
    "link": "https://www.techiedelight.com/?problem=LinearEquationKVariables",
    "category": "Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LinearEquationKVariables/LinearEquationKVariables.java",
    "problem": "/* START *//*\r\n\r\nGiven a linear equation of `k` variables, return the total number of possible solutions to it.\r\n\r\nInput: coeff = [1, 3, 5, 7], rhs = 8\r\nOutput: 6\r\nExplanation: The total number of solutions is 6. The input represents the equation a + 3b + 5c + 7d = 8.\r\n\r\n(a = 1, b = 0, c = 0, d = 1)\r\n(a = 0, b = 1, c = 1, d = 0)\r\n(a = 2, b = 2, c = 0, d = 0)\r\n(a = 3, b = 0, c = 1, d = 0)\r\n(a = 5, b = 1, c = 0, d = 0)\r\n(a = 8, b = 0, c = 0, d = 0)\r\n\r\n\r\nInput: coeff = [1, 2, 3], rhs = 4\r\nOutput: 4\r\nExplanation: The total number of solutions is 4. The input represents the equation x + 2y + 3z = 4.\r\n\r\n(x = 1, y = 0, z = 1)\r\n(x = 0, y = 2, z = 0)\r\n(x = 2, y = 1, z = 0)\r\n(x = 4, y = 0, z = 0)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Word Break Problem",
    "link": "https://www.techiedelight.com/?problem=WordBreakProblem",
    "category": "Dynamic Programming, String, Trie",
    "tag": "Algorithm, Recursive, Bottom-up, Top-down, Trie",
    "lists": "TopClassic, TopLiked, TopDP",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/WordBreakProblem/WordBreakProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a string and a dictionary of words, determine if the string can be segmented into a space-separated sequence of one or more dictionary words.\r\n\r\nInput:\r\n\r\ndict = [\"this\", \"th\", \"is\", \"famous\", \"Word\", \"break\", \"b\", \"r\", \"e\", \"a\", \"k\", \"br\", \"bre\", \"brea\", \"ak\", \"problem\"]\r\nword = \"Wordbreakproblem\"\r\n\r\nOutput: true\r\n\r\nExplanation: The string can be segmented. The segmented strings are:\r\n\r\nWord break problem\r\nWord brea k problem\r\nWord bre ak problem\r\nWord bre a k problem\r\nWord br e ak problem\r\nWord br e a k problem\r\nWord b r e ak problem\r\nWord b r e a k problem\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Weighted Interval Scheduling",
    "link": "https://www.techiedelight.com/?problem=WeightedIntervalScheduling",
    "category": "Array, Dynamic Programming, Sorting",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/WeightedIntervalScheduling/WeightedIntervalScheduling.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of jobs where each job has a start and finish time, and a profit associated with it, find a maximum profit subset of non-overlapping jobs.\r\n\r\nInput: jobs = [(0, 6, 60), (5, 9, 50), (1, 4, 30), (5, 7, 30), (3, 5, 10), (7, 8, 10)]\t\t// (starting time, finishing time, associated profit)\r\nOutput: 80\r\nExplanation: The jobs involved in the maximum profit are: (1, 4, 30) and (5, 9, 50).\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Matrix Chain Multiplication",
    "link": "https://www.techiedelight.com/?problem=MatrixChainMultiplication",
    "category": "Array, Dynamic Programming, Matrix",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic, TopLiked, TopDP",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MatrixChainMultiplication/MatrixChainMultiplication.java",
    "problem": "/* START *//*\r\n\r\nMatrix chain multiplication is an optimization problem that to find the most efficient way to multiply a given sequence of matrices. The problem is not actually to perform the multiplications but merely to decide the sequence of the matrix multiplications involved.\r\n\r\nYou're given an array `dims` of `n` positive integers, where matrix `M[i]` has dimension `dims[i-1] \u00c3\u0097 dims[i]` for `i=1\u00e2\u0080\u00a6n`. Determine the optimal parenthesization of the product of matrices `M[1\u00e2\u0080\u00a6n]`.\r\n\r\nInput: [10, 30, 5, 60]\r\nOutput: 4500\r\nExplanation: Here A is a 10 \u00c3\u0097 30 matrix, B is a 30 \u00c3\u0097 5 matrix, and C is a 5 \u00c3\u0097 60 matrix. Computing (AB)C needs (10\u00c3\u009730\u00c3\u00975) + (10\u00c3\u00975\u00c3\u009760) = 1500 + 3000 = 4500 operations.\r\n\r\nNote that the order in which the product is parenthesized affects the number of simple arithmetic operations needed to compute the product. For example, computing A(BC) needs (30\u00c3\u00975\u00c3\u009760) + (10\u00c3\u009730\u00c3\u009760) = 9000 + 18000 = 27000 operations. The former ordering is more efficient.\r\n\r\nThe matrix multiplication is associative as no matter how the product is parenthesized, the result obtained will remain the same. For example, for four matrices A, B, C, and D, we would have:\r\n\r\n((AB)C)D = ((A(BC))D) = (AB)(CD) = A((BC)D) = A(B(CD))\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Climbing Stairs",
    "link": "https://www.techiedelight.com/?problem=ClimbingStairs",
    "category": "Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ClimbingStairs/ClimbingStairs.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n, find the total number of ways to reach the n'th stair from the bottom of a stair when a person can only climb either 1 or 2 or 3 stairs at a time.\r\n\r\nInput: 3\r\nOutput: 4\r\nExplanation: Total ways to reach the 3rd stair are 4\r\n\r\n1 step + 1 step + 1 step\r\n1 step + 2 steps\r\n2 steps + 1 step\r\n3 steps\r\n\r\n\r\nInput: 4\r\nOutput: 7\r\nExplanation: Total ways to reach the 4'th stair are 7\r\n\r\n1 step + 1 step + 1 step + 1 steps\r\n1 step + 1 step + 2 steps\r\n1 step + 2 steps + 1 step\r\n1 step + 3 steps\r\n2 steps + 1 step + 1 step\r\n2 steps + 2 steps\r\n3 steps + 1 step\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Climbing Stairs II",
    "link": "https://www.techiedelight.com/?problem=ClimbingStairsII",
    "category": "Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ClimbingStairsII/ClimbingStairsII.java",
    "problem": "/* START *//*\r\n\r\nGiven two positive numbers n and m, find the total number of ways to reach the n'th stair from the bottom of a stair when a person is only allowed to take at-most m steps at a time.\r\n\r\nInput: n = 3, m = 2\r\nOutput: 3\r\nExplanation: Total ways to reach the 3rd stair with at most 2 steps are 3\r\n\r\n1 step + 1 step + 1 step\r\n1 step + 2 steps\r\n2 steps + 1 step\r\n\r\n\r\nInput: n = 4, m = 3\r\nOutput: 7\r\nExplanation: Total ways to reach the 4th stair with at most 3 steps are 7\r\n\r\n1 step + 1 step + 1 step + 1 steps\r\n1 step + 1 step + 2 steps\r\n1 step + 2 steps + 1 step\r\n1 step + 3 steps\r\n2 steps + 1 step + 1 step\r\n2 steps + 2 steps\r\n3 steps + 1 step\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Pots of Gold Game",
    "link": "https://www.techiedelight.com/?problem=PotsOfGoldGame",
    "category": "Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/PotsOfGoldGame/PotsOfGoldGame.java",
    "problem": "/* START *//*\r\n\r\nIn pots of gold game, there are two players, A and B, and pots of gold arranged in a line, each containing some gold coins. The players can see how many coins are there in each gold pot, and each player gets alternating turns in which the player can pick a pot from either end of the line. The winner is the player who has a higher number of coins at the end. The objective is to \"maximize\" the number of coins collected by A, assuming B also plays \"optimally\", and A starts the game.\r\n\r\nInput: coins[] = [4, 6, 2, 3]\r\nOutput: 9\r\nExplanation: The optimal way is shown below:\r\n\r\n                    Player A  |  Player B\r\n\t\t\t\t\t\t\t  |\r\n4, 6, 2, 3              3     |\r\n4, 6, 2                       |     4\r\n6, 2                    6     |\r\n2                             |     2\r\n                     9 coins  |  6 coins\r\n\r\n\r\nInput: coins[] = [6, 1, 4, 9, 8, 5]\r\nOutput: 18\r\nExplanation: The optimal way is shown below:\r\n\r\n                     Player A  |  Player B\r\n\t\t\t\t\t\t\t   |\r\n6, 1, 4, 9, 8, 5        6      |\r\n1, 4, 9, 8, 5                  |     5\r\n1, 4, 9, 8              8      |\r\n1, 4, 9                        |     9\r\n1, 4                    4      |\r\n1                              |     1\r\n                     18 coins  |  15 coins\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Jumps",
    "link": "https://www.techiedelight.com/?problem=MinimumJumps",
    "category": "Array, Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumJumps/MinimumJumps.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of non-negative integers, where each array element represents the maximum number of positions one can move forward from that element. Find the minimum number of jumps required to reach end of the array from start of the array.\r\n\r\nInput: [4, 2, 0, 3, 2, 0, 1, 8]\r\nOutput: 3\r\nExplanation: The minimum jumps required to reach the destination are 3.\r\n\r\n3 jumps: (4 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 8) or (4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 8)\r\n4 jumps: (4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 8) or (4 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 8)\r\n5 jumps: (4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 8)\r\n\r\nNote that if any element has value 0 in the array, the destination cannot be reached through that element. The solution should return -1 as the destination cannot be reached.\r\n\r\nInput: [4, 2, 2, 1, 0, 8, 1]\r\nOutput: -1\r\nExplanation: The minimum jumps required to reach the destination are infinity. This is because no matter what path we choose, it will always end up in a dead cell.\r\n\r\n4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 0\r\n4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 0\r\n4 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 0\r\n4 \u00e2\u0080\u0094> 0\r\n\r\nInput: [0, 2, 2, 1, 8, 1]\r\nOutput: -1\r\nExplanation: The destination cannot be reached at all since the source itself has value 0.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Sum Subsequence",
    "link": "https://www.techiedelight.com/?problem=MaximumSumSubsequence",
    "category": "Array, Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumSumSubsequence/MaximumSumSubsequence.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, find the maximum sum of subsequence where the subsequence contains no element at adjacent positions.\r\n\r\nInput: [1, 2, 9, 4, 5, 0, 4, 11, 6]\r\nOutput: 26\r\nExplanation: The maximum sum is 26 and formed by the subsequence [1, 9, 5, 11].\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Nth Fibonacci Number",
    "link": "https://www.techiedelight.com/?problem=NthFibonacciNumber",
    "category": "Basic, Dynamic Programming",
    "tag": "Recursive, Top-down, Bottom-up",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/NthFibonacciNumber/NthFibonacciNumber.java",
    "problem": "/* START *//*\r\n\r\nGiven a non-negative number n, calculate the Fibonacci number F(n). Fibonacci's sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones. For example,\r\n\r\nThe Fibonacci's sequence is [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u00e2\u0080\u00a6 ]\r\n\r\nInput: n = 0\r\nOutput: 0\r\nExplanation: F(0) = 0\r\n\r\nInput: n = 1\r\nOutput: 1\r\nExplanation: F(1) = 1\r\n\r\nInput: n = 8\r\nOutput: 21\r\nExplanation: F(8) = 21\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Count Decodings",
    "link": "https://www.techiedelight.com/?problem=CountDecodings",
    "category": "Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CountDecodings/CountDecodings.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n, map its digits to the corresponding alphabet in the mapping table [(1, 'A'), (2, 'B'), (3, 'C'), \u00e2\u0080\u00a6 (26, 'Z')], and return the count of the total number of decodings possible. Assume that the input number can be split into valid single-digit or two-digit numbers that are present in the mapping table.\r\n\r\nInput: n = 123\r\nOutput: 3\r\nExplanation: The possible decodings are [ABC, AW, LC]\r\n\r\nInput: n = 1221\r\nOutput: 5\r\nExplanation: The possible decodings are [ABBA, ABU, AVA, LBA, LU]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Hat Check Problem",
    "link": "https://www.techiedelight.com/?problem=HatCheckProblem",
    "category": "Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "TopClassic",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/HatCheckProblem/HatCheckProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number `n`, find the total number of ways in which `n` hats can be returned to `n` people such that no hat makes it back to its owner.\r\n\r\nInput: n = 2\r\nOutput: 1\r\nExplanation: You're given a 2\u00e2\u0080\u0093hat set, say [h1, h2]. There is only one derangement [h2, h1].\r\n\r\nInput: n = 3\r\nOutput: 2\r\nExplanation: You're given a 3\u00e2\u0080\u0093hat set, say [h1, h2, h3]. The derangements are [h3, h1, h2] and [h2, h3, h1].\r\n\r\nInput: n = 4\r\nOutput: 9\r\nExplanation: You're given a 4\u00e2\u0080\u0093hat set, say [h1, h2, h3, h4]. The derangements are\r\n\r\n[h2, h1, h4, h3]\r\n[h2, h3, h4, h1]\r\n[h2, h4, h1, h3]\r\n[h3, h4, h1, h2]\r\n[h3, h1, h4, h2]\r\n[h3, h4, h2, h1]\r\n[h4, h1, h2, h3]\r\n[h4, h3, h1, h2]\r\n[h4, h3, h2, h1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Squares",
    "link": "https://www.techiedelight.com/?problem=MinimumSquares",
    "category": "Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumSquares/MinimumSquares.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive integer n, find the minimum number of squares that sums to n.\r\n\r\nInput: 100\r\nOutput: 1\r\nExplanation: 100 is a perfect square. It can be represented as 10^2.\r\n\r\nInput: 10\r\nOutput: 2\r\nExplanation: 10 can be represented as 3^2 + 1^2.\r\n\r\nInput: 63\r\nOutput: 4\r\nExplanation: 63 can be represented as 7^2 + 3^2 + 2^2 + 1^2.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Truncate Array",
    "link": "https://www.techiedelight.com/?problem=TruncateArray",
    "category": "Array, Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/TruncateArray/TruncateArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of positive integers, truncate it such that `2\u00c3\u0097min` becomes more than `max`, and the total number of removals is minimal. The `min` and `max` are the minimum and the maximum elements in the array, respectively. The elements can be removed either from the start or end of the array if the above condition does not meet.\r\n\r\nInput: [4, 6, 1, 7, 5, 9, 2]\r\nOutput: 4\r\nExplanation: The minimum number of removals is 4. The truncated array is [7, 5, 9] where 9 < 2 \u00c3\u0097 5.\r\n\r\nInput: [4, 2, 6, 4, 9]\r\nOutput: 3\r\nExplanation: The minimum number of removals is 3. The truncated array is [6, 4] where 6 < 2 \u00c3\u0097 4.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Dice Throw",
    "link": "https://www.techiedelight.com/?problem=DiceThrow",
    "category": "Dynamic Programming",
    "tag": "Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DiceThrow/DiceThrow.java",
    "problem": "/* START *//*\r\n\r\nGiven two positive numbers n, k and a target, calculate the total number of ways to reach `target` with `n` throws of dice having `k` faces.\r\n\r\nInput:\r\n\r\nn = 2\t\t\t(total number of throws)\r\nk = 6 \t\t\t(each dice has values from 1 to 6)\r\ntarget = 10\t\t(desired sum)\r\n\r\nOutput: 3\r\n\r\nExplanation: The total number of ways is 3. The possible throws are (6, 4), (4, 6), (5, 5)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Weight Triangulation",
    "link": "https://www.techiedelight.com/?problem=MinimumWeightTriangulation",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumWeightTriangulation/MinimumWeightTriangulation.java",
    "problem": "/* START *//*\r\n\r\nA triangulation of a convex polygon results in a set of non-intersecting diagonals between non-adjacent vertices, which completely partition the interior of the convex hull of the polygon into triangles. The minimum-weight triangulation (MWT) is the triangulation having the minimum total edge length among all possible triangulation.\r\n\r\nInput: [(0, 0), (2, 0), (2, 1), (1, 2), (0, 1)]\r\nOutput: 15.30056307974577\r\n\r\nExplanation: The following are the two triangulations of the same convex pentagon. The triangulation on the left has a cost of 8 + 2\u00e2\u0088\u009a2 + 2\u00e2\u0088\u009a5 (approximately 15.30), the one on the right has a cost of 4 + 2\u00e2\u0088\u009a2 + 4\u00e2\u0088\u009a5 (approximately 15.77).\r\n\r\nhttps://techiedelight.com/practice/images/Minimum-Weight-Triangulation.png\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Longest Alternating Subarray",
    "link": "https://www.techiedelight.com/?problem=LongestAlternatingSubarray",
    "category": "Array, Dynamic Programming",
    "tag": "Algorithm, Bottom-up",
    "lists": "TopClassic",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/LongestAlternatingSubarray/LongestAlternatingSubarray.java",
    "problem": "/* START *//*\r\n\r\nGiven an array containing positive and negative elements, find a subarray with alternating positive and negative elements, and in which the subarray is as long as possible.\r\n\r\nInput : [1, -2, 6, 4, -3, 2, -4, -3]\r\nOutput: [4, -3, 2, -4]\r\n\r\nNote that the longest alternating subarray might not be unique. In case the multiple alternating subarrays of maximum length exists, the solution can return any one of them.\r\n\r\nInput : [1, -2, 6, 2, 4, -3, 2, 4, -3]\r\nOutput: [1, -2, 6] or [4, -3, 2]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Implement Power Function",
    "link": "https://www.techiedelight.com/?problem=ImplementPowerFunction",
    "category": "Bit Manipulation, Divide & Conquer",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ImplementPowerFunction/ImplementPowerFunction.java",
    "problem": "/* START *//*\r\n\r\nGiven two integers, `x` and `n`, where `n` is non-negative, efficiently compute the power function `pow(x, n)`.\r\n\r\nInput: x = -2, n = 10\r\nOutput: 1024\r\nExplanation: pow(-2, 10) = 1024\r\n\r\nInput: x = -3, n = 4\r\nOutput: 81\r\nExplanation: pow(-3, 4) = 81\r\n\r\nInput: x = 5, n = 0\r\nOutput: 1\r\nExplanation: pow(5, 0) = 1\r\n\r\nInput: x = -2, n = 3\r\nOutput: -8\r\nExplanation: pow(-2, 3) = -8\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Implement Square Root",
    "link": "https://www.techiedelight.com/?problem=ImplementSquareRoot",
    "category": "Divide & Conquer",
    "tag": "Binary Search",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ImplementSquareRoot/ImplementSquareRoot.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number, return the square root of it. If the number is not a perfect square, return the floor of its square root.\r\n\r\nInput : x = 12\r\nOutput: 3\r\n\r\nInput : x = 16\r\nOutput: 4\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Linked List",
    "link": "https://www.techiedelight.com/?problem=ConstructLinkedList",
    "category": "Linked List",
    "tag": "",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructLinkedList/ConstructLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of integers, implement a linked list out of the array keys. The solution should create a new node for every key and insert it onto the list's front.\r\n\r\nInput : [1, 2, 3, 4, 5]\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Linked List II",
    "link": "https://www.techiedelight.com/?problem=ConstructLinkedListII",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructLinkedListII/ConstructLinkedListII.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of integers, construct a linked list out of the array keys. The solution should create a new node for every key and efficiently insert it onto the list's tail.\r\n\r\nInput : [1, 2, 3, 4, 5]\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Pop Linked List Head",
    "link": "https://www.techiedelight.com/?problem=PopLinkedListHead",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/PopLinkedListHead/PopLinkedListHead.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, delete its head node, and advance the head pointer to point at the next node in line.\r\n\r\nInput : 1 -> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\nOutput: 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\n\r\nInput : 1 \u00e2\u0080\u0094> null\r\nOutput: null\r\n\r\nInput : null\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sorted Insert in Linked List",
    "link": "https://www.techiedelight.com/?problem=SortedInsertInLinkedList",
    "category": "Linked List",
    "tag": "",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SortedInsertInLinkedList/SortedInsertInLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted list in increasing order and a single node, insert the node into its correct sorted position in the list.\r\n\r\nInput: List = 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null, Node = 9\r\nOutput: 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null\r\n\r\nInput: List = 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null, Node = 1\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null\r\n\r\nInput: List = 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null, Node = 5\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Kth Node from End",
    "link": "https://www.techiedelight.com/?problem=KthNodeFromEnd",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/KthNodeFromEnd/KthNodeFromEnd.java",
    "problem": "/* START *//*\r\n\r\nGiven a non-empty linked list and a positive integer k, return the value of k'th node from the end of the list.\r\n\r\nInput: List = 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null, k = 3\r\nOutput: 3\r\n\r\nAssume that k is less than or equal to number of nodes in the linked list.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Delete Nodes Linked List",
    "link": "https://www.techiedelight.com/?problem=DeleteNodesLinkedList",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/DeleteNodesLinkedList/DeleteNodesLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers and two positive numbers, m and n, delete every n nodes after skipping m nodes.\r\n\r\nInput: List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null, m = 1, n = 3\r\nOutput: 1 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null\r\n\r\nInput: List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null, m = 2, n = 2\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\n\r\nInput: List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null, m = 4, n = 6\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\n\r\nInput: List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null, m = 4, n = 2\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Remove Redundant Nodes",
    "link": "https://www.techiedelight.com/?problem=RemoveRedundantNodes",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RemoveRedundantNodes/RemoveRedundantNodes.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list that stores a path formed by cells of a matrix, remove the redundant nodes in that path. The path can be both vertical and horizontal, but never diagonal. To determine the complete path, you need the endpoints of all vertical and horizontal paths; middle nodes don't provide any value and are therefore redundant. So, the resultant list should contain coordinates of only endpoints of all vertical and horizontal paths.\r\n\r\nInput : (0, 1) \u00e2\u0086\u0092 (0, 5) \u00e2\u0086\u0092 (0, 8)\r\n\t\t\t\t\t\t\t\u00e2\u0086\u0093\r\n\t\t\t\t\t\t  (2, 8)\r\n\t\t\t\t\t\t\t\u00e2\u0086\u0093\r\n\t\t\t\t\t\t  (5, 8)\r\n\t\t\t\t\t\t\t\u00e2\u0086\u0093\r\n\t\t\t\t\t\t  (7, 8) \u00e2\u0086\u0092 (7, 10) \u00e2\u0086\u0092 (7, 12) \u00e2\u0086\u0092 null\r\n\r\nOutput: (0, 1) \u00e2\u0086\u0092 (0, 8)\r\n\t\t\t\t   \u00e2\u0086\u0093\r\n\t\t\t\t (7, 8) \u00e2\u0086\u0092 (7, 12) \u00e2\u0086\u0092 null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Add Number to Linked List",
    "link": "https://www.techiedelight.com/?problem=AddNumberToLinkedList",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/AddNumberToLinkedList/AddNumberToLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a single-digit number k and a singly-linked list whose nodes stores digits of a non-negative number, add k to the linked list.\r\n\r\nInput: List = 9 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null, k = 7\r\nOutput: 1 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> null\r\nExplanation: The input linked list represents the number 9993. Adding a single-digit number 7 results in linked list corresponding to the number 10000.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Add Two Linked Lists",
    "link": "https://www.techiedelight.com/?problem=AddTwoLinkedLists",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/AddTwoLinkedLists/AddTwoLinkedLists.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list representation of two positive numbers, calculate and store their sum in a new list using constant space.\r\n\r\nInput: X = 5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null, Y = 9 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\nOutput: 6 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> null\r\nExplanation: 5734 + 946 = 6680\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sort Linked List",
    "link": "https://www.techiedelight.com/?problem=SortLinkedList",
    "category": "Divide & Conquer, Linked List, Sorting",
    "tag": "Algorithm, Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortLinkedList/SortLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, rearrange its nodes to be sorted in increasing order.\r\n\r\nInput : 6 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null\r\nOutput: 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null\r\n\r\nInput : 9 \u00e2\u0080\u0094> -3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> -2 \u00e2\u0080\u0094> -8 \u00e2\u0080\u0094> -6 \u00e2\u0080\u0094> null\r\nOutput: -8 \u00e2\u0080\u0094> -6 \u00e2\u0080\u0094> -3 \u00e2\u0080\u0094> -2 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Dutch National Flag Problem II",
    "link": "https://www.techiedelight.com/?problem=DutchNationalFlagProblemII",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DutchNationalFlagProblemII/DutchNationalFlagProblemII.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list containing 0\u00e2\u0080\u0099s, 1\u00e2\u0080\u0099s, and 2\u00e2\u0080\u0099s, sort the linked list by doing a single traversal of it.\r\n\r\nInput : 0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> null\r\nOutput: 0 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sort Doubly Linked List",
    "link": "https://www.techiedelight.com/?problem=SortDoublyLinkedList",
    "category": "Divide & Conquer, Linked List, Sorting",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortDoublyLinkedList/SortDoublyLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a doubly-linked list of integers, rearrange its nodes to be sorted in increasing order.\r\n\r\nInput : 6 \u00e2\u0087\u0094 3 \u00e2\u0087\u0094 4 \u00e2\u0087\u0094 8 \u00e2\u0087\u0094 2 \u00e2\u0087\u0094 9 \u00e2\u0087\u0094 null\r\nOutput: 2 \u00e2\u0087\u0094 3 \u00e2\u0087\u0094 4 \u00e2\u0087\u0094 6 \u00e2\u0087\u0094 8 \u00e2\u0087\u0094 9 \u00e2\u0087\u0094 null\r\n\r\nInput : 9 \u00e2\u0087\u0094 -3 \u00e2\u0087\u0094 5 \u00e2\u0087\u0094 -2 \u00e2\u0087\u0094 -8 \u00e2\u0087\u0094 -6 \u00e2\u0087\u0094 null\r\nOutput: -8 \u00e2\u0087\u0094 -6 \u00e2\u0087\u0094 -3 \u00e2\u0087\u0094 -2 \u00e2\u0087\u0094 5 \u00e2\u0087\u0094 9 \u00e2\u0087\u0094 null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Swap Nodes Linked List",
    "link": "https://www.techiedelight.com/?problem=SwapNodesLinkedList",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SwapNodesLinkedList/SwapNodesLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, pairwise swap its adjacent nodes. The swapping of data is not allowed, only links should be changed.\r\n\r\nInput : 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null\r\nOutput: 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Swap Nodes Linked List II",
    "link": "https://www.techiedelight.com/?problem=SwapNodesLinkedListII",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SwapNodesLinkedListII/SwapNodesLinkedListII.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers and a positive number k, swap the k'th node from the beginning with the k'th node from the end. The swapping should be done so that only links between the nodes are exchanged, and no data is swapped.\r\n\r\nInput:\r\n\r\nLinked List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null\r\nk = 2\r\n\r\nOutput: 1 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null\r\n\r\n\r\nInput:\r\n\r\nLinked List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> null\r\nk = 2\r\n\r\nOutput: 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> null\r\n\r\n\r\nAssume that k is less than or equal to the length of linked list.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Detect Cycle Linked List",
    "link": "https://www.techiedelight.com/?problem=DetectCycleLinkedList",
    "category": "Linked List",
    "tag": "Algorithm, Hashing",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/DetectCycleLinkedList/DetectCycleLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, which may contain a cycle, detect and report the cycle if present.\r\n\r\nInput: 1 \u00e2\u0086\u0092 2 \u00e2\u0086\u0092 3 \u00e2\u0086\u0092 4 \u00e2\u0094\u0080\u00e2\u0094\u0090\r\n\t\t   \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0098\r\nOutput: true\r\n\r\nInput: 1 \u00e2\u0086\u0092 2 \u00e2\u0086\u0092 3 \u00e2\u0086\u0092 4 \u00e2\u0086\u0092 null\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Remove Cycle Linked List",
    "link": "https://www.techiedelight.com/?problem=RemoveCycleLinkedList",
    "category": "Linked List",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RemoveCycleLinkedList/RemoveCycleLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, which may contain a cycle, remove the cycle if present.\r\n\r\nInput: 1 \u00e2\u0086\u0092 2 \u00e2\u0086\u0092 3 \u00e2\u0086\u0092 4 \u00e2\u0094\u0080\u00e2\u0094\u0090\r\n\t\t   \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0098\r\nOutput: 1 \u00e2\u0086\u0092 2 \u00e2\u0086\u0092 3 \u00e2\u0086\u0092 4 \u00e2\u0086\u0092 null\r\n\r\n\r\nInput : 1 \u00e2\u0086\u0092 2 \u00e2\u0086\u0092 3 \u00e2\u0086\u0092 4 \u00e2\u0086\u0092 null\r\nOutput: 1 \u00e2\u0086\u0092 2 \u00e2\u0086\u0092 3 \u00e2\u0086\u0092 4 \u00e2\u0086\u0092 null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Split Linked List",
    "link": "https://www.techiedelight.com/?problem=SplitLinkedList",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SplitLinkedList/SplitLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, split it into two sublists \u00e2\u0080\u0093 one for the front half and one for the back half. The solution should return a list containing the front half and the back half.\r\n\r\nInput: 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\nOutput: [[2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null], [5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null]]\r\n\r\nIf the total number of elements in the list is odd, the extra element should go in the front list.\r\n\r\nInput: 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null\r\nOutput: [[2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null], [7 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null]]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Split Linked List II",
    "link": "https://www.techiedelight.com/?problem=SplitLinkedListII",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SplitLinkedListII/SplitLinkedListII.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, split it into two lists containing alternating elements from the original list.\r\n\r\nInput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\nOutput: [[1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null], [2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null]]\r\n\r\nInput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\nOutput: [[1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null], [2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null]]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Remove Duplicates Linked List",
    "link": "https://www.techiedelight.com/?problem=RemoveDuplicatesLinkedList",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RemoveDuplicatesLinkedList/RemoveDuplicatesLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers sorted in increasing order, remove duplicates from it by traversing the list only once.\r\n\r\nInput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Remove Duplicates Linked List II",
    "link": "https://www.techiedelight.com/?problem=RemoveDuplicatesLinkedListII",
    "category": "Linked List",
    "tag": "Hashing",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RemoveDuplicatesLinkedListII/RemoveDuplicatesLinkedListII.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted linked list of integers, remove duplicate nodes from it by traversing the list only once. The solution should preserve the order of elements appearing in the list.\r\n\r\nInput: 5 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null\r\nOutput: 5 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Clone Linked List",
    "link": "https://www.techiedelight.com/?problem=CloneLinkedList",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CloneLinkedList/CloneLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly linked list of integers, return a complete copy of it. The solution should return a new linked list which is identical to the given list in terms of its structure and contents, and it should not use any nodes of the list.\r\n\r\nInput : 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Clone Linked List II",
    "link": "https://www.techiedelight.com/?problem=CloneLinkedListII",
    "category": "Linked List",
    "tag": "Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/CloneLinkedListII/CloneLinkedListII.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers with each node containing an additional random pointer, efficiently clone it. The random pointer can point to any random node of the linked list or null.\r\n\r\nThe solution should return a new linked list which is identical to the given list in terms of its structure and contents, and it should not use any nodes of the list.\r\n\r\n\t\t\t  \u00e2\u0094\u008c\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\r\n\t\t\t  \u00e2\u00ae\u009f\t\t\u00e2\u0094\u0082\r\nInput : 1 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 2 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 3 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 4 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 5 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e null\t\t// Original linked list\r\n\t\t\u00e2\u0094\u0082\t\t\t\t   \u00e2\u00ae\u009d\r\n\t\t\u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0098\r\n\r\n\t\t\t  \u00e2\u0094\u008c\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\r\n\t\t\t  \u00e2\u00ae\u009f\t\t\u00e2\u0094\u0082\r\nOutput: 1 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 2 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 3 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 4 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 5 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e null\t\t// Cloned linked list\r\n\t\t\u00e2\u0094\u0082\t\t\t\t   \u00e2\u00ae\u009d\r\n\t\t\u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0098\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Move Node Linked List",
    "link": "https://www.techiedelight.com/?problem=MoveNodeLinkedList",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MoveNodeLinkedList/MoveNodeLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven two singly-linked lists of integers, move front node of the second list in front of the first list. The solution should return a list containing the first list and the second list.\r\n\r\nInput:\r\n\r\nX: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null\r\nY: 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\n\r\nOutput: [4 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null, 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Move Node Linked List II",
    "link": "https://www.techiedelight.com/?problem=MoveNodeLinkedListII",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MoveNodeLinkedListII/MoveNodeLinkedListII.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, move its last node to the front.\r\n\r\nInput : 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\nOutput: 4 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sorted Intersect",
    "link": "https://www.techiedelight.com/?problem=SortedIntersect",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortedIntersect/SortedIntersect.java",
    "problem": "/* START *//*\r\n\r\nGiven two sorted singly-linked lists of integers, return a new list representing their intersection.\r\n\r\nInput:\r\n\r\nX: 1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\nY: 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\n\r\nOutput: 4 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shuffle Merge",
    "link": "https://www.techiedelight.com/?problem=ShuffleMerge",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ShuffleMerge/ShuffleMerge.java",
    "problem": "/* START *//*\r\n\r\nGiven two singly-linked lists of integers, merge their nodes to make one list, taking nodes alternately between the two lists.\r\n\r\nInput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null, 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\n\r\nIf either list runs out, all the nodes should be taken from the other list.\r\n\r\nInput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> null, 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\n\r\nInput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null, 4 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shuffle Merge II",
    "link": "https://www.techiedelight.com/?problem=ShuffleMergeII",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ShuffleMergeII/ShuffleMergeII.java",
    "problem": "/* START *//*\r\n\r\nGiven two singly-linked lists of integers, merge their nodes into the first list by taking nodes alternately between the two lists. If the first list runs out, the remaining nodes of the second list should not be moved. The solution should return a list containing the first list and the second list.\r\n\r\nInput:\r\n\r\nX: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> null\r\nY: 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null\r\n\r\nOutput: [1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null, 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Linked List",
    "link": "https://www.techiedelight.com/?problem=ReverseLinkedList",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseLinkedList/ReverseLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, reverse it and return the reversed list. The swapping of data is not allowed, only links should be changed.\r\n\r\nInput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\nOutput: 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Linked List II",
    "link": "https://www.techiedelight.com/?problem=ReverseLinkedListII",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseLinkedListII/ReverseLinkedListII.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list and a positive number k, reverse every adjacent group of k nodes. The swapping of data is not allowed, only links should be changed.\r\n\r\nInput:\r\n\r\nLinked List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null\r\nk = 3\r\n\r\nOutput: 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\n\r\n\r\nInput:\r\n\r\nLinked List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null\r\nk = 2\r\n\r\nOutput: 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\n\r\n\r\nInput:\r\n\r\nLinked List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> null\r\nk >= 8\r\n\r\nOutput: 8 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Linked List III",
    "link": "https://www.techiedelight.com/?problem=ReverseLinkedListIII",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseLinkedListIII/ReverseLinkedListIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list and a positive number k, reverse every alternate group of k nodes. The swapping of data is not allowed, only links should be changed.\r\n\r\n\r\nInput:\r\n\r\nLinked List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\nk = 2\r\n\r\nOutput: 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null\r\n\r\n\r\nInput:\r\n\r\nLinked List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\nk = 3\r\n\r\nOutput: 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\n\r\n\r\nInput:\r\n\r\nLinked List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\nk >= 10\r\n\r\nOutput: 10 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Linked List IV",
    "link": "https://www.techiedelight.com/?problem=ReverseLinkedListIV",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseLinkedListIV/ReverseLinkedListIV.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list and two positive numbers m and n where m <= n, reverse the portion of list from position m to n. The swapping of data is not allowed, only links should be changed.\r\n\r\nInput:\r\n\r\nLinked List: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\n\r\nm = 2 (start position)\r\nn = 5 (end position)\r\n\r\nOutput: 1 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Doubly Linked List",
    "link": "https://www.techiedelight.com/?problem=ReverseDoublyLinkedList",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseDoublyLinkedList/ReverseDoublyLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a doubly-linked list of integers, reverse it and return the reversed list. The swapping of data is not allowed, only links should be changed.\r\n\r\nInput : 1 \u00e2\u0087\u0094 2 \u00e2\u0087\u0094 3 \u00e2\u0087\u0094 4 \u00e2\u0087\u0094 5 \u00e2\u0087\u0094 null\r\nOutput: 5 \u00e2\u0087\u0094 4 \u00e2\u0087\u0094 3 \u00e2\u0087\u0094 2 \u00e2\u0087\u0094 1 \u00e2\u0087\u0094 null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Linked List",
    "link": "https://www.techiedelight.com/?problem=RearrangeLinkedList",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeLinkedList/RearrangeLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, move every even node to the end of the list in reverse order.\r\n\r\nInput : 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Linked List II",
    "link": "https://www.techiedelight.com/?problem=RearrangeLinkedListII",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeLinkedListII/RearrangeLinkedListII.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, rearrange its nodes such that alternate positions are filled with nodes starting from the beginning and end of the list.\r\n\r\nInput : 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\n\r\nInput : 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Linked List III",
    "link": "https://www.techiedelight.com/?problem=RearrangeLinkedListIII",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeLinkedListIII/RearrangeLinkedListIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, split it into two lists where each list contains alternating elements from the list. The solution should join the two lists back together and return it.\r\n\r\nInput : 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\n\r\nInput : 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Linked List IV",
    "link": "https://www.techiedelight.com/?problem=RearrangeLinkedListIV",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeLinkedListIV/RearrangeLinkedListIV.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, rearrange it by separating odd nodes from even ones. The solution should return a list containing all even nodes followed by all odd nodes, where the relative order of even and odd nodes is maintained.\r\n\r\nInput : 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\nOutput: 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\n\r\nInput : 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\nOutput: 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\n\r\nInput : 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sorted Merge",
    "link": "https://www.techiedelight.com/?problem=SortedMerge",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortedMerge/SortedMerge.java",
    "problem": "/* START *//*\r\n\r\nGiven two sorted singly-linked lists of integers, merge them into a single list in increasing order, and return it.\r\n\r\nInput:\r\n\r\nX: 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\nY: 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\n\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sorted Merge II",
    "link": "https://www.techiedelight.com/?problem=SortedMergeII",
    "category": "Linked List, Sorting",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortedMergeII/SortedMergeII.java",
    "problem": "/* START *//*\r\n\r\nGiven two sorted singly-linked lists of integers, merge them into a single list in decreasing order, and return it. In other words, merge two sorted linked lists from their end.\r\n\r\nInput:\r\n\r\nX: 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> null\r\nY: 2 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\n\r\nOutput: 10 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sorted Merge III",
    "link": "https://www.techiedelight.com/?problem=SortedMergeIII",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortedMergeIII/SortedMergeIII.java",
    "problem": "/* START *//*\r\n\r\nGiven two sorted singly-linked lists of integers, merge them without modifying the links of the first list.\r\n\r\nIf m and n are the total number of nodes in the first and second list, then the first m smallest nodes in both lists combined should become part of the first list, and the remaining nodes should become part of the second list. The solution should preserve the sorted order of elements in both lists.\r\n\r\nInput:\r\n\r\nX: 2 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> 15 \u00e2\u0080\u0094> null\r\nY: 1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 20 \u00e2\u0080\u0094> null\r\n\r\nOutput:\r\n\r\nX: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\nY: 9 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> 15 \u00e2\u0080\u0094> 20 \u00e2\u0080\u0094> null\r\n\r\nNote: The solution should rearrange the first list X without modifying its links, and return the second list Y.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sorted Merge IV",
    "link": "https://www.techiedelight.com/?problem=SortedMergeIV",
    "category": "Divide & Conquer, Heap, Linked List",
    "tag": "Priority Queue, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/SortedMergeIV/SortedMergeIV.java",
    "problem": "/* START *//*\r\n\r\nGiven k sorted singly-linked lists of integers, merge them into a single list in increasing order, and return it.\r\n\r\nInput: [\r\n\t1 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null,\r\n\t2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> null,\r\n\t4 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\n]\r\n\r\nOutput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 10 \u00e2\u0080\u0094> null\r\n\r\n */\r\n\r\n"
  },
  {
    "title": "Palindrome Linked List",
    "link": "https://www.techiedelight.com/?problem=PalindromeLinkedList",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PalindromeLinkedList/PalindromeLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, determine whether the linked list is a palindrome.\r\n\r\nInput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> null\r\nOutput: true\r\n\r\nInput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> null\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Palindrome Linked List II",
    "link": "https://www.techiedelight.com/?problem=PalindromeLinkedListII",
    "category": "Linked List, String",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/PalindromeLinkedListII/PalindromeLinkedListII.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of strings, check whether the concatenation of all values in the list together forms a palindrome. It is not permissible to construct a string out of the linked list nodes and check that string for palindrome.\r\n\r\nInput: \"AA\" \u00e2\u0080\u0094> \"XYZ\" \u00e2\u0080\u0094> \"CD\" \u00e2\u0080\u0094> \"C\" \u00e2\u0080\u0094> \"ZYX\" \u00e2\u0080\u0094> \"AA\" \u00e2\u0080\u0094> null\r\nOutput: true\r\nExplanation: The string \"AAXYZCDCZYXAA\" is palindrome\r\n\r\nInput: \"A\" \u00e2\u0080\u0094> \"B\" \u00e2\u0080\u0094> \"C\" \u00e2\u0080\u0094> \"DC\" \u00e2\u0080\u0094> \"B\" \u00e2\u0080\u0094> null\r\nOutput: false\r\nExplanation: The string \"ABCDCB\" is not a palindrome\r\n\r\n\r\nNote that Punctuation, capitalization, and spaces should not be ignored.\r\n\r\nInput: \"step on\" \u00e2\u0080\u0094> \"no pets\" \u00e2\u0080\u0094> None\r\nOutput: true\r\nExplanation: The string \"step onno pets\" is a palindrome\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Update Random Pointer",
    "link": "https://www.techiedelight.com/?problem=UpdateRandomPointer",
    "category": "Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/UpdateRandomPointer/UpdateRandomPointer.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers with each node having an additional random pointer, update the random pointer of each node to point to a maximum value node to its right.\r\n\r\nInput : 5(X) \u00e2\u0080\u0094\u00e2\u00ae\u009e 10(X) \u00e2\u0080\u0094\u00e2\u00ae\u009e 7(X) \u00e2\u0080\u0094\u00e2\u00ae\u009e 9(X) \u00e2\u0080\u0094\u00e2\u00ae\u009e 4(X) \u00e2\u0080\u0094\u00e2\u00ae\u009e 3(X) \u00e2\u0080\u0094\u00e2\u00ae\u009e X\r\nOutput: 5(10) \u00e2\u0080\u0094\u00e2\u00ae\u009e 10(9) \u00e2\u0080\u0094\u00e2\u00ae\u009e 7(9) \u00e2\u0080\u0094\u00e2\u00ae\u009e 9(4) \u00e2\u0080\u0094\u00e2\u00ae\u009e 4(3) \u00e2\u0080\u0094\u00e2\u00ae\u009e 3(X) \u00e2\u0080\u0094\u00e2\u00ae\u009e X\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Lists Intersection Point",
    "link": "https://www.techiedelight.com/?problem=ListsIntersectionPoint",
    "category": "Linked List",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ListsIntersectionPoint/ListsIntersectionPoint.java",
    "problem": "/* START *//*\r\n\r\nGiven two non-empty singly-linked lists, where the tail of the second list points to a node in the first list, return the node where both lists intersect. If the lists does not intersect, return null.\r\n\r\nInput:\r\n\r\n1 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 2 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 3 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 4 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 5 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e null\t\t\t// first linked list\r\n\t\t\t\t   \u00e2\u00ae\u009d\r\n1 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 2 \u00e2\u0080\u0094\u00e2\u0080\u0094\u00e2\u00ae\u009e 3 \u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0098\t\t\t\t\t\t\t// second linked list\r\n\r\nOutput: Node 4\r\n\r\nExplanation: The tail of the second list is connected to the fourth node of the first list. The solution should return a pointer to node 4 as the intersection point.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Inorder Tree Traversal",
    "link": "https://www.techiedelight.com/?problem=InorderTreeTraversal",
    "category": "Binary Tree, Stack",
    "tag": "Algorithm, Depth-First Search, Recursive",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/InorderTreeTraversal/InorderTreeTraversal.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the inorder traversal of its nodes' values.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\nOutput: [4, 2, 1, 7, 5, 8, 3, 6]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Preorder Tree Traversal",
    "link": "https://www.techiedelight.com/?problem=PreorderTreeTraversal",
    "category": "Binary Tree, Stack",
    "tag": "Algorithm, Depth-First Search, Recursive",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/PreorderTreeTraversal/PreorderTreeTraversal.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the preorder traversal of its nodes' values.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\nOutput: [1, 2, 4, 3, 5, 7, 8, 6]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Postorder Tree Traversal",
    "link": "https://www.techiedelight.com/?problem=PostorderTreeTraversal",
    "category": "Binary Tree, Stack",
    "tag": "Algorithm, Depth-First Search, Recursive",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/PostorderTreeTraversal/PostorderTreeTraversal.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the postorder traversal of its nodes' values.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\nOutput: [4, 2, 7, 8, 5, 6, 3, 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Level Order Traversal",
    "link": "https://www.techiedelight.com/?problem=LevelOrderTraversal",
    "category": "Binary Tree, Queue",
    "tag": "Algorithm, Breadth-First Search, Depth-First Search, Hashing, Recursive",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/LevelOrderTraversal/LevelOrderTraversal.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the level order traversal of its nodes' values. The solution should consider the binary tree nodes level by level from left to right, i.e., process all nodes of level 1 first, followed by all nodes of level 2, and so on.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\nOutput: [1, 2, 3, 4, 5, 6, 7, 8]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Spiral Order Traversal",
    "link": "https://www.techiedelight.com/?problem=SpiralOrderTraversal",
    "category": "Binary Tree, Queue",
    "tag": "Algorithm, Breadth-First Search, Depth-First Search, Hashing, Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SpiralOrderTraversal/SpiralOrderTraversal.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the spiral level order traversal of its nodes' values. The solution should consider the binary tree nodes level by level in spiral order, i.e., all nodes present at level 1 should be processed first from left to right, followed by nodes of level 2 from right to left, followed by nodes of level 3 from left to right and so on\u00e2\u0080\u00a6 In other words, odd levels should be processed from left to right, and even levels should be processed from right to left.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\nOutput: [1, 3, 2, 4, 5, 6, 8, 7]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Level Order Traversal",
    "link": "https://www.techiedelight.com/?problem=ReverseLevelOrderTraversal",
    "category": "Binary Tree, Queue, Stack",
    "tag": "Algorithm, Breadth-First Search, Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseLevelOrderTraversal/ReverseLevelOrderTraversal.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the reverse level order traversal of its nodes' values. The solution should consider the binary tree nodes level by level in bottom-up order from left to right, i.e., process all nodes of the last level first, followed by all nodes of the second last level, and so on.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\nOutput: [7, 8, 4, 5, 6, 2, 3, 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Check Identical Binary Trees",
    "link": "https://www.techiedelight.com/?problem=CheckIdenticalBinaryTrees",
    "category": "Binary Tree, Stack",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CheckIdenticalBinaryTrees/CheckIdenticalBinaryTrees.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of two binary trees, x and y, check if x is identical to y. Two binary trees are identical if they have identical structure and their contents are also the same.\r\n\r\nInput:\r\n\t\t   1\t\t\t\t\t\t1\r\n\t\t /   \\\t\t\t\t\t  /   \\\r\n\t\t/\t  \\\t\t\t\t\t /\t   \\\r\n\t   2\t   3\t\t\t\t2\t\t3\r\n\t  /\t\\\t  / \\\t\t\t   / \\\t   / \\\r\n\t /\t \\ \t /\t \\\t\t\t  /\t  \\\t  /\t  \\\r\n\t4\t  5\t6\t  7\t\t\t 4\t   5 6\t   7\r\n\r\nOutput: true\r\nExplanation: Both binary trees have the same structure and contents.\r\n\r\nInput:\r\n\t\t   1\t\t\t\t\t\t1\r\n\t\t /   \\\t\t\t\t\t  /   \\\r\n\t\t/\t  \\\t\t\t\t\t /\t   \\\r\n\t   2\t   3\t\t\t\t2\t\t3\r\n\t  /\t\\\t  / \\\t\t\t   / \\\t   /\r\n\t /\t \\ \t /\t \\\t\t\t  /\t  \\\t  /\r\n\t4\t  5\t6\t  7\t\t\t 4\t   5 6\r\n\r\nOutput: false\r\nExplanation: Both binary trees have different structures.\r\n\r\nInput:\r\n\t\t   1\t\t\t\t\t\t1\r\n\t\t /   \\\t\t\t\t\t  /   \\\r\n\t\t/\t  \\\t\t\t\t\t /\t   \\\r\n\t   2\t   3\t\t\t\t2\t\t3\r\n\t  /\t\\\t  / \\\t\t\t   / \\\t   / \\\r\n\t /\t \\ \t /\t \\\t\t\t  /\t  \\\t  /\t  \\\r\n\t4\t  5\t6\t  7\t\t\t 4\t   5 6\t   8\r\n\r\nOutput: false\r\nExplanation: Both binary trees have the same structure but differ in nodes' values.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Height of Binary Tree",
    "link": "https://www.techiedelight.com/?problem=HeightOfBinaryTree",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/HeightOfBinaryTree/HeightOfBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the binary tree's height. The height of the binary tree is the total number of edges or nodes on the longest path from the root node to the leaf node.\r\n\r\nThe solution should consider the total number of nodes in the longest path. For example, an empty tree's height is 0, and the tree's height with only one node is 1.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\\\t  / \\\r\n\t /\t \\ \t /\t \\\r\n\t4\t  5\t6\t  7\r\n\r\nOutput: 3\r\n\r\n\r\nInput:\r\n\t\t   1\r\n\t\t  /\r\n\t\t /\r\n\t\t2\r\n\t   /\r\n\t  /\r\n\t 3\r\n\t/\r\n   /\r\n  4\r\n\r\nOutput: 4\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Height of Binary Tree II",
    "link": "https://www.techiedelight.com/?problem=HeightOfBinaryTreeII",
    "category": "Array, Binary Tree, Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/HeightOfBinaryTreeII/HeightOfBinaryTreeII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array representing the parent-child relationship in a binary tree, find the tree's height without building the tree. The parent-child relationship is defined by (A[i], i) for every index i in array A. The root node's value will be i if -1 is present at index i in the array.\r\n\r\nThe height of a \"node\" is the total number of edges on the longest path from the node to a leaf. The height of a \"tree\" would be the height of its root node, or equivalently, the depth of its deepest node. A leaf node will have a height of 0 and an empty tree has height \u00e2\u0088\u00921.\r\n\r\nInput: [-1, 0, 0, 1, 2, 2, 4, 4]\r\nOutput: 3\r\nExplanation: The parent array represents the folllowing binary tree\r\n\r\n\t\t   0\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   1\t   2\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t3\t\t4\t  5\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 6\t   7\r\n\r\n\u00e2\u0080\u00a2 -1 is present at index 0, which implies that the binary tree root is node 0.\r\n\u00e2\u0080\u00a2 0 is present at index 1 and 2, which implies that the left and right children of node 0 are 1 and 2.\r\n\u00e2\u0080\u00a2 1 is present at index 3, which implies that the left or the right child of node 1 is 3.\r\n\u00e2\u0080\u00a2 2 is present at index 4 and 5, which implies that the left and right children of node 2 are 4 and 5.\r\n\u00e2\u0080\u00a2 4 is present at index 6 and 7, which implies that the left and right children of node 4 are 6 and 7.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Height of Binary Tree III",
    "link": "https://www.techiedelight.com/?problem=HeightOfBinaryTreeIII",
    "category": "Binary Tree, Linked List",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/HeightOfBinaryTreeIII/HeightOfBinaryTreeIII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree with leaf nodes forming a circular doubly linked list, return the binary tree's height. Note that the leaf node's left and right pointers will act as a previous and next pointer of the circular doubly linked list, respectively.\r\n\r\nThe height of the binary tree is the total number of edges or nodes on the longest path from the root node to the leaf node. The solution should consider the total number of nodes in the longest path. For example, an empty tree's height is 0, and the tree's height with only one node is 1.\r\n\r\nInput: Below binary tree (The leaf nodes [7, 5, 6] are connected using the left and right pointers and forming a circular doubly linked list)\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\\\t\t\\\r\n\t /\t \\ \t \t \\\r\n\t4\t  5\t\t  6\r\n   /\r\n  /\r\n 7\r\n\r\nOutput: 4\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Clone Binary Tree",
    "link": "https://www.techiedelight.com/?problem=CloneBinaryTree",
    "category": "Binary Tree",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CloneBinaryTree/CloneBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return a clone of it. The solution should return a new binary tree which is identical to the given binary tree in terms of its structure and contents, and it should not use the nodes of the binary tree.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\\\t  / \\\r\n\t /\t \\ \t /\t \\\r\n\t4\t  5\t6\t  7\r\n\r\nOutput:\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\\\t  / \\\r\n\t /\t \\ \t /\t \\\r\n\t4\t  5\t6\t  7\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Clone Binary Tree II",
    "link": "https://www.techiedelight.com/?problem=CloneBinaryTreeII",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/CloneBinaryTreeII/CloneBinaryTreeII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a special binary tree with each node containing an additional random pointer, return a clone of it. The random pointer can point to any node of the binary tree or can be null.\r\n\r\nThe solution should return a new binary tree which is identical to the given binary tree in terms of its structure and contents, and it should not use the nodes of the binary tree.\r\n\r\nInput:\r\n\t\t\t  1(6)\r\n\t\t\t/\t   \\\r\n\t\t  /\t\t\t \\\r\n\t\t2(X)\t\t 3(X)\r\n\t   /   \\\t\t/   \\\r\n\t  /\t\t\\\t   /\t \\\r\n\t4(3)   5(1)  6(4)\t 7(X)\r\n\r\n\r\nHere, random pointer of:\r\n\r\n\u00e2\u0080\u00a2 Node 1 points to Node 6\r\n\u00e2\u0080\u00a2 Node 2 points to null\r\n\u00e2\u0080\u00a2 Node 3 points to null\r\n\u00e2\u0080\u00a2 Node 4 points to Node 3\r\n\u00e2\u0080\u00a2 Node 5 points to Node 1\r\n\u00e2\u0080\u00a2 Node 6 points to Node 4\r\n\u00e2\u0080\u00a2 Node 7 points to null\r\n\r\nOutput:\r\n\r\n\t\t\t  1(6)\r\n\t\t\t/\t   \\\r\n\t\t  /\t\t\t \\\r\n\t\t2(X)\t\t 3(X)\r\n\t   /   \\\t\t/   \\\r\n\t  /\t\t\\\t   /\t \\\r\n\t4(3)   5(1)  6(4)\t 7(X)\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Ancestor or Descendant",
    "link": "https://www.techiedelight.com/?problem=IsAncestorOrDescendant",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/IsAncestorOrDescendant/IsAncestorOrDescendant.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree and two tree nodes, x and y, check if they lie on the same root-to-leaf path in the binary tree. In other words, determine whether x is an ancestor of y or x is a descendant of y.\r\n\r\nFor example, consider the following binary tree.\r\n\r\n\t\t\t\t\t 1\r\n\t\t\t\t   /   \\\r\n\t\t\t\t /\t\t \\\r\n\t\t\t\t2\t\t  3\r\n\t\t\t  /  \\\t\t /  \\\r\n\t\t\t /\t  \\\t\t/\t \\\r\n\t\t\t4\t   5   6\t  7\r\n\t\t  /   \\\t\t\\\t\t /\r\n\t\t /\t   \\\t \\\t\t/\r\n\t\t8\t\t9\t 10\t   11\r\n\t\t\t  /   \\\t\t  /\r\n\t\t\t /\t   \\\t /\r\n\t\t\t12\t   13\t14\r\n\r\nInput: x = Node 3, y = Node 14\r\nOutput: true\r\nExplanation: Node 3 is an ancestor of Node 14\r\n\r\nInput: x = Node 12, y = Node 2\r\nOutput: true\r\nExplanation: Node 12 is a direct descendant of Node 2\r\n\r\nInput: x = Node 4, y = Node 5\r\nOutput: false\r\nExplanation: Node 4 is a neither an ancestor nor a descendant of Node 5\r\n\r\nNote: The solution should return false if either x or y is not the actual node in the tree.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Bottom View Binary Tree",
    "link": "https://www.techiedelight.com/?problem=BottomViewBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/BottomViewBinaryTree/BottomViewBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the bottom view of its nodes' values. Assume the left and right child of a node makes a 45\u00e2\u0080\u0093degree angle with the parent.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /\t \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  \t\t /   \\\r\n\t \t  \t/\t  \\\r\n\t\t   5\t   6\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   7\t   8\r\n\r\nOutput: [7, 5, 8, 6]\r\n\r\nInput:\r\n\r\n\t  1\r\n\t/   \\\r\n   /\t \\\r\n  2\t\t  3\r\n   \\\r\n\t\\\r\n\t 4\r\n\t  \\\r\n\t   \\\r\n\t\t5\r\n\r\nOutput: [2, 4, 5]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Top View Binary Tree",
    "link": "https://www.techiedelight.com/?problem=TopViewBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TopViewBinaryTree/TopViewBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the top view of its nodes' values. Assume the left and right child of a node makes a 45\u00e2\u0080\u0093degree angle with the parent.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /\t \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  \t\t /   \\\r\n\t \t  \t/\t  \\\r\n\t\t   5\t   6\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   7\t   8\r\n\r\nOutput: [2, 1, 3, 6]\r\n\r\nInput:\r\n\r\n\t  1\r\n\t/   \\\r\n   /\t \\\r\n  2\t\t  3\r\n   \\\r\n\t\\\r\n\t 4\r\n\t  \\\r\n\t   \\\r\n\t\t5\r\n\r\nOutput: [2, 1, 3]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Left View Binary Tree",
    "link": "https://www.techiedelight.com/?problem=LeftViewBinaryTree",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Hashing, Recursive",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/LeftViewBinaryTree/LeftViewBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the left view of its nodes' values. Assume the left and right child of a node makes a 45\u00e2\u0080\u0093degree angle with the parent.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /\t \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  \t\t /   \\\r\n\t \t  \t/\t  \\\r\n\t\t   5\t   6\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   7\t   8\r\n\r\nOutput: [1, 2, 5, 7]\r\n\r\nInput:\r\n\r\n\t  1\r\n\t/   \\\r\n   /\t \\\r\n  2\t\t  3\r\n   \\\t /\r\n\t\\   /\r\n\t 4 5\r\n\r\nOutput: [1, 2, 4]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Right View Binary Tree",
    "link": "https://www.techiedelight.com/?problem=RightViewBinaryTree",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RightViewBinaryTree/RightViewBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the right view of its nodes' values. Assume the left and right child of a node makes a 45\u00e2\u0080\u0093degree angle with the parent.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /\t \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  \t\t /   \\\r\n\t \t  \t/\t  \\\r\n\t\t   5\t   6\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   7\t   8\r\n\r\nOutput: [1, 3, 6, 8]\r\n\r\nInput:\r\n\r\n\t  1\r\n\t/   \\\r\n   /\t \\\r\n  2\t\t  3\r\n   \\\t /\r\n\t\\   /\r\n\t 4 5\r\n\r\nOutput: [1, 3, 5]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Perfect Binary Tree Traversal",
    "link": "https://www.techiedelight.com/?problem=PerfectBinaryTreeTraversal",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Hashing",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/PerfectBinaryTreeTraversal/PerfectBinaryTreeTraversal.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a perfect binary tree, return the values of alternating left and right nodes for each level.\r\n\r\nInput:\r\n\t\t\t\t\t1\r\n\t\t\t\t  /\t   \\\r\n\t\t\t   /\t\t \\\r\n\t\t\t/\t\t\t   \\\r\n\t\t  2\t\t\t\t\t 3\r\n\t\t/   \\\t\t\t\t/  \\\r\n\t  /\t\t  \\\t\t\t  /\t\t \\\r\n\t 4\t\t   5\t\t 6\t\t  7\r\n\t/ \\\t\t  / \\\t\t/ \\\t\t / \\\r\n   /   \\\t /   \\\t   /   \\\t/   \\\r\n  8\t\t9   10   11   12   13  14   15\r\n\r\nOutput: [1, 2, 3, 4, 7, 5, 6, 8, 15, 9, 14, 10, 13, 11, 12]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Perfect Binary Tree Traversal II",
    "link": "https://www.techiedelight.com/?problem=PerfectBinaryTreeTraversalII",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Hashing",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/PerfectBinaryTreeTraversalII/PerfectBinaryTreeTraversalII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a perfect binary tree, return the values of alternating left and right nodes for each level from bottom to top.\r\n\r\nInput:\r\n\t\t\t\t\t1\r\n\t\t\t\t  /\t   \\\r\n\t\t\t   /\t\t \\\r\n\t\t\t/\t\t\t   \\\r\n\t\t  2\t\t\t\t\t 3\r\n\t\t/   \\\t\t\t\t/  \\\r\n\t  /\t\t  \\\t\t\t  /\t\t \\\r\n\t 4\t\t   5\t\t 6\t\t  7\r\n\t/ \\\t\t  / \\\t\t/ \\\t\t / \\\r\n   /   \\\t /   \\\t   /   \\\t/   \\\r\n  8\t\t9   10   11   12   13  14   15\r\n\r\nOutput: [8, 15, 9, 14, 10, 13, 11, 12, 4, 7, 5, 6, 2, 3, 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Boundary Traversal Binary Tree",
    "link": "https://www.techiedelight.com/?problem=BoundaryTraversalBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/BoundaryTraversalBinaryTree/BoundaryTraversalBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the boundary traversal of its nodes' values. The solution should process the boundary nodes starting from the tree's root, in an anti-clockwise direction, without any duplicates.\r\n\r\nInput:\r\n\t\t\t\t1\r\n\t\t\t  /   \\\r\n\t\t\t/\t\t\\\r\n\t\t  /\t\t\t  \\\r\n\t\t 2\t\t\t   3\r\n\t   /   \\\t\t /   \\\r\n\t  /\t\t\\\t\t/\t  \\\r\n\t 4\t\t 5\t   6\t   7\r\n\t/ \\\t\t  \\\t\t\t  /\r\n   /   \\\t   \\\t\t /\r\n  8\t\t9\t   10\t   11\r\n\t   / \\\t\t\t  /\r\n\t  /   \\\t\t\t /\r\n\t 12   13\t\t14\r\n\r\nOutput: [1, 2, 4, 8, 12, 13, 10, 6, 14, 11, 7, 3]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Diagonal Traversal Binary Tree",
    "link": "https://www.techiedelight.com/?problem=DiagonalTraversalBinaryTree",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DiagonalTraversalBinaryTree/DiagonalTraversalBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the diagonal traversal of its nodes' values. The solution should process all nodes for each diagonal having negative slope (\\). Assume that the left and right child of a node makes a 45\u00e2\u0080\u0093degree angle with the parent.\r\n\r\nInput:\r\n\t\t\t\t 1\r\n\t\t\t .\t\t .\r\n\t\t   .\t\t   .\r\n\t\t 2\t\t\t\t 3\r\n\t   .\t\t\t   .\t.\r\n\t .\t\t\t\t .\t\t  .\r\n   4\t\t\t   5\t\t\t6\r\n\t\t\t\t .   .\r\n\t\t\t   .\t   .\r\n\t\t\t 7\t\t\t 8\r\n\r\nOutput: [1, 3, 6, 2, 5, 8, 4, 7]\r\n\r\nExplanation: The binary tree has three diagonals:\r\n\r\n[1, 3, 6]\r\n[2, 5, 8]\r\n[4, 7]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Vertical Traversal Binary Tree",
    "link": "https://www.techiedelight.com/?problem=VerticalTraversalBinaryTree",
    "category": "Binary Tree, Linked List, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/VerticalTraversalBinaryTree/VerticalTraversalBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the vertical traversal of its nodes' values. In a vertical traversal, nodes of a binary tree are processed in vertical order from left to right. Assume that the left and right child makes a 45\u00e2\u0080\u0093degree angle with the parent.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /\t \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  \t\t /   \\\r\n\t \t  \t/\t  \\\r\n\t\t   5\t   6\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   7\t   8\r\n\r\nOutput: [2, 7, 1, 5, 3, 8, 6]\r\n\r\nExplanation: The binary tree has four vertical levels:\r\n\r\n[2, 7]\r\n[1, 5]\r\n[3, 8]\r\n[6]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Width Binary Tree",
    "link": "https://www.techiedelight.com/?problem=MaximumWidthBinaryTree",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumWidthBinaryTree/MaximumWidthBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the maximum number of nodes at any level in the binary tree.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\\\t  / \\\r\n\t /\t \\ \t /\t \\\r\n\t4\t  5\t6\t  7\r\n\r\nOutput: 4\r\n\r\nInput:\r\n\t\t   1\r\n\t\t  /\r\n\t\t /\r\n\t\t2\r\n\t   /\r\n\t  /\r\n\t 3\r\n\t/\r\n   /\r\n  4\r\n\r\nOutput: 1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Depth Binary Tree",
    "link": "https://www.techiedelight.com/?problem=MinimumDepthBinaryTree",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumDepthBinaryTree/MinimumDepthBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the minimum depth of the binary tree. The minimum depth is the total number of nodes along the shortest path in binary tree from the root node down to the nearest leaf node.\r\n\r\nInput:\r\n\r\n\t\t\t\t1\r\n\t\t\t  /   \\\r\n\t\t\t/\t\t\\\r\n\t\t  /\t\t\t  \\\r\n\t\t 2\t\t\t   3\r\n\t   /   \\\t\t /   \\\r\n\t  /\t\t\\\t\t/\t  \\\r\n\t 4\t\t 5\t   6\t   7\r\n\t  \\\t\t  \\\t\t\t  / \\\r\n\t   \\\t   \\\t\t /   \\\r\n\t\t8\t\t9\t\t10\t 11\r\n\t\t \\\r\n\t\t  \\\r\n\t\t  12\r\n\r\nOutput: 3\r\n\r\nExplanation: The shortest path is 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 6.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Corner Nodes in Each Level",
    "link": "https://www.techiedelight.com/?problem=CornerNodesInEachLevel",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CornerNodesInEachLevel/CornerNodesInEachLevel.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return corner nodes' values for each level in it.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t\t\t  / \\\r\n\t\t\t /\t \\\r\n\t\t\t4\t  5\r\n\t\t   / \\\t   \\\r\n\t\t  /   \\\t\t\\\r\n\t\t 6\t   7\t 8\r\n\r\nOutput: [1, 2, 3, 4, 5, 6, 8]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Cousin Nodes",
    "link": "https://www.techiedelight.com/?problem=CousinNodes",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CousinNodes/CousinNodes.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree and two tree nodes, x and y, check if x and y are cousins of each other. Two nodes of a binary tree are cousins of each other if they have different parents, but they are at the same level.\r\n\r\nFor example, consider the following binary tree.\r\n\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  3\r\n\t  /  \\\t\t /  \\\r\n\t /\t  \\\t\t/\t \\\r\n\t4\t   5   6\t  7\r\n\r\n\r\nInput: x = Node 4, y = Node 6\r\nOutput: true\r\n\r\nInput: x = Node 5, y = Node 6\r\nOutput: true\r\n\r\nInput: x = Node 2, y = Node 3\r\nOutput: false\r\n\r\nInput: x = Node 4, y = Node 3\r\nOutput: false\r\n\r\nNote: The solution should return false if either x or y is not the actual node in the tree.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Cousin Nodes II",
    "link": "https://www.techiedelight.com/?problem=CousinNodesII",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CousinNodesII/CousinNodesII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree and a tree node x, return values of all cousin nodes of x in the binary tree. Two nodes of a binary tree are cousins of each other only if they have different parents, but they are at the same level.\r\n\r\nFor example, consider the following binary tree.\r\n\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  3\r\n\t  /  \\\t\t /  \\\r\n\t /\t  \\\t\t/\t \\\r\n\t4\t   5   6\t  7\r\n\r\n\r\nInput: x = Node 6\r\nOutput: [4, 5]\r\n\r\nInput: x = Node 2\r\nOutput: []\r\n\r\nInput: x = Node 4\r\nOutput: [6, 7]\r\n\r\nNote: The solution should return an empty list if x is not the actual node in the tree.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Lowest Common Ancestor",
    "link": "https://www.techiedelight.com/?problem=LowestCommonAncestor",
    "category": "Binary Tree",
    "tag": "Recursive",
    "lists": "TopClassic, TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LowestCommonAncestor/LowestCommonAncestor.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree and two tree nodes, x and y, return the lowest common ancestor (LCA) of x and y in the binary tree.\r\n\r\nThe lowest common ancestor (LCA) of two nodes x and y in a binary tree is the lowest (i.e., deepest) node that has both x and y as descendants, where each node can be a descendant of itself (so if x is reachable from w, w is the LCA). In other words, the LCA of x and y is the shared ancestor of x and y that is located farthest from the root.\r\n\r\nFor example, consider the following binary tree.\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t   \\\t  / \\\r\n\t\t\\\t /\t \\\r\n\t\t 4\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\nInput: x = Node 6, y = Node 7\r\nOutput: Node 3\r\nExplanation: The common ancestors of nodes 6 and 7 are 1 and 3. Out of nodes 1 and 3, the LCA is 3 as it is farthest from the root.\r\n\r\nInput: x = Node 5, y = Node 8\r\nOutput: Node 5\r\nExplanation: Node 8 itself is descendant of node 5 (and node 5 can be a descendant of itself).\r\n\r\nInput: x = Node 2, y = Node 5\r\nOutput: Node 1\r\n\r\nNote: The solution should return null if either x or y is not the actual node in the tree.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Ancestors of Binary Tree Node",
    "link": "https://www.techiedelight.com/?problem=AncestorsOfBinaryTreeNode",
    "category": "Binary Tree, Stack",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/AncestorsOfBinaryTreeNode/AncestorsOfBinaryTreeNode.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree and a tree node x, return values of all ancestors of x in the binary tree. Two nodes of a binary tree are cousins of each other if they have different parents, but they are at the same level.\r\n\r\nFor example, consider the following binary tree.\r\n\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  3\r\n\t  /  \\\t\t /  \\\r\n\t /\t  \\\t\t/\t \\\r\n\t4\t   5   6\t  7\r\n\t\t\t  /\t\t   \\\r\n\t\t\t /\t\t\t\\\r\n\t\t\t8\t\t\t 9\r\n\r\nInput: x = Node 9\r\nOutput: [7, 3, 1]\r\n\r\nInput: x = Node 6\r\nOutput: [3, 1]\r\n\r\nInput: x = Node 5\r\nOutput: [2, 1]\r\n\r\nThe returned nodes should follow the node-to-root order. The solution should return an empty list if x is not the actual node in the tree.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Height Balanced Binary Tree",
    "link": "https://www.techiedelight.com/?problem=HeightBalancedBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/HeightBalancedBinaryTree/HeightBalancedBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, check if it is height-balanced or not. In a height-balanced tree, the absolute difference between the height of the left and right subtree for every node is 0 or 1.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t   \\\t  / \\\r\n\t\t\\\t /\t \\\r\n\t\t 4\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\nOutput: true\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t\t\t  / \\\r\n\t\t\t /\t \\\r\n\t\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Height Balanced Binary Tree II",
    "link": "https://www.techiedelight.com/?problem=HeightBalancedBinaryTreeII",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/HeightBalancedBinaryTreeII/HeightBalancedBinaryTreeII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, check if it satisfies the height-balanced property of the red\u00e2\u0080\u0093black tree or not.\r\n\r\nThe red\u00e2\u0080\u0093black tree's height-balanced property states that the path from the root to the farthest leaf is no more than twice as long as a path from the root to the nearest leaf. In other words, the maximum height of any node in a tree is not greater than twice its minimum height.\r\n\r\nInput:\r\n\t\t\t   1\r\n\t\t\t/\t \\\r\n\t\t   2\t   3\r\n\t\t /\t\t /   \\\r\n\t   4\t\t5\t   6\r\n\t\t\t  /   \\\r\n\t\t\t 7\t   8\r\n\t\t   /   \\\r\n\t\t  9\t   10\r\n\r\nOutput: true\r\n\r\n\r\nInput:\r\n\t\t\t   1\r\n\t\t\t/\t \\\r\n\t\t   2\t   3\r\n\t\t /\t\t /   \\\r\n\t   4\t\t5\t   6\r\n\t\t\t  /   \\\r\n\t\t\t 7\t   8\r\n\t\t   /   \\\r\n\t\t  9\t\t10\r\n\t\t\t  /\t   \\\r\n\t\t\t 11\t   12\r\n\r\nOutput: false\r\n\r\nExplanation: The tree violates the red\u00e2\u0080\u0093black tree property at node 3.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Nodes Between Two Levels",
    "link": "https://www.techiedelight.com/?problem=NodesBetweenTwoLevels",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/NodesBetweenTwoLevels/NodesBetweenTwoLevels.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree and two positive numbers m and n where m >= n, return values of all nodes between level m and level n. The nodes for each level should be processed from left and right.\r\n\r\nInput: Below binary tree, m = 2, n = 3\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t\t\t  / \\\r\n\t\t\t /\t \\\r\n\t\t\t4\t  5\r\n\t\t   / \\\t   \\\r\n\t\t  /   \\\t\t\\\r\n\t\t 6\t   7\t 8\r\n\r\nOutput: [2, 3, 4, 5]\r\n\r\nNote: If n is more than the number of levels in the binary tree, the solution return nodes till last level. For example, if the starting level is 2 and the ending level is 7, the solution should return [2, 3, 4, 5, 6, 7, 8] for above binary tree.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Distance Between Two Nodes",
    "link": "https://www.techiedelight.com/?problem=DistanceBetweenTwoNodes",
    "category": "Binary Tree",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/DistanceBetweenTwoNodes/DistanceBetweenTwoNodes.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree and two tree nodes, x and y, return the distance between x and y in the binary tree. The distance between two nodes is defined as the total number of edges in the shortest path from one node to other.\r\n\r\nFor example, consider the following binary tree.\r\n\r\n\t\t  1\r\n\t\t/   \\\r\n\t   /\t \\\r\n\t  2\t\t  3\r\n\t   \\\t / \\\r\n\t\t4   5   6\r\n\t\t   /\t \\\r\n\t\t  7\t\t  8\r\n\r\nInput: x = Node 7, y = Node 6\r\nOutput: 3\r\n\r\nInput: x = Node 4, y = Node 8\r\nOutput: 5\r\n\r\nInput: x = Node 5, y = Node 5\r\nOutput: 0\r\n\r\nNote: The solution should return a negative value if either x or y is not the actual node in the tree.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "K Distance Nodes from Leaves",
    "link": "https://www.techiedelight.com/?problem=KDistanceNodesFromLeaves",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/KDistanceNodesFromLeaves/KDistanceNodesFromLeaves.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree and a positive number k, return all nodes present at distance k from any leaf node. The solution should report only those nodes that are present in the root-to-leaf path for that leaf.\r\n\r\nFor example, consider the following binary tree.\r\n\r\n\t\t\t\t1\r\n\t\t\t  /   \\\r\n\t\t\t/\t\t\\\r\n\t\t  /\t\t\t  \\\r\n\t\t 2\t\t\t   3\r\n\t   /   \\\t\t /   \\\r\n\t  /\t\t\\\t\t/\t  \\\r\n\t 4\t\t 5\t   6\t   7\r\n\t\t\t\t /\r\n\t\t\t\t/\r\n\t\t\t   8\r\n\r\nInput: k = 1\r\nOutput: {2, 6, 3}\r\n\r\nInput: k = 2\r\nOutput: {1, 3}\r\n\r\nInput: k = 3\r\nOutput: {1}\r\n\r\nNote: If k is more than the number of levels in the binary tree, the solution return an empty set.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Transform Binary Tree",
    "link": "https://www.techiedelight.com/?problem=TransformBinaryTree",
    "category": "Binary Tree",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/TransformBinaryTree/TransformBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven root of two binary trees, x and y, determine if x can be converted into y by doing any number of swaps of its right and left branches. Two binary trees are identical if they have identical structure and same nodes' values.\r\n\r\nInput: Two binary trees\r\n\r\n\t\t\t\t6\r\n\t\t\t  /   \\\r\n\t\t\t/\t\t\\\r\n\t\t  /\t\t\t  \\\r\n\t\t 3\t\t\t   8\r\n\t\t/ \\\t\t\t  / \\\r\n\t   /   \\\t\t /   \\\r\n\t  1\t\t7\t\t4\t  2\r\n\t\t\t\t   / \\\t   \\\r\n\t\t\t\t  /   \\\t\t\\\r\n\t\t\t\t 7\t   1\t 3\r\n\r\n\t\t\t\t6\r\n\t\t\t  /   \\\r\n\t\t\t/\t\t\\\r\n\t\t  /\t\t\t  \\\r\n\t\t 8\t\t\t   3\r\n\t\t/ \\\t\t\t  / \\\r\n\t   /   \\\t\t /   \\\r\n\t  2\t\t4\t\t7\t  1\r\n\t /\t   / \\\r\n\t/\t  /\t  \\\r\n   3\t 1\t   7\r\n\r\nOutput: true\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Transform Binary Tree II",
    "link": "https://www.techiedelight.com/?problem=TransformBinaryTreeII",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/TransformBinaryTreeII/TransformBinaryTreeII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, in-place replace each node's value to the sum of all elements present in its left and right subtree. You may assume the value of an empty child node to be 0.\r\n\r\nInput:\r\n\r\n\t   1\r\n\t /   \\\r\n\t/\t  \\\r\n   2\t   3\r\n\r\nOutput:\r\n\r\n\t   5\r\n\t /   \\\r\n\t/\t  \\\r\n   0\t   0\r\n\r\n\r\nInput:\r\n\r\n\t   1\r\n\t /\t \\\r\n\t/\t  \\\r\n   /\t   \\\r\n  2\t\t\t3\r\n   \\\t   / \\\r\n\t\\\t  /\t  \\\r\n\t 4   5\t   6\r\n\t\t/ \\\r\n\t   /   \\\r\n\t  7\t\t8\r\n\r\nOutput:\r\n\r\n\t   35\r\n\t /\t  \\\r\n\t/\t   \\\r\n   /\t\t\\\r\n  4\t\t\t26\r\n   \\\t   /  \\\r\n\t\\\t  /\t   \\\r\n\t 0   15\t\t0\r\n\t\t/  \\\r\n\t   /\t\\\r\n\t  0\t\t 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Truncate Binary Tree",
    "link": "https://www.techiedelight.com/?problem=TruncateBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TruncateBinaryTree/TruncateBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, convert it into a full tree by removing half nodes i.e., nodes having one child. A full binary tree is a tree in which every node other than the leaves has two children.\r\n\r\nInput:\r\n\t\t\t 0\r\n\t\t   /   \\\r\n\t\t  /\t\t\\\r\n\t\t 1\t\t 2\r\n\t\t/\t\t/\r\n\t   /\t   /\r\n\t  3\t\t  4\r\n\t /\t\t / \\\r\n\t/\t\t/   \\\r\n   5\t   6\t 7\r\n\r\nOutput:\r\n\r\n\t\t 0\r\n\t   /   \\\r\n\t  /\t \t\\\r\n\t 5\t\t 4\r\n\t\t\t/ \\\r\n\t\t   /   \\\r\n\t\t  6\t \t7\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Truncate Binary Tree II",
    "link": "https://www.techiedelight.com/?problem=TruncateBinaryTreeII",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TruncateBinaryTreeII/TruncateBinaryTreeII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree and a positive number k, remove nodes from the tree which lie on a complete path having a sum less than k. Since a node can be part of multiple paths, delete it only if all paths from it have a sum less than k.\r\n\r\nA complete path in a binary tree is defined as a path from the root to a leaf. The sum of all nodes on that path is defined as the sum of that path.\r\n\r\n\r\nInput: Below binary tree, k = 20\r\n\r\n\t\t 6\r\n\t   /   \\\r\n\t  /\t\t\\\r\n\t 3\t\t 8\r\n\t\t   /   \\\r\n\t\t  /\t\t\\\r\n\t\t 4\t\t 2\r\n\t   /   \\\t  \\\r\n\t  /\t\t\\\t   \\\r\n\t 1\t\t 7\t\t3\r\n\r\nOutput:\r\n\r\n\t  6\r\n\t   \\\r\n\t\t\\\r\n\t\t 8\r\n\t\t/\r\n\t   /\r\n\t  4\r\n\t   \\\r\n\t\t\\\r\n\t\t 7\r\n\r\nThe deletion should be done in a bottom-up manner until the path has a root-to-leaf sum greater than or equal to `k`. For example:\r\n\r\nInput: Below binary tree, k = 3\r\n\r\n         1\r\n       /   \\\r\n      /     \\\r\n     2       3\r\n      \\     / \\\r\n       \\   /   \\\r\n       -4 5     6\r\n\r\nOutput:\r\n\r\n         1\r\n       /   \\\r\n      /     \\\r\n     2       3\r\n            / \\\r\n           /   \\\r\n          5     6\r\n*/\r\n\r\n"
  },
  {
    "title": "Sum Tree",
    "link": "https://www.techiedelight.com/?problem=SumTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SumTree/SumTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, check if the binary tree is a sum tree or not. In a sum tree, each non-leaf node's value is equal to the sum of all elements present in its left and right subtree. The value of a leaf node can be anything and the value of an empty child node is considered to be 0.\r\n\r\nInput:\r\n\r\n\t\t\t 44\r\n\t\t   /\t\\\r\n\t\t  /\t\t \\\r\n\t\t 9\t\t  13\r\n\t   /   \\\t /  \\\r\n\t  /\t\t\\\t/\t \\\r\n\t 4\t\t 5 6\t  7\r\n\r\nOutput: true\r\n\r\nExplanation: All non-leaf nodes follows the sum tree property, as shown below:\r\n\r\n\t\t\t 44 (4+5+9)+(6+7+13)\r\n\t\t   /\t\\\r\n\t\t  /\t\t \\\r\n   (4+5) 9\t\t  13 (6+7)\r\n\t   /   \\\t /  \\\r\n\t  /\t\t\\\t/\t \\\r\n\t 4\t\t 5 6\t  7\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Root to Leaf Paths in Binary Tree",
    "link": "https://www.techiedelight.com/?problem=RootToLeafPathsInBinaryTree",
    "category": "Binary Tree, Backtracking",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/RootToLeafPathsInBinaryTree/RootToLeafPathsInBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return all paths from the root node to every leaf node in the binary tree.\r\n\r\nInput:\r\n\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  3\r\n\t  /  \\\t\t /  \\\r\n\t /\t  \\\t\t/\t \\\r\n\t4\t   5   6\t  7\r\n\t\t\t  /\t\t   \\\r\n\t\t\t /\t\t\t\\\r\n\t\t\t8\t\t\t 9\r\n\r\nOutput: {[1, 2, 4], [1, 2, 5], [1, 3, 6, 8], [1, 3, 7, 9]}\r\n\r\nExplanation: The binary tree has four root-to-leaf paths:\r\n\r\n1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 4\r\n1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 5\r\n1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8\r\n1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 9\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Leaf to Root Paths in Binary Tree",
    "link": "https://www.techiedelight.com/?problem=LeafToRootPathsInBinaryTree",
    "category": "Binary Tree, Backtracking",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LeafToRootPathsInBinaryTree/LeafToRootPathsInBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return all paths from every leaf node to the root node in the binary tree.\r\n\r\nInput:\r\n\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  3\r\n\t   / \\\t\t / \\\r\n\t  /\t  \\\t\t/\t\\\r\n\t 4\t   5   6\t 7\r\n\t\t\t  / \\\r\n\t\t\t /\t \\\r\n\t\t\t8\t  9\r\n\r\nOutput: {[4, 2, 1], [5, 2, 1], [8, 6, 3, 1], [9, 6, 3, 1], [7, 3, 1]}\r\n\r\nExplanation: The binary tree has five leaf-to-root paths:\r\n\r\n4 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1\r\n5 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 1\r\n8 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1\r\n9 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1\r\n7 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Mirror of Binary Tree",
    "link": "https://www.techiedelight.com/?problem=MirrorOfBinaryTree",
    "category": "Binary Tree, Queue, Stack",
    "tag": "Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MirrorOfBinaryTree/MirrorOfBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, convert the binary tree into its mirror.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  / \\\t  / \\\r\n\t /\t \\\t /\t \\\r\n\t4\t  5\t6\t  7\r\n\r\nOutput:\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   3\t   2\r\n\t  / \\\t  / \\\r\n\t /\t \\\t /\t \\\r\n\t7\t  6\t5\t  4\r\n\r\nExplanation:\r\n\t\t\t\t\t\t|\r\n\t\t\t\t\t\t|\r\n\t\t   1\t\t\t|\t\t   1\r\n\t\t /   \\\t\t\t|\t\t /   \\\r\n\t\t/\t  \\\t\t\t|\t\t/\t  \\\r\n\t   2\t   3\t\t|\t   3\t   2\r\n\t  / \\\t  / \\\t\t|\t  / \\\t  / \\\r\n\t /\t \\\t /\t \\\t\t|\t /\t \\\t /\t \\\r\n\t4\t  5\t6\t  7\t\t|\t7\t  6\t5\t  4\r\n\t\t\t\t\t\t|\r\n\t\t\t\t\t\t|\r\n*/\r\n\r\n"
  },
  {
    "title": "Node Descendant Difference",
    "link": "https://www.techiedelight.com/?problem=NodeDescendantDifference",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/NodeDescendantDifference/NodeDescendantDifference.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the maximum difference between a node and its descendants in the binary tree. You may assume that the binary tree contains at-least two nodes.\r\n\r\nInput:\r\n\t\t   6\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   3\t   8\r\n\t\t\t  / \\\r\n\t\t\t /\t \\\r\n\t\t\t2\t  4\r\n\t\t   / \\\r\n\t\t  /\t  \\\r\n\t\t 1\t   7\r\n\r\nOutput: 7\r\n\r\nExplanation: The maximum difference between a node and its descendants is 8 - 1 = 7.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Alternate Levels Sum Difference",
    "link": "https://www.techiedelight.com/?problem=AlternateLevelsSumDifference",
    "category": "Binary Tree",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/AlternateLevelsSumDifference/AlternateLevelsSumDifference.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the difference between the sum of all nodes present at odd levels and the sum of all nodes present at even level.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t  \t5\t  6\r\n\t\t   / \\\r\n\t\t  /\t  \\\r\n\t\t 7\t   8\r\n\r\nOutput: -4\r\n\r\nExplanation: The difference is (1 + 4 + 5 + 6) - (2 + 3 + 7 + 8) = -4\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Sum Path Binary Tree",
    "link": "https://www.techiedelight.com/?problem=MaximumSumPathBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumSumPathBinaryTree/MaximumSumPathBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the maximum sum path from the root node to any leaf node in the binary tree.\r\n\r\nInput:\r\n\t\t\t\t1\r\n\t\t\t  /   \\\r\n\t\t\t/\t\t\\\r\n\t\t  /\t\t\t  \\\r\n\t\t 2\t\t\t   3\r\n\t   /   \\\t\t /   \\\r\n\t  /\t\t\\\t\t/\t  \\\r\n\t 8\t\t 4\t   5\t   6\r\n\t\t\t/\t  / \\\t\t\\\r\n\t\t   /\t /   \\\t\t \\\r\n\t\t 10\t\t7\t  9\t\t  5\r\n\r\nOutput: [1, 3, 5, 9]\r\n\r\nExplanation: The maximum sum path is [1 -> 3 -> 5 -> 9] having sum 18.\r\n\r\n\r\nIn case multiple paths exists with the maximum sum, the solution can return any one of them.\r\n\r\nInput:\r\n\r\n\t\t\t  -1\r\n\t\t\t/\t \\\r\n\t\t  /\t\t   \\\r\n\t\t 2\t\t   -3\r\n\t   /   \\\t\t \\\r\n\t  /\t\t\\\t\t  \\\r\n\t 4\t\t-5\t\t  -6\r\n\t  \\\t\t\t\t  /\r\n\t   \\\t\t\t /\r\n\t   -7\t\t\t8\r\n\r\nOutput: [-1, 2, 4, -7] or [-1, -3, -6, 8]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Sum Path Binary Tree II",
    "link": "https://www.techiedelight.com/?problem=MaximumSumPathBinaryTreeII",
    "category": "Binary Tree",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumSumPathBinaryTreeII/MaximumSumPathBinaryTreeII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the maximum sum of a path between any two leaves in the binary tree. You may assume that the binary tree is not skewed and contains at-least two nodes.\r\n\r\nInput:\r\n\r\n\t\t  1\r\n\t\t/   \\\r\n\t   /\t \\\r\n\t  2\t\t  3\r\n\t   \\\t / \\\r\n\t   -4   5   6\r\n\t\t   / \\\r\n\t\t  7   8\r\n\r\nOutput: 22\r\n\r\nExplanation: The maximum sum path between two leaves is [8, 5, 3, 6].\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Sum Path Binary Tree III",
    "link": "https://www.techiedelight.com/?problem=MaximumSumPathBinaryTreeIII",
    "category": "Binary Tree",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumSumPathBinaryTreeIII/MaximumSumPathBinaryTreeIII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a non-empty binary tree, return the maximum path sum between any two nodes in the binary tree. The path can start and end at any node in the tree and need not go through the root.\r\n\r\nInput:\r\n\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  10\r\n\t   / \\\t\t / \\\r\n\t  /\t  \\\t\t/\t\\\r\n\t -1\t  -4   -5\t -6\r\n\t\t  /\t  / \\\r\n\t\t /\t /\t \\\r\n\t\t3\t7\t  4\r\n\t\t\t \\\r\n\t\t\t  \\\r\n\t\t\t  -2\r\n\r\nOutput: 15\r\n\r\nExplanation: The maximum sum path is [2, 1, 10, -5, 7].\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Binary Tree",
    "link": "https://www.techiedelight.com/?problem=ConstructBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructBinaryTree/ConstructBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven two integer arrays representing inorder and preorder traversal of a binary tree, construct and return the binary tree.\r\n\r\nInput:\r\n\r\ninorder[]  = [4, 2, 1, 7, 5, 8, 3, 6]\r\npreorder[] = [1, 2, 4, 3, 5, 7, 8, 6]\r\n\r\nOutput: Root of below binary tree\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Binary Tree II",
    "link": "https://www.techiedelight.com/?problem=ConstructBinaryTreeII",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructBinaryTreeII/ConstructBinaryTreeII.java",
    "problem": "/* START *//*\r\n\r\nGiven two integer arrays representing inorder and postorder traversal of a binary tree, construct and return the binary tree.\r\n\r\nInput:\r\n\r\ninorder[]   = [4, 2, 1, 7, 5, 8, 3, 6]\r\npostorder[] = [4, 2, 7, 8, 5, 6, 3, 1]\r\n\r\nOutput: Root of below binary tree\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Binary Tree III",
    "link": "https://www.techiedelight.com/?problem=ConstructBinaryTreeIII",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructBinaryTreeIII/ConstructBinaryTreeIII.java",
    "problem": "/* START *//*\r\n\r\nGiven two integer arrays representing inorder and level order traversal of a binary tree, construct and return the binary tree.\r\n\r\nInput:\r\n\r\ninorder[]    = [4, 2, 1, 7, 5, 8, 3, 6]\r\nlevelorder[] = [1, 2, 3, 4, 5, 6, 7, 8]\r\n\r\nOutput: Root of below binary tree\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Binary Tree IV",
    "link": "https://www.techiedelight.com/?problem=ConstructBinaryTreeIV",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructBinaryTreeIV/ConstructBinaryTreeIV.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array representing preorder traversal of a binary tree, and a boolean array that determines if the value at the corresponding index in the preorder sequence is a leaf node or an internal node, construct and return the full binary tree. A full binary tree is a tree in which every node has either 0 or 2 children.\r\n\r\nInput:\r\n\r\npreorder[] = [1, 2, 4, 5, 3, 6, 8, 9, 7]\r\nisLeaf[]   = [0, 0, 1, 1, 0, 0, 1, 1, 1]\t (1 represents a leaf node, and 0 represents an internal node)\r\n\r\nOutput: Root of below binary tree\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\\\t  / \\\r\n\t /\t \\ \t /\t \\\r\n\t4\t  5\t6\t  7\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 8\t   9\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Binary Tree V",
    "link": "https://www.techiedelight.com/?problem=ConstructBinaryTreeV",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructBinaryTreeV/ConstructBinaryTreeV.java",
    "problem": "/* START *//*\r\n\r\nGiven two integer arrays representing preorder and postorder traversal of a binary tree, construct and return the full binary tree. A full binary tree is a tree in which every node has either 0 or 2 children.\r\n\r\nInput:\r\n\r\npreorder[]  = [1, 2, 4, 5, 3, 6, 8, 9, 7]\r\npostorder[] = [4, 5, 2, 8, 9, 6, 7, 3, 1]\r\n\r\nOutput: Root of below binary tree\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\\\t  / \\\r\n\t /\t \\ \t /\t \\\r\n\t4\t  5\t6\t  7\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 8\t   9\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Binary Tree VI",
    "link": "https://www.techiedelight.com/?problem=ConstructBinaryTreeVI",
    "category": "Binary Tree",
    "tag": "Hashing",
    "lists": "TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructBinaryTreeVI/ConstructBinaryTreeVI.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array representing a binary tree, where the parent-child relationship is defined by (A[i], i) for every index i in the array A, build a binary tree out of it. The root node's value is i if -1 is present at index i in the array.\r\n\r\nInput: [-1, 0, 0, 1, 2, 2, 4, 4]\r\n\r\nOutput:\r\n\r\n\t\t   0\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   1\t   2\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t3\t\t4\t  5\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 6\t   7\r\n\r\nExplanation:\r\n\r\n\u00e2\u0080\u00a2 -1 is present at index 0, which implies that the binary tree root is node 0.\r\n\u00e2\u0080\u00a2 0 is present at index 1 and 2, which implies that the left and right children of node 0 are 1 and 2.\r\n\u00e2\u0080\u00a2 1 is present at index 3, which implies that the left or the right child of node 1 is 3.\r\n\u00e2\u0080\u00a2 2 is present at index 4 and 5, which implies that the left and right children of node 2 are 4 and 5.\r\n\u00e2\u0080\u00a2 4 is present at index 6 and 7, which implies that the left and right children of node 4 are 6 and 7.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Cartesian Tree",
    "link": "https://www.techiedelight.com/?problem=ConstructCartesianTree",
    "category": "Binary Tree, Heap",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructCartesianTree/ConstructCartesianTree.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array representing inorder traversal of a binary tree, construct and return a Cartesian tree from it. A Cartesian tree is a binary tree with the heap property: the parent of any node has a smaller value than the node itself.\r\n\r\nInput: [9, 3, 7, 1, 8, 12, 10, 20, 15, 18, 5]\r\n\r\nOutput: Root of below Cartesian tree\r\n\r\n\t\t   1\r\n\t\t /\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 3\t\t\t5\r\n\t/ \\\t\t   /\r\n   /   \\\t  /\r\n  9\t\t7\t 8\r\n\t\t\t  \\\r\n\t\t\t   \\\r\n\t\t\t\t10\r\n\t\t\t   /  \\\r\n\t\t\t  /\t   \\\r\n\t\t\t 12\t   15\r\n\t\t\t\t   / \\\r\n\t\t\t\t  /   \\\r\n\t\t\t\t 20\t  18\r\n\r\nExplanation: Refer below diagram\r\n\r\nhttps://techiedelight.com/practice/images/Cartesian-Tree.png\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct LCRS Binary Tree",
    "link": "https://www.techiedelight.com/?problem=ConstructLCRSBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructLCRSBinaryTree/ConstructLCRSBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, convert it into a Left\u00e2\u0080\u0093child right\u00e2\u0080\u0093sibling (LC\u00e2\u0080\u0093RS) binary tree.\r\n\r\nEach node in the LC\u00e2\u0080\u0093RS binary tree has two pointers: one to the node's left child and one to its next sibling in the original binary tree. So starting with the root, each node's leftmost child in the original tree is made its left child in the LC\u00e2\u0080\u0093RS binary tree, and its nearest sibling to the right in the original tree is made its right child in the binary tree.\r\n\r\nInput:\r\n\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  3\r\n\t  /  \\\t\t /\r\n\t /\t  \\\t\t/\r\n\t4\t   5   6\r\n\t\t\t  / \\\r\n\t\t\t /\t \\\r\n\t\t\t7\t  8\r\n\r\nOutput:\r\n\r\n\t\t\t1\r\n\t\t  /\r\n\t\t/\r\n\t   2\r\n\t /   \\\r\n   /\t   \\\r\n  4\t\t\t3\r\n   \\\t   /\r\n\t\\\t  /\r\n\t 5   6\r\n\t\t/\r\n\t   /\r\n\t  7\r\n\t   \\\r\n\t\t\\\r\n\t\t 8\r\n\r\nExplanation:\r\n\r\nRewrite the binary tree shown by putting the left child node to one level below its parents and by placing the sibling next to the left child at the same level.\r\n\r\n\t\t\t 1\r\n\t\t   /\r\n\t\t /\r\n\t\t2 ------- 3\r\n\t  /  \\\r\n\t /\t  \\\r\n\t4 ---- 5 -- 6\r\n\t\t\t   /\r\n\t\t\t  /\r\n\t\t\t 7 --- 8\r\n\r\nThen transform this tree into a LC-RS binary tree by turning each sibling 45\u00c2\u00b0 clockwise.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Expression Tree",
    "link": "https://www.techiedelight.com/?problem=ConstructExpressionTree",
    "category": "Binary Tree, Stack",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructExpressionTree/ConstructExpressionTree.java",
    "problem": "/* START *//*\r\n\r\nGiven a postfix expression, construct a binary expression tree from it and return its root. The binary expression tree is a binary tree whose leaves are operands, such as constants or variable names, and the other nodes contain operators.\r\n\r\nInput: ab+cde+**\r\nOutput: Root of the following expression tree.\r\n\r\n\t\t\t *\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t+\t\t  *\r\n\t   / \\\t\t / \\\r\n\t  /\t  \\\t\t/\t\\\r\n\t a\t   b   c\t +\r\n\t\t\t\t\t/ \\\r\n\t\t\t\t   /   \\\r\n\t\t\t\t  d\t\te\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Evaluate Expression Tree",
    "link": "https://www.techiedelight.com/?problem=EvaluateExpressionTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/EvaluateExpressionTree/EvaluateExpressionTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary expression tree representing algebraic expressions, evaluate it and return its value. A binary expression tree is a binary tree, where the operators are stored in the tree's internal nodes, and the leaves contain constants.\r\n\r\nAssume that each node of the binary expression tree has zero or two children. The supported operators are +(addition), \u00e2\u0088\u0092(subtraction), *(multiplication), \u00c3\u00b7(division) and ^(exponentiation).\r\n\r\nInput:\r\n\r\n\t\t\t(+)\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t   (*)\t\t (/)\r\n\t   / \\\t\t / \\\r\n\t  /\t  \\\t\t/\t\\\r\n\t(-)\t   5   21\t 7\r\n\t/ \\\r\n   /   \\\r\n  10\t5\r\n\r\nOutput: 28\r\n\r\nExplanation: The corresponding infix notation is ((10-5)*5)+(21/7) = 28 which can be produced by traversing the expression tree in an inorder fashion.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Symmetric Binary Tree",
    "link": "https://www.techiedelight.com/?problem=IsSymmetricBinaryTree",
    "category": "Binary Tree",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/IsSymmetricBinaryTree/IsSymmetricBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, check if the binary tree has a symmetric structure or not, i.e., left and right subtree mirror each other.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t\t\\\t  /\r\n\t\t \\\t /\r\n\t\t  4\t5\r\n\r\nOutput: true\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  / \\\t  / \\\r\n\t /   \\\t /\t \\\r\n\t7\t  8\t5\t  6\r\n\r\nOutput: true\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  /\r\n\t /\t\t /\r\n\t7\t\t5\r\n\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Complete Binary Tree",
    "link": "https://www.techiedelight.com/?problem=IsCompleteBinaryTree",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/IsCompleteBinaryTree/IsCompleteBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, check if it is a complete binary tree or not. A complete binary tree is a binary tree in which every level, except possibly the last, is filled, and all nodes are as far left as possible.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  / \\\t  /\r\n\t /\t \\\t /\r\n\t4\t 5\t6\r\n\r\nOutput: true\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t\t /\t \\\r\n\t4\t\t5\t  6\r\n\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Skewed Binary Tree",
    "link": "https://www.techiedelight.com/?problem=IsSkewedBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/IsSkewedBinaryTree/IsSkewedBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, check if each node has exactly one child or not. In other words, check whether the binary tree is skewed or not.\r\n\r\nInput:\r\n\t\t  1\r\n\t\t /\r\n\t\t/\r\n\t   2\r\n\t  /\r\n\t /\r\n\t3\r\n\r\nOutput: true\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Subtree",
    "link": "https://www.techiedelight.com/?problem=IsSubtree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/IsSubtree/IsSubtree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of two binary trees, x and y, determine whether y is a subtree of x. A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T.\r\n\r\nInput:\r\n\t\t   1\t\t\t\t\t\t3\r\n\t\t /   \\\t\t\t\t\t  /   \\\r\n\t\t/\t  \\\t\t\t\t\t /\t   \\\r\n\t   2\t   3\t\t\t\t6\t\t7\r\n\t  /\t\\\t  / \\\r\n\t /\t \\ \t /\t \\\r\n\t4\t  5\t6\t  7\r\n\r\nOutput: true\r\nExplanation: y is a subtree of x as y = x.right.\r\n\r\nInput:\r\n\t\t   1\t\t\t\t\t\t2\r\n\t\t /   \\\t\t\t\t\t  /   \\\r\n\t\t/\t  \\\t\t\t\t\t /\t   \\\r\n\t   2\t   3\t\t\t\t4\t\t5\r\n\t  /\t\\\t  / \\\t\t\t   /\r\n\t /\t \\ \t /\t \\\t\t\t  /\r\n\t4\t  5\t6\t  7\t\t\t 8\r\n\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Binary Tree Min Heap",
    "link": "https://www.techiedelight.com/?problem=IsBinaryTreeMinHeap",
    "category": "Binary Tree, Heap, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/IsBinaryTreeMinHeap/IsBinaryTreeMinHeap.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, check if it is a min-heap or not. In order words, the binary tree must be a complete binary tree where each node has a higher value than its parent's value.\r\n\r\nInput:\r\n\t\t   2\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   3\t   4\r\n\t  / \\\t  / \\\r\n\t /\t \\\t /\t \\\r\n\t5\t  6\t8\t  10\r\n\r\nOutput: true\r\n\r\nInput:\r\n\t\t   5\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   3\t   8\r\n\t  / \\\t  / \\\r\n\t /\t \\\t /\t \\\r\n\t2\t  4\t6\t  10\r\n\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Diameter of Binary Tree",
    "link": "https://www.techiedelight.com/?problem=DiameterOfBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DiameterOfBinaryTree/DiameterOfBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the diameter of binary tree. A binary tree diameter equals the total number of nodes on the longest path between any two leaves in it.\r\n\r\nInput:\r\n\r\n\t   1\r\n\t /   \\\r\n\t/\t  \\\r\n   2\t   3\r\n\t\\\t  / \\\r\n\t \\\t /\t \\\r\n\t  4\t5\t  6\r\n\t   / \\\r\n\t  /\t  \\\r\n\t 7\t   8\r\n\r\nOutput: 6\r\n\r\nExplanation: The nodes involved in binary tree's diameter are [4, 2, 1, 3, 5, 7]. Note that the diameter passes through the root node.\r\n\r\n\r\nInput:\r\n\r\n\t\t1\r\n\t\t \\\r\n\t\t  \\\r\n\t\t   2\r\n\t\t  / \\\r\n\t\t /\t \\\r\n\t\t3\t  4\r\n\t   / \\\t   \\\r\n\t  /\t  \\\t\t\\\r\n\t 5\t   6\t 7\r\n\r\nOutput: 5\r\n\r\nExplanation: The nodes involved in binary tree's diameter are [5, 3, 2, 4, 7]. Note that the diameter does not pass through the root node.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Diagonal Sum Binary Tree",
    "link": "https://www.techiedelight.com/?problem=DiagonalSumBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DiagonalSumBinaryTree/DiagonalSumBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the sum of all nodes for each diagonal having negative slope `\\`. Assume that the left and right child of a node makes a 45\u00e2\u0080\u0093degree angle with the parent.\r\n\r\nInput:\r\n\t\t\t\t 1\r\n\t\t\t .\t\t .\r\n\t\t   .\t\t   .\r\n\t\t 2\t\t\t\t 3\r\n\t   .\t\t\t   .\t.\r\n\t .\t\t\t\t .\t\t  .\r\n   4\t\t\t   5\t\t\t6\r\n\t\t\t\t .   .\r\n\t\t\t   .\t   .\r\n\t\t\t 7\t\t\t 8\r\n\r\nOutput: [10, 15, 11]\r\n\r\nExplanation: The binary tree has three diagonals - [1, 3, 6], [2, 5, 8], and [4, 7]. The sum of diagonals is 10, 15, and 11 respectively.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Postorder from Inorder and Preorder",
    "link": "https://www.techiedelight.com/?problem=PostorderFromInorderAndPreorder",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/PostorderFromInorderAndPreorder/PostorderFromInorderAndPreorder.java",
    "problem": "/* START *//*\r\n\r\nGiven two integer arrays representing inorder and preorder traversal of a binary tree, return the postorder traversal of the corresponding binary tree.\r\n\r\nInput:\r\n\r\ninorder[]  = [4, 2, 1, 7, 5, 8, 3, 6]\r\npreorder[] = [1, 2, 4, 3, 5, 7, 8, 6]\r\n\r\nOutput: [4, 2, 7, 8, 5, 6, 3, 1]\r\n\r\nExplanation: The inorder and preorder traversal represents the following binary tree.\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Preorder from Inorder and Postorder",
    "link": "https://www.techiedelight.com/?problem=PreorderFromInorderAndPostorder",
    "category": "Binary Tree, Stack",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/PreorderFromInorderAndPostorder/PreorderFromInorderAndPostorder.java",
    "problem": "/* START *//*\r\n\r\nGiven two integer arrays representing inorder and postorder traversal of a binary tree, return the preorder traversal of the corresponding binary tree.\r\n\r\nInput:\r\n\r\ninorder[]   = [4, 2, 1, 7, 5, 8, 3, 6]\r\npostorder[] = [4, 2, 7, 8, 5, 6, 3, 1]\r\n\r\nOutput: [1, 2, 4, 3, 5, 7, 8, 6]\r\n\r\nExplanation: The inorder and postorder traversal represents the following binary tree.\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t  \t /\t \\\r\n\t4\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Binary Trees with Same Inorder",
    "link": "https://www.techiedelight.com/?problem=BinaryTreesWithSameInorder",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/BinaryTreesWithSameInorder/BinaryTreesWithSameInorder.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array representing inorder sequence of a binary tree, return count of all possible binary trees having that same inorder traversal.\r\n\r\nInput: [1, 2, 3]\r\nOutput: 5\r\nExplanation: There are 5 binary trees with inorder traversal [1, 2, 3], as shown below:\r\n\r\n  1\t\t\t1\t\t  2\t\t\t3\t\t   3\r\n   \\\t\t \\\t\t / \\\t   /\t\t  /\r\n\t2\t\t  3\t\t1   3\t  1\t\t  \t 2\r\n\t \\\t\t /\t\t\t\t   \\\t\t/\r\n\t  3\t\t2\t\t\t\t\t2\t   1\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Independent Set Problem",
    "link": "https://www.techiedelight.com/?problem=MaximumIndependentSetProblem",
    "category": "Binary Tree, Dynamic Programming",
    "tag": "Algorithm, Recursive, Top-down",
    "lists": "TopClassic",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumIndependentSetProblem/MaximumIndependentSetProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the size of the Maximum Independent Set (MIS) in it.\r\n\r\nAn independent set is a set of nodes in a binary tree, no two of which are adjacent, i.e., there is no edge connecting any two. The size of an independent set is the total number of nodes it contains. The maximum independent set problem is finding an independent set of the largest possible size for a given binary tree.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   /\t   \\\r\n\t  2\t\t\t3\r\n\t   \\\t   / \\\r\n\t\t\\\t  /\t  \\\r\n\t\t 4\t 5\t   6\r\n\t\t\t/ \\\r\n\t\t   /   \\\r\n\t\t  7\t\t8\r\n\r\nOutput: 5\r\n\r\nExplanation: The Maximum Independent Set (MIS) is [1, 4, 6, 7, 8].\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Next Node at Same Level",
    "link": "https://www.techiedelight.com/?problem=NextNodeAtSameLevel",
    "category": "Binary Tree, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/NextNodeAtSameLevel/NextNodeAtSameLevel.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree and a tree node x, return the next node at the same level as the node x.\r\n\r\nFor example, consider the following binary tree.\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  / \\\t\t\\\r\n\t /\t \\\t\t \\\r\n\t4\t  5\t\t  6\r\n\t\t\t\t / \\\r\n\t\t\t\t/   \\\r\n\t\t\t   7\t 8\r\n\r\nInput: Node 2\r\nOutput: Node 3\r\nExplanation: The next node of 2 is node 3\r\n\r\nInput: Node 5\r\nOutput: Node 6\r\nExplanation: The next node of 5 is node 6\r\n\r\nInput: Node 8\r\nOutput: null\r\nExplanation: The next node of 8 doesn't exist.\r\n\r\nNote: The solution should return null if x is not the actual tree node.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Invert Alternate Levels",
    "link": "https://www.techiedelight.com/?problem=InvertAlternateLevels",
    "category": "Binary Tree, Queue, Stack",
    "tag": "Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/InvertAlternateLevels/InvertAlternateLevels.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a perfect binary tree, invert alternate levels of it.\r\n\r\nInput:\r\n\t\t\t\t\t1\r\n\t\t\t\t  /\t   \\\r\n\t\t\t   /\t\t \\\r\n\t\t\t/\t\t\t   \\\r\n\t\t  2\t\t\t\t\t 3\r\n\t\t/   \\\t\t\t\t/  \\\r\n\t  /\t\t  \\\t\t\t  /\t\t \\\r\n\t 4\t\t   5\t\t 6\t\t  7\r\n\t/ \\\t\t  / \\\t\t/ \\\t\t / \\\r\n   /   \\\t /   \\\t   /   \\\t/   \\\r\n  8\t\t9   10   11   12   13  14   15\r\n\r\nOutput:\r\n\t\t\t\t\t1\r\n\t\t\t\t  /\t   \\\r\n\t\t\t   /\t\t \\\r\n\t\t\t/\t\t\t   \\\r\n\t\t  3\t\t\t\t\t 2\r\n\t\t/   \\\t\t\t\t/  \\\r\n\t  /\t\t  \\\t\t\t  /\t\t \\\r\n\t 4\t\t   5\t\t 6\t\t  7\r\n\t/ \\\t\t  / \\\t\t/ \\\t\t / \\\r\n   /   \\\t /   \\\t   /   \\\t/   \\\r\n  15   14   13   12   11   10  9\t 8\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Subtrees with Same Node Value",
    "link": "https://www.techiedelight.com/?problem=SubtreesWithSameNodeValue",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SubtreesWithSameNodeValue/SubtreesWithSameNodeValue.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the count all subtrees in it such that every node in the subtree has the same value.\r\n\r\nInput:\r\n\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  /\t\t  / \\\r\n\t /\t\t /\t \\\r\n\t4\t\t5\t  6\r\n   /\t   / \\\t   \\\r\n  /\t\t  /   \\\t\t\\\r\n 4\t\t 5\t   5\t 7\r\n\r\nOutput: 6\r\n\r\nExplanation: Six subtrees have the same data, as shown below:\r\n\r\n\t 4\t\t   5\t\t4\t\t5\t\t5\t\t7\r\n\t/\t\t /   \\\r\n   /\t\t/\t  \\\r\n  4\t\t   5\t   5\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Split Binary Tree",
    "link": "https://www.techiedelight.com/?problem=SplitBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SplitBinaryTree/SplitBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, check if removing an edge can split the binary tree into two binary trees of equal size.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  / \\\t\t\\\r\n\t /\t \\\t \t \\\r\n\t4\t  5\t\t  7\r\n\r\nOutput: true\r\nExplanation: Removing the edge 1 \u00e2\u0080\u0094> 2 from the binary tree splits it into two binary trees of size 3.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t\t\t  / \\\r\n\t\t\t /\t \\\r\n\t\t\t5\t  6\r\n\t\t   / \\\r\n\t\t  /   \\\r\n\t\t 7\t   8\r\n\r\nOutput: false\r\nExplanation: There is no edge whose removal splits the binary tree into two equal-size binary trees.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Set Inorder Successor",
    "link": "https://www.techiedelight.com/?problem=SetInorderSuccessor",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SetInorderSuccessor/SetInorderSuccessor.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a special binary tree with each node containing an additional next pointer, set it to the inorder successor for all binary tree nodes.\r\n\r\nInput:\r\n\r\n\t\t\t 1(X)\r\n\t\t\t/\t \\\r\n\t\t   /\t  \\\r\n\t\t  /\t\t   \\\r\n\t\t2(X)\t  3(X)\r\n\t\t/\t\t  /  \\\r\n\t   /\t\t /\t  \\\r\n\t 4(X)\t   5(X)  6(X)\r\n\t\t\t   /  \\\r\n\t\t\t  /\t   \\\r\n\t\t\t7(X)  8(X)\r\n\r\nOutput:\r\n\r\n\t\t\t 1(7)\r\n\t\t\t/\t \\\r\n\t\t   /\t  \\\r\n\t\t  /\t\t   \\\r\n\t\t2(1)\t  3(6)\r\n\t\t/\t\t  /  \\\r\n\t   /\t\t /\t  \\\r\n\t 4(2)\t   5(8)  6(X)\r\n\t\t\t   /  \\\r\n\t\t\t  /\t   \\\r\n\t\t\t7(5)  8(3)\r\n\r\nExplanation:\r\n\r\n\u00e2\u0080\u00a2 The inorder successor of node 4 is node 2\r\n\u00e2\u0080\u00a2 The inorder successor of node 2 is node 1\r\n\u00e2\u0080\u00a2 The inorder successor of node 1 is node 7\r\n\u00e2\u0080\u00a2 The inorder successor of node 7 is node 5\r\n\u00e2\u0080\u00a2 The inorder successor of node 5 is node 8\r\n\u00e2\u0080\u00a2 The inorder successor of node 8 is node 3\r\n\u00e2\u0080\u00a2 The inorder successor of node 3 is node 6\r\n\u00e2\u0080\u00a2 The inorder successor of node 6 doesn't exist\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Vertical Sum Binary Tree",
    "link": "https://www.techiedelight.com/?problem=VerticalSumBinaryTree",
    "category": "Binary Tree, Linked List",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/VerticalSumBinaryTree/VerticalSumBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, return the sum of all nodes for each vertical level. In a vertical traversal, nodes of a binary tree are processed in vertical order from left to right. Assume that the left and right child makes a 45\u00e2\u0080\u0093degree angle with the parent.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /\t \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  \t\t /   \\\r\n\t \t  \t/\t  \\\r\n\t\t   5\t   6\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   7\t   8\r\n\r\nOutput: [9, 6, 11, 6]\r\n\r\nExplanation: The binary tree has four vertical levels:\r\n\r\n[2, 7]\r\n[1, 5]\r\n[3, 8]\r\n[6]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Leaf Traversal Binary Tree",
    "link": "https://www.techiedelight.com/?problem=LeafTraversalBinaryTree",
    "category": "Binary Tree, Linked List, Stack",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LeafTraversalBinaryTree/LeafTraversalBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of two binary trees, check whether the leaf traversals of both trees are the same or not.\r\n\r\nInput:\r\n\t\t   1\t\t\t\t\t\t1\r\n\t\t /   \\\t\t\t\t\t  /   \\\r\n\t\t/\t  \\\t\t\t\t\t /\t   \\\r\n\t   2\t   3\t\t\t\t2\t\t3\r\n\t  /\t\\\t  /\t\t\t\t\t \\\t   / \\\r\n\t /\t \\ \t /\t\t\t\t  \t  \\\t  /\t  \\\r\n\t4\t  5\t6\t\t\t\t \t   4 5\t   6\r\n\r\nOutput: true\r\nExplanation: The leaf traversal of both binary trees is [4, 5, 6].\r\n\r\nInput:\r\n\t\t   1\t\t\t\t\t\t1\r\n\t\t /   \\\t\t\t\t\t  /   \\\r\n\t\t/\t  \\\t\t\t\t\t /\t   \\\r\n\t   2\t   3\t\t\t\t2\t\t3\r\n\t  /\t\\\t\t\t\t\t   \t\t   / \\\r\n\t /\t \\\t\t\t  \t\t\t\t  /\t  \\\r\n\t4\t  5\t\t\t\t\t\t\t 4\t   5\r\n\r\nOutput: false\r\nExplanation: Both binary trees have different leaf traversals.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Link Nodes Binary Tree",
    "link": "https://www.techiedelight.com/?problem=LinkNodesBinaryTree",
    "category": "Binary Tree, Linked List",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LinkNodesBinaryTree/LinkNodesBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a special binary tree with each node containing an additional next pointer, link nodes at the same level using the next pointer in the form of a linked list like structure.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  / \\\t\t\\\r\n\t /\t \\\t \t \\\r\n\t4\t  5\t\t  6\r\n\t\t\t\t / \\\r\n\t\t\t\t/\t\\\r\n\t\t\t   7\t 8\r\n\r\nOutput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2 ----> 3\r\n\t  / \\\t\t\\\r\n\t /\t \\\t \t \\\r\n\t4 --> 5 ----> 6\r\n\t\t\t\t / \\\r\n\t\t\t\t/\t\\\r\n\t\t\t   7 --> 8\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Ternary Tree to Doubly Linked List",
    "link": "https://www.techiedelight.com/?problem=TernaryTreeToDoublyLinkedList",
    "category": "Binary Tree, Linked List",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TernaryTreeToDoublyLinkedList/TernaryTreeToDoublyLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a ternary tree, in-place convert the ternary tree into a doubly-linked list. A ternary tree is a tree data structure in which each node has three child nodes distinguished as left, mid, and right.\r\n\r\nThe conversion should be done such that the left child pointer of a ternary tree node should act as a previous pointer for the doubly linked list node, the right child pointer should serve as the next pointer for the doubly linked list node, and the mid-child pointer should point to nothing. The conversion should be done by only exchanging ternary tree node pointers without allocating any extra memory for the nodes of the doubly linked list.\r\n\r\nThe solution should push the root node before its children into the doubly linked list and each node should recursively follows this in the subtree rooted at its left child, mid-child, and right child, in that order.\r\n\r\nInput:\r\n\t\t\t  1\r\n\t\t\t/ | \\\r\n\t\t  /   |   \\\r\n\t\t/\t  |\t\t\\\r\n\t   2\t  9\t\t 12\r\n\t / | \\   / \\\t |  \\\r\n\t3  6  8 10  11  13   16\r\n\t|   \\\t\t   /  \\   |\r\n\t4\t 7\t\t  14  15  17\r\n\t \\\r\n\t  5\r\n\r\nOutput: 1 \u00e2\u0087\u0094 2 \u00e2\u0087\u0094 3 \u00e2\u0087\u0094 4 \u00e2\u0087\u0094 5 \u00e2\u0087\u0094 6 \u00e2\u0087\u0094 7 \u00e2\u0087\u0094 8 \u00e2\u0087\u0094 9 \u00e2\u0087\u0094 10 \u00e2\u0087\u0094 11 \u00e2\u0087\u0094 12 \u00e2\u0087\u0094 13 \u00e2\u0087\u0094 14 \u00e2\u0087\u0094 15 \u00e2\u0087\u0094 16 \u00e2\u0087\u0094 17 \u00e2\u0087\u0094 null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Extract Binary Tree Leaves",
    "link": "https://www.techiedelight.com/?problem=ExtractBinaryTreeLeaves",
    "category": "Binary Tree, Linked List",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ExtractBinaryTreeLeaves/ExtractBinaryTreeLeaves.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, extract all its leaves into a doubly-linked list, i.e., remove all leaf nodes from the binary tree and construct a doubly linked list out of them.\r\n\r\nThe solution should process the left child before its right child for each tree node. The extraction should be by rearranging the pointers of the binary tree such that the left pointer should act as the previous pointer, and the right pointer should serve as the next pointer for the doubly linked list node.\r\n\r\nInput:\r\n\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  3\r\n\t   / \\\t\t / \\\r\n\t  /\t  \\\t\t/\t\\\r\n\t 4\t   5   6\t 7\r\n\t/ \\\t\t  / \\\r\n   /   \\\t /   \\\r\n  8\t\t9\t10\t 11\r\n\r\nOutput:\r\n\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  3\r\n\t   /\t\t /\r\n\t  /\t\t\t/\r\n\t 4\t\t   6\r\n\r\n8 \u00e2\u0087\u0094 9 \u00e2\u0087\u0094 5 \u00e2\u0087\u0094 10 \u00e2\u0087\u0094 11 \u00e2\u0087\u0094 7\r\n\r\nThe solution should return the head of the doubly-linked list and detach the tree from all its leaf nodes. Assume that the binary tree contains at least two nodes.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Binary Tree to Doubly Linked List",
    "link": "https://www.techiedelight.com/?problem=BinaryTreeToDoublyLinkedList",
    "category": "Binary Tree, Linked List",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/BinaryTreeToDoublyLinkedList/BinaryTreeToDoublyLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, in-place convert the binary tree into a doubly-linked list.\r\n\r\nThe conversion should be done such that the left and right pointers of binary tree nodes should act as previous and next pointers in a doubly-linked list, and the doubly linked list nodes should follow the same order of nodes as inorder traversal on the tree.\r\n\r\nInput:\r\n\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  3\r\n\t   / \\\t\t / \\\r\n\t  /\t  \\\t\t/\t\\\r\n\t 4\t   5   6\t 7\r\n\r\nOutput: 4 \u00e2\u0087\u0094 2 \u00e2\u0087\u0094 5 \u00e2\u0087\u0094 1 \u00e2\u0087\u0094 6 \u00e2\u0087\u0094 3 \u00e2\u0087\u0094 7\r\n\r\nThe solution should return the head of the doubly-linked list constructed from the tree nodes.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Binary Tree to Doubly Linked List II",
    "link": "https://www.techiedelight.com/?problem=BinaryTreeToDoublyLinkedListII",
    "category": "Binary Tree, Linked List, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/BinaryTreeToDoublyLinkedListII/BinaryTreeToDoublyLinkedListII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, in-place convert the binary tree into a doubly-linked list in the spiral order.\r\n\r\nThe conversion should be done so that the left child pointer of a binary tree node should act as a previous pointer for a doubly-linked list node, and the right child pointer should act as the next pointer for a doubly-linked list node. The conversion should also be done by only exchanging the pointers without allocating any memory for the doubly linked list's nodes.\r\n\r\nInput:\r\n\t\t\t 1\r\n\t\t   /   \\\r\n\t\t /\t\t \\\r\n\t\t2\t\t  3\r\n\t   / \\\t\t / \\\r\n\t  /\t  \\\t\t/\t\\\r\n\t 4\t   5   6\t 7\r\n\r\nOutput: 1 \u00e2\u0087\u0094 2 \u00e2\u0087\u0094 3 \u00e2\u0087\u0094 7 \u00e2\u0087\u0094 6 \u00e2\u0087\u0094 5 \u00e2\u0087\u0094 4\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Linked List to Complete Binary Tree",
    "link": "https://www.techiedelight.com/?problem=LinkedListToCompleteBinaryTree",
    "category": "Binary Tree, Linked List, Queue",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/LinkedListToCompleteBinaryTree/LinkedListToCompleteBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, construct a complete binary tree out of it. Assume that the order of elements present in the linked list is the same as that in the complete tree's array representation. i.e., for a tree node at position i (position starting from 1) in the linked list, the left child is present at the position 2\u00c3\u0097i, and the right child is present at the position 2\u00c3\u0097i + 1.\r\n\r\nInput: 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> None\r\nOutput:\r\n\r\n\t\t\t1\r\n\t\t  /   \\\r\n\t\t /\t   \\\r\n\t\t2\t\t3\r\n\t   / \\\t   /\r\n\t  /\t  \\\t  /\r\n\t 4\t   5 6\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Ancestor Matrix",
    "link": "https://www.techiedelight.com/?problem=AncestorMatrix",
    "category": "Binary Tree, Matrix",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/AncestorMatrix/AncestorMatrix.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree whose nodes are labeled from 0 to N-1, construct and return an N \u00c3\u0097 N ancestor matrix from the binary tree. An ancestor matrix is a boolean matrix, whose cell (i, j) is true if i is an ancestor of j in the binary tree.\r\n\r\nInput:\r\n\t\t   4\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   3\t   1\r\n\t  / \\\t\t\\\r\n\t /   \\\t\t \\\r\n\t2\t  0\t\t  5\r\n\r\nOutput:\r\n\r\n[\r\n\t[0, 0, 0, 0, 0, 0],\r\n\t[0, 0, 0, 0, 0, 1],\r\n\t[0, 0, 0, 0, 0, 0],\r\n\t[1, 0, 1, 0, 0, 0],\r\n\t[1, 1, 1, 1, 0, 1],\r\n\t[0, 0, 0, 0, 0, 0]\r\n]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct BST",
    "link": "https://www.techiedelight.com/?problem=ConstructBST",
    "category": "BST",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructBST/ConstructBST.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of distinct integers, construct and return a binary search tree (BST) out of them. The solution should insert keys into the BST in the same order as they appear in the array.\r\n\r\nInput: [15, 10, 20, 8, 12, 16, 25]\r\n\r\nOutput:\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Insert key into BST",
    "link": "https://www.techiedelight.com/?problem=InsertKeyIntoBST",
    "category": "BST",
    "tag": "Algorithm, Recursive",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/InsertKeyIntoBST/InsertKeyIntoBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and an integer k, insert k into the BST. The solution should not rearrange the existing tree nodes and insert a new node with the given key at its correct position in BST.\r\n\r\nInput: Below BST, k = 16\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t\t \\\r\n   /\t\\\t \t  \\\r\n  8\t\t12\t\t  25\r\n\r\nOutput:\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\nYou may assume that the key does not exist in the BST.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Search key in BST",
    "link": "https://www.techiedelight.com/?problem=SearchKeyInBST",
    "category": "BST",
    "tag": "Algorithm, Recursive",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/SearchKeyInBST/SearchKeyInBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a key, search for the node with that key in the BST.\r\n\r\nFor example, consider the following BST.\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\nInput: key = 25\r\nOutput: true\r\n\r\nInput: key = 5\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Delete key from BST",
    "link": "https://www.techiedelight.com/?problem=DeleteKeyFromBST",
    "category": "BST",
    "tag": "Algorithm, Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DeleteKeyFromBST/DeleteKeyFromBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a key, delete the node with that key in the BST if it exists, and return the root node.\r\n\r\n\u00e2\u0080\u00a2 When deleting a node with no children, the solution should remove the node from the tree.\r\n\u00e2\u0080\u00a2 When deleting a node with one child, the solution should remove the node and replace it with its child.\r\n\u00e2\u0080\u00a2 When deleting a node with two children, the solution should swap the node's value with either its inorder successor or inorder predecessor, and then call delete on the inorder successor or inorder predecessor. This node will have at-most one child and can be deleted according to one of the two simpler cases above.\r\n\r\nFor example, consider the following BST.\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\nInput: key = 25\r\nOutput:\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /\r\n   /\t\\\t /\r\n  8\t\t12\t16\r\n\r\nInput: key = 15\r\nOutput:\r\n\r\n\t\t  12\t\t\t\t\t  16\r\n\t\t/\t \\\t\t\t  \t\t/\t \\\r\n\t   /\t  \\\t\t\t \t   /\t  \\\r\n\t  /\t\t   \\\t\t or   /\t\t   \\\r\n\t 10\t\t   20\t\t   \t 10\t\t   20\r\n\t/\t\t  /  \\\t\t  \t/  \\\t\t \\\r\n   /\t\t /\t  \\\t\t   /\t\\\t \t  \\\r\n  8\t\t\t16\t  25\t  8\t\t12\t\t  25\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Same BSTs",
    "link": "https://www.techiedelight.com/?problem=IsSameBSTs",
    "category": "BST",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/IsSameBSTs/IsSameBSTs.java",
    "problem": "/* START *//*\r\n\r\nGiven two integer arrays, X and Y, representing a set of BST keys, check if they represent the same BSTs or not without building the tree. Assume that the keys are inserted into the BST in the same order as they appear in the array.\r\n\r\nInput:\r\n\r\nX[] = [15, 25, 20, 22, 30, 18, 10, 8, 9, 12, 6]\r\nY[] = [15, 10, 12, 8, 25, 30, 6, 20, 18, 9, 22]\r\n\r\nOutput: true\r\nExplanation: Both arrays represent the same BSTs, as shown below:\r\n\r\n\t\t\t\t15\r\n\t\t\t  /   \\\r\n\t\t\t/\t\t\\\r\n\t\t  /\t\t\t  \\\r\n\t\t 10\t\t\t   25\r\n\t   /   \\\t\t /   \\\r\n\t  /\t\t\\\t\t/\t  \\\r\n\t 8\t\t12 \t   20\t  30\r\n\t/ \\\t\t\t  /  \\\r\n   /   \\\t\t /\t  \\\r\n  6\t\t9\t\t18\t  22\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Inorder Predecessor BST",
    "link": "https://www.techiedelight.com/?problem=InorderPredecessorBST",
    "category": "BST",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/InorderPredecessorBST/InorderPredecessorBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a tree node x, find the inorder predecessor of x in the BST. An inorder predecessor of a tree node is the previous node in the inorder traversal of the tree.\r\n\r\nFor example, consider the following tree:\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\nInput: Node 10\r\nOutput: Node 8\r\n\r\nInput: Node 12\r\nOutput: Node 10\r\n\r\n\u00e2\u0080\u00a2 If the node does not lie in the BST, return the previous greater node (if any) present in the BST.\r\n\r\nInput: Node 18\r\nOutput: Node 16\r\n\r\n\u00e2\u0080\u00a2 If the node does not lie in the BST and the previous greater node also does not exist, the solution should return null.\r\n\r\nInput: Node 8\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Inorder Successor BST",
    "link": "https://www.techiedelight.com/?problem=InorderSuccessorBST",
    "category": "Binary Tree, BST",
    "tag": "Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/InorderSuccessorBST/InorderSuccessorBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a tree node x, find the inorder successor of x in the BST. An inorder successor of a tree node is the next node in the inorder traversal of the tree.\r\n\r\nFor example, consider the following tree:\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\nInput: Node 10\r\nOutput: Node 12\r\n\r\nInput: Node 12\r\nOutput: Node 15\r\n\r\n\u00e2\u0080\u00a2 If the node does not lie in the BST, return the next greater node (if any) present in the BST.\r\n\r\nInput: Node 5\r\nOutput: Node 8\r\n\r\n\u00e2\u0080\u00a2 If the node does not lie in the BST and the next greater node also does not exist, the solution should return null.\r\n\r\nInput: Node 30\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Lowest Common Ancestor II",
    "link": "https://www.techiedelight.com/?problem=LowestCommonAncestorII",
    "category": "BST",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/LowestCommonAncestorII/LowestCommonAncestorII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and two tree nodes, x and y, return the lowest common ancestor (LCA) of x and y in the BST.\r\n\r\nThe lowest common ancestor (LCA) of two nodes x and y in a BST is the lowest (i.e., deepest) node that has both x and y as descendants, where each node can be a descendant of itself (so if x is reachable from w, w is the LCA). In other words, the LCA of x and y is the shared ancestor of x and y that is located farthest from the root.\r\n\r\nFor example, consider the following BST.\r\n\r\n\t\t\t\t15\r\n\t\t\t  /   \\\r\n\t\t\t/\t\t\\\r\n\t\t  /\t\t\t  \\\r\n\t\t 10\t\t\t   25\r\n\t   /   \\\t\t /   \\\r\n\t  /\t\t\\\t\t/\t  \\\r\n\t 8\t\t12 \t   20\t  30\r\n\t/ \\\t\t\t  /  \\\r\n   /   \\\t\t /\t  \\\r\n  6\t\t9\t\t18\t  22\r\n\r\nInput: x = Node 6, y = Node 12\r\nOutput: Node 10\r\nExplanation: The common ancestors of nodes 6 and 12 are 10 and 15. Out of nodes 10 and 15, the LCA is 10 as it is farthest from the root.\r\n\r\nInput: x = Node 10, y = Node 12\r\nOutput: Node 10\r\nExplanation: Node 12 itself is descendant of node 10 (and node 10 can be a descendant of itself).\r\n\r\nInput: x = Node 20, y = Node 6\r\nOutput: Node 15\r\n\r\nInput: x = Node 30, y = Node 30\r\nOutput: Node 30\r\n\r\nNote: The solution should return null if either x or y is not the actual node in the tree.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Kth Smallest Node BST",
    "link": "https://www.techiedelight.com/?problem=KthSmallestNodeBST",
    "category": "BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/KthSmallestNodeBST/KthSmallestNodeBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a positive number k, find the k'th smallest node in the BST.\r\n\r\nFor example, consider the following BST.\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\nInput: k = 4\r\nOutput: Node 15\r\n\r\nInput: k = 6\r\nOutput: Node 20\r\n\r\nThe solution should return null if k is more than number of nodes in the BST.\r\n\r\nInput: k = 8\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Kth Largest Node BST",
    "link": "https://www.techiedelight.com/?problem=KthLargestNodeBST",
    "category": "BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "TopLiked",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/KthLargestNodeBST/KthLargestNodeBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a positive number k, find the k'th largest node in the BST.\r\n\r\nFor example, consider the following BST.\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\nInput: k = 4\r\nOutput: Node 15\r\n\r\nInput: k = 2\r\nOutput: Node 20\r\n\r\nThe solution should return null if k is more than number of nodes in the BST.\r\n\r\nInput: k = 8\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Floor and Ceil II",
    "link": "https://www.techiedelight.com/?problem=FloorAndCeilII",
    "category": "BST",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/FloorAndCeilII/FloorAndCeilII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a tree node x, find the floor and ceiling of node x in the BST. If node x lies in the BST, then both floor and ceil are equal to that node; otherwise, the ceil is equal to the next greater node (if any) in the BST, and the floor is equal to the previous greater node (if any) in the BST.\r\n\r\nThe solution should return the (floor, ceil) pair. If the floor or ceil doesn't exist, consider it to be null.\r\n\r\nFor example, consider the following BST.\r\n\r\n\t\t  8\r\n\t\t/\t\\\r\n\t   /\t \\\r\n\t  /\t\t  \\\r\n\t 4\t\t  10\r\n\t/ \\\t\t /  \\\r\n   /   \\\t/\t \\\r\n  2\t\t6  9\t 12\r\n\r\nInput: Node 7\r\nOutput: (Node 6, Node 8)\r\nExplanation: The floor of node 7 is node 6, and ceil is node 8.\r\n\r\nInput: Node 9\r\nOutput: (Node 9, Node 9)\r\nExplanation: Node 9 lies in the BST. Hence both floor and ceil are equal to node 9.\r\n\r\nInput: Node 1\r\nOutput: (null, Node 2)\r\nExplanation: The floor of node 1 doesn't exist and ceil is node 2.\r\n\r\nInput: Node 15\r\nOutput: (Node 12, null)\r\nExplanation: The floor of node 15 is node 12 and its ceil doesn't exist.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "2 Sum BST",
    "link": "https://www.techiedelight.com/?problem=2SumBST",
    "category": "BST",
    "tag": "Depth-First Search, Hashing, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/2SumBST/2SumBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a target, check if there exists a pair of nodes in the BST with their sum equal to the target.\r\n\r\nFor example, consider the following BST.\r\n\r\n\t\t  8\r\n\t\t/\t\\\r\n\t   /\t \\\r\n\t  /\t\t  \\\r\n\t 4\t\t  10\r\n\t/ \\\t\t /  \\\r\n   /   \\\t/\t \\\r\n  2\t\t6  9\t 12\r\n\r\nInput: target = 20\r\nOutput: true\r\nExplanation: Node 8 and 12 sums to target 20\r\n\r\nInput: target = 14\r\nOutput: true\r\nExplanation: Node 6 and 8 (or Node 4 and 10) sums to target 14\r\n\r\nInput: target = 25\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "2 Sum BST II",
    "link": "https://www.techiedelight.com/?problem=2SumBSTII",
    "category": "BST",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/2SumBSTII/2SumBSTII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a target, return a pair of nodes in the BST such that their sum is equal to the target. The solution can return pair in any order.\r\n\r\nFor example, consider the following BST.\r\n\r\n\t\t  8\r\n\t\t/\t\\\r\n\t   /\t \\\r\n\t  /\t\t  \\\r\n\t 4\t\t  10\r\n\t/ \\\t\t /  \\\r\n   /   \\\t/\t \\\r\n  2\t\t6  9\t 12\r\n\r\nInput: target = 20\r\nOutput: (Node 8, Node 12)\r\n\r\n\u00e2\u0080\u00a2 Each input can have multiple solutions. The output should match with either one of them.\r\n\r\nInput: target = 14\r\nOutput: (Node 6, Node 8) or (Node 4, Node 10)\r\n\r\n\u00e2\u0080\u00a2 If no pair with the given sum exists, the solution should return null.\r\n\r\nInput: target = 25\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "3 Sum BST",
    "link": "https://www.techiedelight.com/?problem=3SumBST",
    "category": "BST, Linked List",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/3SumBST/3SumBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a target, return a triplet of nodes in the BST such that their sum is equal to the target. The solution can return triplet in any order.\r\n\r\nInput: target = 20\r\n\r\n\t\t  10\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t-15\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n -40\t 3  15\t  50\r\n\r\nOutput: [Node -40, Node 10, Node 50]\r\n\r\n\r\nInput: target = 5\r\n\r\n\t 2\r\n\t/ \\\r\n   /   \\\r\n  1\t\t3\r\n\r\nOutput: []\r\n\r\n\r\nEach input can have multiple solutions. The output should match with either one of them.\r\n\r\nInput: target = 10\r\n\r\n\t\t  5\r\n\t\t/\t\\\r\n\t   /\t \\\r\n\t  /\t\t  \\\r\n\t 2\t\t   7\r\n\t/ \\\t\t  / \\\r\n   /   \\\t /\t \\\r\n  1\t\t3   8\t  9\r\n\r\nOutput: [Node 2, Node 5, Node 3] or [Node 7, Node 2, Node 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Transform BST",
    "link": "https://www.techiedelight.com/?problem=TransformBST",
    "category": "BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TransformBST/TransformBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST), in-place modify the BST such that every node is updated to contain the sum of all greater keys present in the BST.\r\n\r\nInput:\r\n\r\n\t\t  5\r\n\t\t/\t\\\r\n\t   /\t \\\r\n\t  /\t\t  \\\r\n\t 3\t\t   8\r\n\t/ \\\t\t  / \\\r\n   /   \\\t /\t \\\r\n  2\t\t4   6\t 10\r\n\r\nOutput:\r\n\r\n\t\t  29\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 36\t\t   18\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  38\t33\t24\t  10\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Truncate BST",
    "link": "https://www.techiedelight.com/?problem=TruncateBST",
    "category": "BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TruncateBST/TruncateBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a range of BST keys, remove nodes from the BST that have keys outside the given range.\r\n\r\nInput: low = 9, high = 12\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\nOutput:\r\n\r\n\t 10\r\n\t   \\\r\n\t\t\\\r\n\t\t12\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Preorder Sequence of BST",
    "link": "https://www.techiedelight.com/?problem=IsPreorderSequenceOfBST",
    "category": "BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/IsPreorderSequenceOfBST/IsPreorderSequenceOfBST.java",
    "problem": "/* START *//*\r\n\r\nGiven a distinct sequence of keys, check if it represents a preorder traversal of a binary search tree (BST).\r\n\r\nInput : [15, 10, 8, 12, 20, 16, 25]\r\nOutput: true\r\nExplanation: The following BST can be constructed from the above sequence and it has the same preorder traversal:\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Skewed BST",
    "link": "https://www.techiedelight.com/?problem=IsSkewedBST",
    "category": "Array, BST",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/IsSkewedBST/IsSkewedBST.java",
    "problem": "/* START *//*\r\n\r\nGiven a distinct sequence of keys representing preorder traversal of a binary search tree (BST), determine whether the sequence represents a skewed BST.\r\n\r\nInput : [15, 30, 25, 18, 20]\r\nOutput: true\r\nExplanation: The preorder traversal represents the following skewed BST:\r\n\r\n\t\t 15\r\n\t\t   \\\r\n\t\t\t\\\r\n\t\t\t 30\r\n\t\t\t/\r\n\t\t   /\r\n\t\t  25\r\n\t\t /\r\n\t\t/\r\n\t   18\r\n\t\t\\\r\n\t\t \\\r\n\t\t 20\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Nodes Within a Range in BST",
    "link": "https://www.techiedelight.com/?problem=NodesWithinARangeInBST",
    "category": "BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/NodesWithinARangeInBST/NodesWithinARangeInBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a range of BST keys, return the count of BST nodes that lie within a given range.\r\n\r\nInput: Below BST, low = 12, high = 20\r\n\r\n\t\t\t\t15\r\n\t\t\t  /\t   \\\r\n\t\t\t/\t\t \\\r\n\t\t  /\t\t\t   \\\r\n\t\t 10\t\t\t\t 25\r\n\t   /\t\\\t\t   /\t\\\r\n\t  /\t\t \\\t\t  /\t\t \\\r\n\t 8\t\t 12\t\t 20\t\t 30\r\n\t/ \\\t\t\t\t/  \\\r\n   /   \\\t\t   /\t\\\r\n  6\t\t9\t\t  18\t22\r\n\r\nOutput: 4\r\nExplanation: The BST nodes in range [12, 20] are 12, 15, 18, and 20.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Subtrees Within a Range in BST",
    "link": "https://www.techiedelight.com/?problem=SubtreesWithinARangeInBST",
    "category": "BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SubtreesWithinARangeInBST/SubtreesWithinARangeInBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST) and a range of BST keys, return the count of subtrees in the BST whose nodes lie within the given range.\r\n\r\nInput: Below BST, low = 5, high = 20\r\n\r\n\t\t\t\t15\r\n\t\t\t  /\t   \\\r\n\t\t\t/\t\t \\\r\n\t\t  /\t\t\t   \\\r\n\t\t 10\t\t\t\t 25\r\n\t   /\t\\\t\t   /\t\\\r\n\t  /\t\t \\\t\t  /\t\t \\\r\n\t 8\t\t 12\t\t 20\t\t 30\r\n\t/ \\\t\t\t\t/  \\\r\n   /   \\\t\t   /\t\\\r\n  6\t\t9\t\t  18\t22\r\n\r\nOutput: 6\r\nExplanation: The total number of subtrees with nodes in range [5, 20] is 6, as shown below:\r\n\r\n  6\t\t9\t\t  8\t\t\t   10\t\t 12\t\t 18\r\n\t\t\t\t/   \\\t\t  /  \\\r\n\t\t\t   6\t 9\t\t 8\t 12\r\n\t\t\t\t\t\t\t/ \\\r\n\t\t\t\t\t\t   6   9\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct BST from Preorder",
    "link": "https://www.techiedelight.com/?problem=ConstructBSTFromPreorder",
    "category": "BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructBSTFromPreorder/ConstructBSTFromPreorder.java",
    "problem": "/* START *//*\r\n\r\nGiven a sequence of distinct keys representing the preorder traversal of a binary search tree (BST), construct and return a BST out of the sequence.\r\n\r\nInput: [15, 10, 8, 12, 20, 16, 25]\r\n\r\nOutput:\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct BST from Postorder",
    "link": "https://www.techiedelight.com/?problem=ConstructBSTFromPostorder",
    "category": "BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructBSTFromPostorder/ConstructBSTFromPostorder.java",
    "problem": "/* START *//*\r\n\r\nGiven a sequence of distinct keys representing the postorder traversal of a binary search tree (BST), construct and return a BST out of the sequence.\r\n\r\nInput: [8, 12, 10, 16, 25, 20, 15]\r\n\r\nOutput:\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Complete BST Traversal",
    "link": "https://www.techiedelight.com/?problem=CompleteBSTTraversal",
    "category": "Array, BST, Stack",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CompleteBSTTraversal/CompleteBSTTraversal.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of distinct integers representing the level order traversal of a complete binary search tree (BST), return its elements in increasing order.\r\n\r\nInput : [15, 10, 20, 8, 12, 18, 25]\r\nOutput: [8, 10, 12, 15, 18, 20, 25]\r\n\r\nThe level order traversal corresponds to the following complete BST:\r\n\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Merge BSTs to Doubly Linked List",
    "link": "https://www.techiedelight.com/?problem=MergeBSTsToDoublyLinkedList",
    "category": "BST, Linked List",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MergeBSTsToDoublyLinkedList/MergeBSTsToDoublyLinkedList.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of two binary search trees, merge them into a doubly-linked list in sorted order.\r\n\r\nInput: Below BSTs\r\n\r\n\t  20\r\n\t /  \\\r\n   10\t30\r\n\t\t/  \\\r\n\t   25  100\r\n\r\n\t  50\r\n\t /  \\\r\n\t5\t70\r\n\r\nOutput: 5 \u00e2\u0087\u0094 10 \u00e2\u0087\u0094 20 \u00e2\u0087\u0094 25 \u00e2\u0087\u0094 30 \u00e2\u0087\u0094 50 \u00e2\u0087\u0094 70 \u00e2\u0087\u0094 100\r\n\r\nThe solution should return the head of the doubly-linked list constructed from the tree nodes.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Merge Height Balanced BSTs",
    "link": "https://www.techiedelight.com/?problem=MergeHeightBalancedBSTs",
    "category": "BST, Linked List",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MergeHeightBalancedBSTs/MergeHeightBalancedBSTs.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of two height-balanced binary search trees, in-place merge them into a single height-balanced binary search tree. For each node of a height-balanced tree, the difference between its left and right subtree height is at most 1.\r\n\r\nYou may assume that both BSTs contains distinct keys.\r\n\r\nInput: Below BSTs\r\n\r\n\t  20\r\n\t /  \\\r\n   10\t30\r\n\t\t/  \\\r\n\t   25  100\r\n\r\n\t  50\r\n\t /  \\\r\n\t5   70\r\n\r\nOutput:\r\n\r\n\t\t  30\r\n\t\t/\t\\\r\n\t  20\t 70\r\n\t /  \\\t/  \\\r\n\t10  25 50  100\r\n   /\r\n  5\r\n\r\nOR\r\n\r\n\t   25\r\n\t /\t  \\\r\n\t10\t   50\r\n   /  \\   /  \\\r\n  5   20 30  70\r\n\t\t\t   \\\r\n\t\t\t   100\r\n\r\nOR\r\n\r\nAny other possible representation.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Height Balanced BST",
    "link": "https://www.techiedelight.com/?problem=ConstructHeightBalancedBST",
    "category": "BST, Sorting",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructHeightBalancedBST/ConstructHeightBalancedBST.java",
    "problem": "/* START *//*\r\n\r\nGiven an unsorted distinct integer array that represents binary search tree (BST) keys, construct a height-balanced BST from it. For each node of a height-balanced tree, the difference between its left and right subtree height is at most 1.\r\n\r\nInput: [15, 10, 20, 8, 12, 16, 25]\r\n\r\nOutput:\r\n\r\n\t  15\r\n\t/\t \\\r\n   10\t  20\r\n  /  \\   /  \\\r\n 8   12 16  25\r\n\r\nOR\r\n\r\n\t  12\r\n\t/\t \\\r\n   10\t 20\r\n  /\t\t/  \\\r\n 8\t   16  25\r\n\t  /\r\n\t 15\r\n\r\nAny other possible representation.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Height Balanced BST II",
    "link": "https://www.techiedelight.com/?problem=ConstructHeightBalancedBSTII",
    "category": "BST, Linked List",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructHeightBalancedBSTII/ConstructHeightBalancedBSTII.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST), convert it into a height-balanced binary search tree. For a height-balanced binary search tree, the difference between the height of the left and right subtree of every node is never more than 1.\r\n\r\nInput: A BST\r\n\r\n\t\t\t  20\r\n\t\t\t /\r\n\t\t   15\r\n\t\t  /\r\n\t\t10\r\n\t   /\r\n\t  5\r\n\t/   \\\r\n   2\t 8\r\n\r\nOutput: Balanced BST\r\n\r\n\t\t  10\r\n\t\t/\t \\\r\n\t   5\t  15\r\n\t  / \\\t   \\\r\n\t 2   8\t   20\r\n\r\nOR\r\n\t\t  8\r\n\t\t/\t\\\r\n\t   5\t 10\r\n\t  / \t  \\\r\n\t 2   \t  15\r\n\t\t\t   \\\r\n\t\t\t   20\r\nOR\r\n\r\nAny other possible representation.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Height Balanced BST III",
    "link": "https://www.techiedelight.com/?problem=ConstructHeightBalancedBSTIII",
    "category": "BST, Linked List",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructHeightBalancedBSTIII/ConstructHeightBalancedBSTIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a sorted doubly-linked list of distinct integers, in-place convert it into a height-balanced binary search tree (BST) where the difference between its left and right subtree height is at most 1.\r\n\r\nThe conversion should be done such that the previous child pointer of a doubly-linked list node should act as a left pointer for a binary tree node, and the next child pointer should act as the right pointer for a binary tree node. The conversion should also be done by only exchanging the pointers without allocating any memory for the BST nodes.\r\n\r\nInput: 8 \u00e2\u0087\u0094 10 \u00e2\u0087\u0094 12 \u00e2\u0087\u0094 15 \u00e2\u0087\u0094 18 \u00e2\u0087\u0094 20 \u00e2\u0087\u0094 25\r\n\r\nOutput:\r\n\r\n\t  15\r\n\t/\t \\\r\n   10\t  20\r\n  /  \\   /  \\\r\n 8   12 18  25\r\n\r\nOR\r\n\r\n\t  12\r\n\t/\t \\\r\n   10\t 20\r\n  /\t\t/  \\\r\n 8\t   18  25\r\n\t  /\r\n\t 15\r\n\r\nAny other possible representation.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Convert Binary Tree to BST",
    "link": "https://www.techiedelight.com/?problem=ConvertBinaryTreeToBST",
    "category": "BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ConvertBinaryTreeToBST/ConvertBinaryTreeToBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, convert the binary tree into a binary search tree (BST) by keeping its original structure intact.\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\t  / \\\t  / \\\r\n\t /\t \\\t /\t \\\r\n\t4\t  5\t6\t  7\r\n\r\nOutput:\r\n\t\t   4\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   6\r\n\t  / \\\t  / \\\r\n\t /\t \\\t /\t \\\r\n\t1\t  3\t5\t  7\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Largest BST Size",
    "link": "https://www.techiedelight.com/?problem=LargestBSTSize",
    "category": "Binary Tree, BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/LargestBSTSize/LargestBSTSize.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, find the size of the largest binary search tree (BST) in the binary tree.\r\n\r\nInput:\r\n\t\t   10\r\n\t\t /\t  \\\r\n\t\t/\t   \\\r\n\t   15\t\t8\r\n\t  /\t \\\t   / \\\r\n\t /\t  \\   /\t  \\\r\n\t12\t  20 5\t   2\r\n\r\nOutput: 3\r\n\r\nExplanation: The largest BST in the binary tree is formed by a subtree rooted at node 15, having size 3:\r\n\r\n\t   15\r\n\t  /\t \\\r\n\t /\t  \\\r\n\t12\t  20\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is BST",
    "link": "https://www.techiedelight.com/?problem=IsBST",
    "category": "Binary Tree, BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/IsBST/IsBST.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, check if it is a binary search tree (BST) or not.\r\n\r\nInput:\r\n\t\t  15\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 10\t\t   20\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  8\t\t12\t16\t  25\r\n\r\nOutput: true\r\n\r\nInput:\r\n\t\t   1\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   2\t   3\r\n\r\nOutput: false\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Fix Binary Tree",
    "link": "https://www.techiedelight.com/?problem=FixBinaryTree",
    "category": "Binary Tree, BST",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/FixBinaryTree/FixBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree that is only one swap away from becoming a BST, convert the binary tree into a BST in a single traversal. Do nothing if the binary tree is already a BST.\r\n\r\nInput:\r\n\t\t   5\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   3\t   8\r\n\t  / \\\t  / \\\r\n\t /\t \\\t /\t \\\r\n\t4\t  2\t6\t 10\r\n\r\nOutput:\r\n\t\t   5\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   3\t   8\r\n\t  / \\\t  / \\\r\n\t /\t \\\t /\t \\\r\n\t2\t  4\t6\t 10\r\n\r\nExplanation: The binary tree can be converted into a BST by swapping node 2 with node 4.\r\n\r\n\r\nInput:\r\n\t\t   2\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   1\t   3\r\n\r\nOutput:\r\n\t\t   2\r\n\t\t /   \\\r\n\t\t/\t  \\\r\n\t   1\t   3\r\n\r\nExplanation: The binary tree is already a BST.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Optimal Cost to Construct BST",
    "link": "https://www.techiedelight.com/?problem=OptimalCostToConstructBST",
    "category": "BST, Dynamic Programming",
    "tag": "Bottom-up, Recursive, Top-down",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/OptimalCostToConstructBST/OptimalCostToConstructBST.java",
    "problem": "/* START *//*\r\n\r\nFind the optimal cost to construct a binary search tree (BST), where each key can repeat several times. You're given each key\u00e2\u0080\u0099s frequency in the same order as corresponding keys in the inorder traversal of a BST.\r\n\r\nTo construct a BST, determine if each given key already exists in the BST or not. The cost of finding a BST key is equal to the level of the key (if present in the BST).\r\n\r\nInput: freq[] = [25, 10, 20]\r\n\r\nNote: As freq[] follows inorder order (ascending keys), you may consider the index of freq[] as corresponding keys. i.e., key 0 occurs 25 times, key 1 occurs 10 times, and key 2 occurs 20 times.\r\n\r\nOutput: 95\r\nExplanation: The optimum BST is:\r\n\r\n    0(25\u00c3\u00971)              \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 1\r\n        \\\r\n         \\\r\n          \\\r\n          2(20\u00c3\u00972)        \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 2\r\n            /\r\n           /\r\n          /\r\n       1(10\u00c3\u00973)           \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 3\r\n\r\n25 lookups of the key 0 will cost 1 each.\r\n20 lookups of the key 2 will cost 2 each.\r\n10 lookups of the key 1 will cost 3 each.\r\n\r\nTherefore, the optimal cost of constructing BST is 25\u00c3\u00971 + 20\u00c3\u00972 + 10\u00c3\u00973 = 95\r\n\r\n\r\nOther possible BSTs are:\r\n\r\n1.\r\n\r\n    0(25\u00c3\u00971)               \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 1\r\n        \\\r\n         \\\r\n          \\\r\n         1(10\u00c3\u00972)          \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 2\r\n            \\\r\n             \\\r\n              \\\r\n           2(20\u00c3\u00973)        \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 3\r\n\r\nCost is 25 + 10\u00c3\u00972 + 20\u00c3\u00973 = 105\r\n\r\n\r\n2.\r\n\r\n            2(20\u00c3\u00971)      \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 1\r\n            /\r\n           /\r\n          /\r\n      1(10\u00c3\u00972)            \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 2\r\n        /\r\n       /\r\n      /\r\n  0(25\u00c3\u00973)                \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 3\r\n\r\nCost is 20 + 10\u00c3\u00972 + 25\u00c3\u00973 = 115\r\n\r\n\r\n3.\r\n\r\n       1(10\u00c3\u00971)            \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 1\r\n        /  \\\r\n       /    \\\r\n      /      \\\r\n  0(25\u00c3\u00972)    2(20\u00c3\u00972)      \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 2\r\n\r\nCost is 10 + 25\u00c3\u00972 + 20\u00c3\u00972 = 100\r\n\r\n\r\n4.\r\n\r\n          2(20\u00c3\u00971)        \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 1\r\n          /\r\n         /\r\n        /\r\n      0(25\u00c3\u00972)            \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 2\r\n        \\\r\n         \\\r\n          \\\r\n        1(10\u00c3\u00973)          \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 \u00e2\u0080\u0094 level 3\r\n\r\nCost is 20 + 25\u00c3\u00972 + 10\u00c3\u00973 = 100\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Probability",
    "link": "https://www.techiedelight.com/?problem=Probability",
    "category": "Bit Manipulation, C, Programming Puzzles",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/Probability/Probability.java",
    "problem": "/* START *//*\r\n\r\nGiven a function that produces either 0 or 1 each with 50% probability, generate 0 and 1 with 75% and 25% probability using that function.\r\n\r\nInput : foo() -> Function that returns 0 or 1 each with 50% probability.\r\nOutput: Return 0 and 1 with 75% and 25% probability using foo() function.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Probability II",
    "link": "https://www.techiedelight.com/?problem=ProbabilityII",
    "category": "C, Programming Puzzles",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ProbabilityII/ProbabilityII.java",
    "problem": "/* START *//*\r\n\r\nGiven a function that generates random numbers from 1 to 6 with equal probability, generate random numbers from 1 to 12 with equal probability using that function.\r\n\r\nInput : foo() -> Function that returns random numbers from 1 to 6 with equal probability.\r\nOutput: Return 1 to 12 with equal probability using foo() function.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Probability III",
    "link": "https://www.techiedelight.com/?problem=ProbabilityIII",
    "category": "C, Programming Puzzles",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ProbabilityIII/ProbabilityIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a function that produces either 0 or 1 each with 50% probability, generate 0, 1, and 2 with equal probability using that function.\r\n\r\nInput : foo() -> Function that returns 0 or 1 each with 50% probability.\r\nOutput: Return 0, 1, and 2 with equal probability using foo() function.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Probability IV",
    "link": "https://www.techiedelight.com/?problem=ProbabilityIV",
    "category": "C, Programming Puzzles",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ProbabilityIV/ProbabilityIV.java",
    "problem": "/* START *//*\r\n\r\nGiven a function that generates random numbers from 1 and 5 with equal probability, generate random numbers from 1 to 7 with equal probability using that function.\r\n\r\nInput : foo() -> Function that returns random numbers from 1 and 5 with equal probability.\r\nOutput: Return 1 to 7 with equal probability using foo() function.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Probability V",
    "link": "https://www.techiedelight.com/?problem=ProbabilityV",
    "category": "C, Programming Puzzles",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ProbabilityV/ProbabilityV.java",
    "problem": "/* START *//*\r\n\r\nGiven a function that generates random numbers from 1 to 5 with equal probability, generate 0 and 1 with equal probability using that function.\r\n\r\nInput : foo() -> Function that returns random numbers from 1 to 5 with equal probability.\r\nOutput: Return 0 and 1 with equal probability using foo() function.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Probability VI",
    "link": "https://www.techiedelight.com/?problem=ProbabilityVI",
    "category": "Array, Programming Puzzles",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ProbabilityVI/ProbabilityVI.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, return any one of its elements according to the given probabilities.\r\n\r\nInput:\r\n\r\nnums[] = [1, 2, 3, 4, 5]\r\nprobability[] = [30, 10, 20, 15, 25]\r\n\r\nOutput: The solution should return 1 with 30% probability, 2 with 10% probability, 3 with 20% probability, 4 with 15% probability, and 5 with 25% probability.\r\n\r\nAssume that the total probability sums to 100%.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Probability VII",
    "link": "https://www.techiedelight.com/?problem=ProbabilityVII",
    "category": "Programming Puzzles",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ProbabilityVII/ProbabilityVII.java",
    "problem": "/* START *//*\r\n\r\nGiven a biased function that returns 0 with `p` probability and 1 with `1-p` probability where p != (1-p), generate fair results from it.\r\n\r\nInput : biased() -> Function that returns 0 with 0.8 probability and 1 with 0.2 probability.\r\nOutput: Return 0 and 1 with equal probability using biased() function.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Probability VIII",
    "link": "https://www.techiedelight.com/?problem=ProbabilityVIII",
    "category": "Array",
    "tag": "Hashing",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ProbabilityVIII/ProbabilityVIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a non-empty integer array, return the index of the maximum occurring element with an equal probability.\r\n\r\nInput: nums[] = [4, 3, 6, 8, 4, 6, 2, 4, 5, 9, 7, 4]\r\nOutput: The solution should return any one of [0, 4, 7, 11] with equal probability.\r\nExplanation: The maximum occurring element, 4, occurs at index 0, 4, 7, and 11.\r\n\r\nIf there are two maximum occurring elements in the array, the solution should consider the first occurring maximum element.\r\n\r\nInput: nums[] = [4, 3, 6, 5, 2, 4, 1, 1]\r\nOutput: The solution should return any one of [0, 5] with equal probability.\r\nExplanation: The maximum occurring elements are 4 and 1. Element 4 appears before element 1, at indices 0 and 5.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Bipartite Graph",
    "link": "https://www.techiedelight.com/?problem=IsBipartiteGraph",
    "category": "Graph, Queue",
    "tag": "Algorithm, Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/IsBipartiteGraph/IsBipartiteGraph.java",
    "problem": "/* START *//*\r\n\r\nGiven an undirected graph, determine whether it is bipartite or not. A bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint sets U and V such that every edge connects a vertex in U to one in V.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (1, 7), (2, 3), (3, 5), (4, 6), (4, 8), (7, 8)], n = 9]\r\nOutput: true\r\nExplanation: The graph is a bipartite as it can be divided it into two sets, U (0, 2, 4, 5, 7) and V (1, 3, 6, 8), with every edge having one endpoint in set U and the other in set V.\r\n\r\nIf we add edge 1 \u00e2\u0080\u0094> 3, the graph becomes non-bipartite.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (1, 3), (1, 7), (2, 3), (3, 5), (4, 6), (4, 8), (7, 8)], n = 9]\r\nOutput: false\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The graph is connected, i.e., every node can be reached starting from all other nodes.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Connected Graph",
    "link": "https://www.techiedelight.com/?problem=IsConnectedGraph",
    "category": "Graph",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/IsConnectedGraph/IsConnectedGraph.java",
    "problem": "/* START *//*\r\n\r\nGiven an undirected graph, determine whether it is connected or not. A graph is said to be connected when a path exists between every pair of vertices in the graph.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 3), (3, 5), (4, 1)], n = 6]\r\nOutput: true\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 3), (3, 5), (4, 6), (4, 8), (7, 8)], n = 9]\r\nOutput: false\r\n\r\nInput: Graph [edges = [(0, 1), (1, 3), (2, 3), (3, 5)], n = 6]\r\nOutput: false\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Acyclic Connected Graph",
    "link": "https://www.techiedelight.com/?problem=IsAcyclicConnectedGraph",
    "category": "Graph",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/IsAcyclicConnectedGraph/IsAcyclicConnectedGraph.java",
    "problem": "/* START *//*\r\n\r\nGiven an undirected graph, check if it is a tree or not. In other words, check if a given undirected graph is an Acyclic Connected Graph or not.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)], n = 6]\r\nOutput: true\r\nExplanation: Graph is connected and has no cycles.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)], n = 6]\r\nOutput: false\r\nExplanation: Graph contains cycle [0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 0].\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The graph is connected, i.e., every node can be reached starting from all other nodes.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is DAG",
    "link": "https://www.techiedelight.com/?problem=IsDAG",
    "category": "Graph",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/IsDAG/IsDAG.java",
    "problem": "/* START *//*\r\n\r\nGiven a directed graph, check if it is a DAG (Directed Acyclic Graph) or not. A DAG is a digraph (directed graph) that contains no cycles.\r\n\r\nInput: Graph [edges = [(0, 1), (0, 3), (1, 2), (1, 3), (3, 2), (3, 4), (3, 0), (5, 6), (6, 3)], n = 7]\r\nOutput: false\r\nExplanation: The graph contains a cycle [0 -> 1 -> 3 -> 0].\r\n\r\nIf we remove edge [3 -> 0] from it, it will become a DAG.\r\n\r\nInput: Graph [edges = [(0, 1), (0, 3), (1, 2), (1, 3), (3, 2), (3, 4), (5, 6), (6, 3)], n = 7]\r\nOutput: true\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Topological Sort",
    "link": "https://www.techiedelight.com/?problem=TopologicalSort",
    "category": "Graph",
    "tag": "Algorithm, Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TopologicalSort/TopologicalSort.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of edges of a directed acyclic graph (DAG), return its topological order using topological sort algorithm. If the graph has more than one topological ordering, return any of them.\r\n\r\nInput: edges = [(0, 1), (0, 2)]\r\nOutput: [0, 1, 2] or [0, 2, 1]\r\n\r\nInput: edges = [(0, 6), (1, 2), (1, 4), (1, 6), (3, 0), (3, 4), (5, 1), (7, 0), (7, 1)]\r\nOutput: [3, 5, 7, 0, 1, 2, 4, 6], or any other valid topological ordering like,\r\n\r\n[3, 5, 7, 0, 1, 2, 6, 4]\r\n[3, 5, 7, 0, 1, 4, 2, 6]\r\n[3, 5, 7, 0, 1, 4, 6, 2]\r\n[3, 5, 7, 0, 1, 6, 2, 4]\r\n[3, 5, 7, 0, 1, 6, 4, 2]\r\n[3, 5, 7, 1, 0, 2, 4, 6]\r\n[3, 5, 7, 1, 0, 2, 6, 4]\r\n\u00e2\u0080\u00a6\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100.\r\n\u00e2\u0080\u00a2 There are no cycles in the graph.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Root Vertex in Graph",
    "link": "https://www.techiedelight.com/?problem=RootVertexInGraph",
    "category": "Graph",
    "tag": "Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RootVertexInGraph/RootVertexInGraph.java",
    "problem": "/* START *//*\r\n\r\nGiven a directed graph, return its root vertex. A root vertex of a directed graph is a vertex u with a directed path from u to v for every pair of vertices (u, v) in the graph. In other words, all other vertices in the graph can be reached from the root vertex.\r\n\r\nA graph can have multiple root vertices. For example, each vertex in a strongly connected component is a root vertex. In such cases, the solution should return anyone of them. If the graph has no root vertices, the solution should return -1.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 3), (3, 0), (4, 3), (4, 5), (5, 0)], n = 6]\r\nOutput: 4\r\nExplanation: The root vertex is 4 since it has a path to every other vertex in the graph.\r\n\r\nInput: Graph [edges = [(0, 1), (0, 5), (1, 2), (2, 3), (4, 5)], n = 6]\r\nOutput: -1\r\nExplanation: The root vertex doesn't exist in the graph.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Connectivity Matrix",
    "link": "https://www.techiedelight.com/?problem=ConnectivityMatrix",
    "category": "Graph, Matrix",
    "tag": "Algorithm, Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ConnectivityMatrix/ConnectivityMatrix.java",
    "problem": "/* START *//*\r\n\r\nThe transitive closure for a digraph G is a digraph G\u00e2\u0080\u0099 with an edge (i, j) corresponding to each directed path from i to j in G. The resultant digraph G\u00e2\u0080\u0099 representation in the form of the adjacency matrix is called the connectivity matrix.\r\n\r\nGiven a directed graph, return its connectivity matrix. The value of a cell C[i][j] in connectivity matrix C is 1 only if a directed path exists from vertex i to vertex j.\r\n\r\nInput: Graph [edges = [(0, 2), (1, 0), (3, 1)], n = 4]\r\nOutput: [\r\n\t[1, 0, 1, 0],\r\n\t[1, 1, 1, 0],\r\n\t[0, 0, 1, 0],\r\n\t[1, 1, 1, 1]\r\n]\r\n\r\nNote that all diagonal elements in the connectivity matrix are 1 since a path exists from every vertex to itself.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Bridges in Graph",
    "link": "https://www.techiedelight.com/?problem=BridgesInGraph",
    "category": "Graph",
    "tag": "Algorithm, Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/BridgesInGraph/BridgesInGraph.java",
    "problem": "/* START *//*\r\n\r\nGiven an undirected connected graph, return a set of all bridges in the graph. A bridge is an edge of a graph whose removal disconnects the graph.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 3)], n = 4]\r\nOutput: {(0, 1), (1, 2), (2, 3)}\r\nExplanation: The graph has 3 bridges {(0, 1), (1, 2), (2, 3)}, since removal of any of it disconnects the graph.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 3), (3, 0)], n = 4]\r\nOutput: {}\r\nExplanation: The graph is 2\u00e2\u0080\u0093edge connected. i.e., it remains connected on removal of any edge.\r\n\r\nNote: The solution should return edges in increasing order of node's value. For instance, both (1, 2) and (2, 1) represent the same edge in an undirected graph. The solution should return edge (1, 2).\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The graph is connected, i.e., every node can be reached starting from all other nodes.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "K Colorable Graph",
    "link": "https://www.techiedelight.com/?problem=KColorableGraph",
    "category": "Backtracking, Graph",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/KColorableGraph/KColorableGraph.java",
    "problem": "/* START *//*\r\n\r\nGiven an undirected graph and a positive integer k, check if the graph is k\u00e2\u0080\u0093colorable or not.\r\n\r\nThe vertex coloring is a way of coloring the vertices of a graph such that no two adjacent vertices share the same color. A coloring using at most k colors is called a (proper) k\u00e2\u0080\u0093coloring, and a graph that can be assigned a (proper) k\u00e2\u0080\u0093coloring is k\u00e2\u0080\u0093colorable.\r\n\r\nInput: Graph [edges = [(0, 1), (0, 4), (0, 5), (4, 5), (1, 4), (1, 3), (2, 3), (2, 4)], n = 6], k = 3\r\n\r\n 0 \u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080 1 \u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080 2\r\n \u00e2\u0094\u0082 \\\t \u00e2\u0094\u0082  \\   / \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082   \\   \u00e2\u0094\u0082\t  X   \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082\t   \\ \u00e2\u0094\u0082  /   \\ \u00e2\u0094\u0082\r\n 5 \u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080 4 \u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080 3\r\n\r\nOutput: true\r\n\r\nExplanation: The graph can be colored using 3 colors in several ways as shown below. However, the graph is not 2\u00e2\u0080\u0093colorable.\r\n\r\n \u00e2\u0094\u008c\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0090\r\n \u00e2\u0094\u0082  #0  \u00e2\u0094\u0082  #1  \u00e2\u0094\u0082  #2  \u00e2\u0094\u0082  #3  \u00e2\u0094\u0082  #4  \u00e2\u0094\u0082  #5  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0082\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0082\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0082\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0082\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0082\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082  C3  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C1  \u00e2\u0094\u0082  C2  \u00e2\u0094\u0082\r\n \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0098\r\n\r\n\r\nInput: Graph [edges = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)], n = 4], k = 3\r\n\r\n 0 \u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080 1\r\n \u00e2\u0094\u0082 \\   / \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082   X   \u00e2\u0094\u0082\r\n \u00e2\u0094\u0082 /   \\ \u00e2\u0094\u0082\r\n 2 \u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080 3\r\n\r\nOutput: false\r\nExplanation: The graph cannot be colored using 3 colors. The graph is 4\u00e2\u0080\u0093colorable.\r\n\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The graph is connected, i.e., every node can be reached starting from all other nodes.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Graph Coloring",
    "link": "https://www.techiedelight.com/?problem=GraphColoring",
    "category": "Graph",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/GraphColoring/GraphColoring.java",
    "problem": "/* START *//*\r\n\r\nGiven an undirected graph, return the minimum number of colors required to color the graph's vertices such that no two adjacent vertices share the same color.\r\n\r\nInput: Graph [edges = [(0, 1), (0, 4), (0, 5), (4, 5), (1, 4), (1, 3), (2, 3), (2, 4)], n = 6]\r\nOutput: 3\r\nExplanation: The graph can be colored in many ways by using the minimum of 3 colors. For example, assign color 1 to vertices [0, 2], color 2 to vertices [3, 4], and color 3 to vertices [1, 5].\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The graph is connected, i.e., every node can be reached starting from all other nodes.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Strongly Connected Graph",
    "link": "https://www.techiedelight.com/?problem=IsStronglyConnectedGraph",
    "category": "Graph",
    "tag": "Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/IsStronglyConnectedGraph/IsStronglyConnectedGraph.java",
    "problem": "/* START *//*\r\n\r\nGiven a directed graph, determine whether it is strongly connected or not. A directed graph is said to be strongly connected if every vertex is reachable from every other vertex.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 0)], n = 3]\r\nOutput: true\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (0, 2)], n = 3]\r\nOutput: false\r\n\r\nInput: Graph [edges = [(0, 1)], n = 2]\r\nOutput: false\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Detect Cycle in Graph",
    "link": "https://www.techiedelight.com/?problem=DetectCycleInGraph",
    "category": "Graph, Queue",
    "tag": "Algorithm, Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/DetectCycleInGraph/DetectCycleInGraph.java",
    "problem": "/* START *//*\r\n\r\nGiven an undirected graph, determine whether it contains any cycle.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (0, 2)], n = 3]\r\nOutput: true\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 3), (1, 4)], n = 5]\r\nOutput: false\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The graph is connected, i.e., every node can be reached starting from all other nodes.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Least Cost Path",
    "link": "https://www.techiedelight.com/?problem=LeastCostPath",
    "category": "Graph, Queue",
    "tag": "Breadth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LeastCostPath/LeastCostPath.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of edges of a weighted directed graph where each edge weight can be one of x, 2x, or 3x (x is a positive integer) and two vertices - source and destination, efficiently compute the least-cost path from the source vertex to the destination vertex and return the least cost.\r\n\r\nInput: edges = [(0, 1, 3), (0, 4, 1), (1, 2, 1), (1, 3, 3), (1, 4, 1), (4, 2, 2), (4, 3, 1)], src = 0, dest = 2\r\nOutput: 3\r\nExplanation: Edge (x, y, w) represents an edge from x to y having weight w. The least-cost path from source to destination is [0, 4, 2] having cost 3.\r\n\r\nInput: edges = [(0, 1, 3), (0, 4, 1), (1, 2, 1), (1, 3, 3), (1, 4, 1), (4, 2, 2), (4, 3, 1)], src = 1, dest = 3\r\nOutput: 2\r\nExplanation: The least-cost path from source to destination is [1, 4, 3] having cost 2.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100.\r\n\u00e2\u0080\u00a2 The destination can be reached from the source.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Least Cost Path II",
    "link": "https://www.techiedelight.com/?problem=LeastCostPathII",
    "category": "Graph",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LeastCostPathII/LeastCostPathII.java",
    "problem": "/* START *//*\r\n\r\nGiven a weighted directed acyclic graph (DAG) and two vertices - source and destination, find the least path cost from the source vertex to the destination vertex.\r\n\r\nInput: Graph [edges = [(0, 6, 2), (1, 2, -4), (1, 4, 1), (1, 6, 8), (3, 0, 3), (3, 4, 5), (5, 1, 2), (7, 0, 6), (7, 1, -1), (7, 3, 4), (7, 5, -4)], n = 8], src = 7, dest = 0\r\nOutput: 6\r\n\r\nNote: Edge (x, y, w) represents an edge from x to y having weight w.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The destination can be reached from the source.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Least Cost Path III",
    "link": "https://www.techiedelight.com/?problem=LeastCostPathIII",
    "category": "Graph, Queue",
    "tag": "Breadth-First Search",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/LeastCostPathIII/LeastCostPathIII.java",
    "problem": "/* START *//*\r\n\r\nGiven a weighted digraph (directed graph), two vertices - source and destination, and a positive number m, find the least-cost path from the source to the destination with exactly m edges and return the least cost.\r\n\r\nInput: Graph [edges = [(0, 6, -1), (0, 1, 5), (1, 6, 3), (1, 5, 5), (1, 2, 7), (2, 3, 8), (3, 4, 10), (5, 2, -1), (5, 3, 9), (5, 4, 1), (6, 5, 2), (7, 6, 9), (7, 1, 6)], n = 8], src = 0, dest = 3, m = 4\r\nOutput: 8\r\nExplanation: The graph has 3 routes from source 0 to destination 3 with 4 edges.\r\n\r\n\u00e2\u0080\u00a2 [0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3] having cost 17\r\n\u00e2\u0080\u00a2 [0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 3] having cost 19\r\n\u00e2\u0080\u00a2 [0 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3] having cost 8\r\n\r\nThe solution should return the least-cost, i.e., 8.\r\n\r\nNote: Edge (x, y, w) represents an edge from x to y having weight w.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The path exists between source and destination with exactly m edges.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Greatest Cost Path",
    "link": "https://www.techiedelight.com/?problem=GreatestCostPath",
    "category": "Graph",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/GreatestCostPath/GreatestCostPath.java",
    "problem": "/* START *//*\r\n\r\nGiven a weighted directed acyclic graph (DAG) and two vertices - source and destination, find the greatest cost path from the source vertex to the destination vertex.\r\n\r\nInput: Graph [edges = [(0, 6, 2), (1, 2, -4), (1, 4, 1), (1, 6, 8), (3, 0, 3), (3, 4, 5), (5, 1, 2), (7, 0, 6), (7, 1, -1), (7, 3, 4), (7, 5, -4)], n = 8], src = 7, dest = 2\r\nOutput: -5\r\n\r\nNote: Edge (x, y, w) represents an edge from x to y having weight w.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The destination can be reached from the source.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Is Reachable Vertex",
    "link": "https://www.techiedelight.com/?problem=IsReachableVertex",
    "category": "Backtracking, Graph, Queue",
    "tag": "Breadth-First Search, Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/IsReachableVertex/IsReachableVertex.java",
    "problem": "/* START *//*\r\n\r\nGiven a directed graph and two vertices - source and destination, determine if the destination vertex is reachable from the source vertex. The solution should return true if a path exists from the source vertex to the destination vertex, false otherwise.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 3), (3, 5), (4, 1)], n = 6], src = 4, dest = 5\r\nOutput: true\r\nExplanation: There exist a path [4 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 5] from vertex 4 to vertex 5.\r\n\r\nInput: Graph [edges = [(0, 1), (1, 2), (2, 3), (3, 5), (4, 1)], n = 6], src = 5, dest = 1\r\nOutput: false\r\nExplanation: There is no path from vertex 5 to any other vertex.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The destination can be reached from the source.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Total Paths in Digraph",
    "link": "https://www.techiedelight.com/?problem=TotalPathsInDigraph",
    "category": "Graph, Queue",
    "tag": "Breadth-First Search",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TotalPathsInDigraph/TotalPathsInDigraph.java",
    "problem": "/* START *//*\r\n\r\nGiven a directed graph, two vertices - source and destination, and a positive number m, find the total number of routes to reach the destination vertex from the source vertex with exactly m edges.\r\n\r\nInput: Graph [edges = [(0, 6), (0, 1), (1, 6), (1, 5), (1, 2), (2, 3), (3, 4), (5, 2), (5, 3), (5, 4), (6, 5), (7, 6), (7, 1)], n = 8], src = 0, dest = 3, m = 4\r\nOutput: 3\r\nExplanation: The graph has 3 routes from source 0 to destination 3 with 4 edges.\r\n\r\n0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3\r\n0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 3\r\n0 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3\r\n\r\nNote: Edge (x, y, w) represents an edge from x to y having weight w.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Single Source Shortest Paths",
    "link": "https://www.techiedelight.com/?problem=SingleSourceShortestPaths",
    "category": "Graph, Heap",
    "tag": "Algorithm, Greedy, Priority Queue",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SingleSourceShortestPaths/SingleSourceShortestPaths.java",
    "problem": "/* START *//*\r\n\r\nGiven a weighted directed graph with non-negative edge weights and a source vertex, return the shortest path cost from the source vertex to every other reachable vertex in the graph.\r\n\r\nInput: Graph [edges = [(0, 1, 10), (0, 4, 3), (1, 2, 2), (1, 4, 4), (2, 3, 9), (3, 2, 7), (4, 1, 1), (4, 2, 8), (4, 3, 2)], n = 5], source = 0\r\nHere, triplet (x, y, w) represents an edge from x to y having weight w.\r\n\r\nOutput: {[0, 1, 4], [0, 2, 6], [0, 3, 5], [0, 4, 3]}\r\nHere, triplet (s, d, c) indicates that the shortest path from source s to destination d has cost c.\r\n\r\nExplanation:\r\n\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 1) is [0 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 1] with cost 4.\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 2) is [0 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 2] with cost 6.\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 3) is [0 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3] with cost 5.\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 4) is [0 \u00e2\u0080\u0094> 4] with cost 3.\r\n\r\nInput: Graph [edges = [(0, 1, 10), (0, 4, 3), (1, 2, 2), (1, 4, 4), (2, 3, 9), (3, 2, 7), (4, 1, 1), (4, 2, 8), (4, 3, 2)], n = 5], source = 1\r\nOutput: {[1, 2, 2], [1, 3, 6], [1, 4, 4]}\r\nExplanation:\r\n\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 0) does not exist.\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 2) is [1 \u00e2\u0080\u0094> 2] with cost 2.\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 3) is [1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3] with cost 6.\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 4) is [1 \u00e2\u0080\u0094> 4] with cost 4.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The source vertex is among the set of vertices in the graph.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Single Source Shortest Paths II",
    "link": "https://www.techiedelight.com/?problem=SingleSourceShortestPathsII",
    "category": "Dynamic Programming, Graph",
    "tag": "Algorithm, Bottom-up, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SingleSourceShortestPathsII/SingleSourceShortestPathsII.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of edges of a weighted directed graph where its edge weights can be negative, return the shortest path cost from a given source vertex to every other reachable vertex in the graph.\r\n\r\nInput: edges = [(0, 1, -1), (0, 2, 4), (1, 2, 3), (1, 3, 2), (1, 4, 2), (3, 2, 5), (3, 1, 1), (4, 3, -3)], source = 0\r\nHere, tuple (x, y, w) represents an edge from x to y having weight w.\r\n\r\nOutput: {(0, 1, -1), (0, 2, 2), (0, 3, -2), (0, 4, 1)}\r\nHere, tuple (s, d, c) indicates that the shortest path from source s to destination d has cost c.\r\n\r\nExplanation:\r\n\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 1) is [0 \u00e2\u0080\u0094> 1] having cost -1.\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 2) is [0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 2] having cost 2.\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 3) is [0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3] having cost -2.\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 4) is [0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 4] having cost 1.\r\n\r\nInput: edges = [(0, 1, -1), (0, 2, 4), (1, 2, 3), (1, 3, 2), (1, 4, 2), (3, 2, 5), (3, 1, 1), (4, 3, -3)], source = 1\r\nOutput: {(1, 2, 3), (1, 3, -1), (1, 4, 2)}\r\nExplanation:\r\n\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 0) does not exist.\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 2) is [1 \u00e2\u0080\u0094> 2] with cost 3.\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 3) is [1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3] with cost -1.\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 4) is [1 \u00e2\u0080\u0094> 4] with cost 2.\r\n\r\nIf the graph contains a negative-weight cycle, the solution should return an empty set.\r\n\r\nInput: edges = [(0, 2, -2), (1, 0, -4), (2, 3, 2), (3, 1, -1)], source = 1\r\nOutput: {}\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100.\r\n\u00e2\u0080\u00a2 The source vertex is among the set of vertices in the graph.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "All Pairs Shortest Paths",
    "link": "https://www.techiedelight.com/?problem=AllPairsShortestPaths",
    "category": "Dynamic Programming, Graph, Matrix",
    "tag": "Algorithm, Bottom-up, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/AllPairsShortestPaths/AllPairsShortestPaths.java",
    "problem": "/* START *//*\r\n\r\nGiven an adjacency matrix representation of a directed graph where its edge weights can be negative, return the cost matrix containing shortest path weights for every vertex to all other vertices present in the graph.\r\n\r\nInput: Adjacency matrix for the graph\r\n\r\nadj = [\r\n\t[0,   inf, -2,  inf],\r\n\t[4,   0,   3,   inf],\r\n\t[inf, inf, 0,   2],\r\n\t[inf, -1,  inf, 0]\r\n]\r\n\r\nHere, adj[i][j] = c indicates that the edge (i, j) has weight c. If there is no edge from vertex i to vertex j, adj[i][j] = Integer.MAX_VALUE.\r\n\r\nOutput: Cost matrix containing the shortest distance\r\n\r\ncost = [\r\n\t[0, -1, -2, 0],\r\n\t[4,  0,  2, 4],\r\n\t[5,  1,  0, 2],\r\n\t[3, -1,  1, 0]\r\n]\r\n\r\nHere, cost[i][j] = c indicates that the shortest path from the source vertex i to the destination vertex j has cost c.\r\n\r\nExplanation:\r\n\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 1) is [0 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1]\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 2) is [0 \u00e2\u0080\u0094> 2]\r\n\u00e2\u0080\u00a2 Shortest path from (0 \u00e2\u0080\u0094> 3) is [0 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3]\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 0) is [1 \u00e2\u0080\u0094> 0]\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 2) is [1 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 2]\r\n\u00e2\u0080\u00a2 Shortest path from (1 \u00e2\u0080\u0094> 3) is [1 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3]\r\n\u00e2\u0080\u00a2 Shortest path from (2 \u00e2\u0080\u0094> 0) is [2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 0]\r\n\u00e2\u0080\u00a2 Shortest path from (2 \u00e2\u0080\u0094> 1) is [2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1]\r\n\u00e2\u0080\u00a2 Shortest path from (2 \u00e2\u0080\u0094> 3) is [2 \u00e2\u0080\u0094> 3]\r\n\u00e2\u0080\u00a2 Shortest path from (3 \u00e2\u0080\u0094> 0) is [3 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 0]\r\n\u00e2\u0080\u00a2 Shortest path from (3 \u00e2\u0080\u0094> 1) is [3 \u00e2\u0080\u0094> 1]\r\n\u00e2\u0080\u00a2 Shortest path from (3 \u00e2\u0080\u0094> 2) is [3 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 2]\r\n\r\n\r\nIf the graph contains a negative-weight cycle, the solution should return null.\r\n\r\ninput: adj = [\r\n\t[0,   -4, -2,   inf],\r\n\t[-1,  0,   3,   inf],\r\n\t[inf, inf, 0,   2],\r\n\t[inf, -1,  inf, 0]\r\n]\r\n\r\nOutput: null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum Spanning Tree",
    "link": "https://www.techiedelight.com/?problem=MinimumSpanningTree",
    "category": "Graph, Sorting",
    "tag": "Algorithm, Greedy, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumSpanningTree/MinimumSpanningTree.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of edges of a connected and weighted undirected graph, construct a minimum spanning tree (MST) out of it. An MST is a spanning tree of a connected, undirected graph that connects all the vertices with minimal total weighting for its edges.\r\n\r\nInput: edges = [(0, 1, 7), (1, 2, 8), (0, 3, 5), (1, 3, 9), (1, 4, 7), (2, 4, 5), (3, 4, 15), (3, 5, 6), (4, 5, 8), (4, 6, 9), (5, 6, 11)]\r\nHere, tuple (x, y, w) represents an edge from x to y having weight w.\r\n\r\nOutput: {(0, 3, 5), (2, 4, 5), (3, 5, 6), (0, 1, 7), (1, 4, 7), (4, 6, 9)}\r\n\r\nExplanation: The minimum spanning tree will have exactly n-1 edges where n is the total number of vertices in the graph, and the sum of weights of edges is as minimum as possible.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Maximum Cost Path",
    "link": "https://www.techiedelight.com/?problem=MaximumCostPath",
    "category": "Graph, Queue",
    "tag": "Breadth-First Search",
    "lists": "TopLiked",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumCostPath/MaximumCostPath.java",
    "problem": "/* START *//*\r\n\r\nGiven a weighted undirected graph, find the maximum cost path from the given source vertex to any other vertex which is greater than the given cost. The path should not contain any cycles.\r\n\r\nInput: Graph [edges = [(0, 6, 11), (0, 1, 5), (1, 6, 3), (1, 5, 5), (1, 2, 7), (2, 3, -8), (3, 4, 10), (5, 2, -1), (5, 3, 9), (5, 4, 1), (6, 5, 2), (7, 6, 9), (7, 1, 6)], n = 8], source = 0, cost = 50\r\nHere, tuple (x, y, w) represents an edge from x to y having weight w.\r\n\r\nOutput: 51\r\nExplanation: The maximum cost route from the source vertex 0 to any other vertex in the graph is [0 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4]. Its cost is 51 which is more than the given cost 50.\r\n\r\nIf all paths from the source vertex have their costs less than the given cost, the solution should return Integer.MIN_VALUE.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\u00e2\u0080\u00a2 The graph is connected, i.e., every node can be reached starting from all other nodes.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Negative Weight Cycle",
    "link": "https://www.techiedelight.com/?problem=NegativeWeightCycle",
    "category": "Dynamic Programming, Graph, Matrix",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/NegativeWeightCycle/NegativeWeightCycle.java",
    "problem": "/* START *//*\r\n\r\nGiven an adjacency matrix representation of a directed graph whose edge weights can be negative, determine if a negative-weight cycle is present in the graph. A negative-weight cycle is a cycle in a graph whose edges sum to a negative value.\r\n\r\nInput: Adjacency matrix for the graph\r\n\r\nadj = [\r\n\t[0,   inf, -2,  inf],\r\n\t[4,   0,   -3,  inf],\r\n\t[inf, inf, 0,   2],\r\n\t[inf, -1,  inf, 0]\r\n]\r\n\r\nHere, adj[i][j] = c indicates that the edge (i, j) has weight c. If there is no edge from vertex i to vertex j, adj[i][j] = Integer.MAX_VALUE.\r\n\r\nOutput: true\r\n\r\nExplanation: The graph has one negative-weight cycle, [1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1] with sum -2.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Hamiltonian Path",
    "link": "https://www.techiedelight.com/?problem=HamiltonianPath",
    "category": "Backtracking, Graph",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/HamiltonianPath/HamiltonianPath.java",
    "problem": "/* START *//*\r\n\r\nGiven an undirected graph, return all Hamiltonian paths present in it. The Hamiltonian path is a path that visits each vertex exactly once.\r\n\r\nInput: Graph [edges = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)], n = 4]\r\nOutput: {[0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 1, 2], [0, 3, 2, 1], [1, 0, 2, 3], [1, 0, 3, 2], [1, 2, 0, 3], [1, 2, 3, 0], [1, 3, 0, 2], [1, 3, 2, 0], [2, 0, 1, 3], [2, 0, 3, 1], [2, 1, 0, 3], [2, 1, 3, 0], [2, 3, 0, 1], [2, 3, 1, 0], [3, 0, 1, 2], [3, 0, 2, 1], [3, 1, 0, 2], [3, 1, 2, 0], [3, 2, 0, 1], [3, 2, 1, 0]}\r\n\r\nInput: Graph [edges = [(0, 1), (2, 3)], n = 4]\r\nOutput: {}\r\nExplanation: The graph is not connected.\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Eulerian Path",
    "link": "https://www.techiedelight.com/?problem=EulerianPath",
    "category": "Graph",
    "tag": "Algorithm, Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/EulerianPath/EulerianPath.java",
    "problem": "/* START *//*\r\n\r\nGiven an undirected graph, determine whether it has an Eulerian path or not. In other words, check if it is possible to construct a path that visits each edge exactly once.\r\n\r\nInput: Graph [edges = [(0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), (3, 4)], n = 5]\r\nOutput: true\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The graph is implemented using an adjacency list.\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100, i.e., 0 <= n < 100, and each node is represented by its numeric value.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Eulerian Path II",
    "link": "https://www.techiedelight.com/?problem=EulerianPathII",
    "category": "Graph",
    "tag": "Depth-First Search",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/EulerianPathII/EulerianPathII.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of edges of a directed graph, check whether it has an Eulerian path or not. An Eulerian path is a path in a graph that visits every edge exactly once.\r\n\r\nInput: edges = [(0, 1), (1, 2), (2, 3), (3, 1), (1, 4), (4, 3), (3, 0), (0, 5), (5, 4)]\r\nOutput: true\r\nExplanation: The graph has an Eulerian path [0 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 0 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 4] which visits each edge exactly once.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Eulerian Cycle",
    "link": "https://www.techiedelight.com/?problem=EulerianCycle",
    "category": "Graph",
    "tag": "Algorithm, Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/EulerianCycle/EulerianCycle.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of edges of a directed graph, check if it is possible to construct a cycle that visits each edge exactly once, i.e., check whether the graph has an Eulerian cycle or not.\r\n\r\nInput: edges = [(0, 1), (1, 2), (1, 4), (2, 3), (3, 1), (4, 3), (3, 0)]\r\nOutput: true\r\nExplanation: The graph has an Eulerian cycle [0 -> 1 -> 2 -> 3 -> 1 -> 4 -> 3 -> 0]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Factorial",
    "link": "https://www.techiedelight.com/?problem=Factorial",
    "category": "Basic",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/Factorial/Factorial.java",
    "problem": "/* START *//*\r\n\r\nGiven a non-negative number n, return its factorial n! which is the product of all positive integers less than or equal to n.\r\n\r\nInput: n = 5\r\nOutput: 120\r\nExplanation: The value of 5! is 120 as 5! = 1 \u00c3\u0097 2 \u00c3\u0097 3 \u00c3\u0097 4 \u00c3\u0097 5 = 120\r\n\r\nInput: n = 0\r\nOutput: 1\r\nExplanation: The value of 0! is 1\r\n\r\nConstraints: 0 <= n <= 20\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Factorial Series",
    "link": "https://www.techiedelight.com/?problem=FactorialSeries",
    "category": "Basic",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/FactorialSeries/FactorialSeries.java",
    "problem": "/* START *//*\r\n\r\nGiven two non-negative numbers x and y, return the factorial series in the range [x, y].\r\n\r\nThe factorial n! of a non-negative integer n is the product of all positive integers less than or equal to n. There are n! different ways to arrange n distinct objects into a sequence.\r\n\r\nInput: x = 5, y = 10\r\nOutput: [120, 720, 5040, 40320, 362880, 3628800]\r\nExplanation:\r\n\r\nThe factorial of 5 is 120\r\nThe factorial of 6 is 720\r\nThe factorial of 7 is 5040\r\nThe factorial of 8 is 40320\r\nThe factorial of 9 is 362880\r\nThe factorial of 10 is 3628800\r\n\r\nConstraints: 0 <= x <= y <= 20\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Palindrome Number",
    "link": "https://www.techiedelight.com/?problem=PalindromeNumber",
    "category": "Basic",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/PalindromeNumber/PalindromeNumber.java",
    "problem": "/* START *//*\r\n\r\nGiven a non-negative number, determine whether it is a palindrome. A palindromic number is a number that remains the same when its digits are reversed.\r\n\r\nInput: n = 16461\r\nOutput: true\r\nExplanation: 16461 is symmetrical.\r\n\r\nInput: n = 1121\r\nOutput: false\r\nExplanation: 1121 is non-symmetrical.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Primes in Range",
    "link": "https://www.techiedelight.com/?problem=PrimesInRange",
    "category": "",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/PrimesInRange/PrimesInRange.java",
    "problem": "/* START *//*\r\n\r\nGiven a non-negative integer n, return all prime numbers less than or equal to n.\r\n\r\nInput: n = 100\r\nOutput: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Minimum and Maximum Element",
    "link": "https://www.techiedelight.com/?problem=MinimumAndMaximumElement",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/MinimumAndMaximumElement/MinimumAndMaximumElement.java",
    "problem": "/* START *//*\r\n\r\nGiven a non-empty integer array, find the minimum and maximum element in the array by making minimum comparisons, and return the (min, max) element pair.\r\n\r\nInput: [5, 7, 2, 4, 9, 6]\r\nOutput: (2, 9)\r\n\r\nExplanation:\r\n\r\nThe minimum array element is 2\r\nThe maximum array element is 9\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Array",
    "link": "https://www.techiedelight.com/?problem=ReverseArray",
    "category": "Array, Basic, C++, Stack",
    "tag": "Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseArray/ReverseArray.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array, in-place reverse it without using any inbuilt functions.\r\n\r\nInput : [1, 2, 3, 4, 5]\r\nOutput: [5, 4, 3, 2, 1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Greatest Common Divisor",
    "link": "https://www.techiedelight.com/?problem=GreatestCommonDivisor",
    "category": "Algorithm, Recursive",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/GreatestCommonDivisor/GreatestCommonDivisor.java",
    "problem": "/* START *//*\r\n\r\nGiven two integers x and y, find the greatest common divisor (GCD) of x and y. The GCD of two integers, x and y, is largest number that divides both x and y without leaving a remainder.\r\n\r\nInput: x = 30, y = 50\r\nOutput: 10\r\n\r\nInput: x = 2740, y = 1760\r\nOutput: 20\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Bezout Coefficients",
    "link": "https://www.techiedelight.com/?problem=BezoutCoefficients",
    "category": "",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/BezoutCoefficients/BezoutCoefficients.java",
    "problem": "/* START *//*\r\n\r\nGiven two integers x and y, return the coefficients of B\u00c3\u00a9zout's identity, i.e., integers a and b such that xa + yb = GCD(x, y). The GCD of two integers, x and y, is largest number that divides both x and y without leaving a remainder.\r\n\r\nInput: x = 30, y = 50\r\nOutput: (2, -1)\r\nExplanation: x = 2 and y = -1 since 30*2 + 50*-1 = 10\r\n\r\nInput: x = 2740, y = 1760\r\nOutput: (9, -14)\r\nExplanation: x = 9 and y = -14 since 2740*9 + 1760*-14 = 20\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Cubes Sum",
    "link": "https://www.techiedelight.com/?problem=CubesSum",
    "category": "",
    "tag": "Hashing",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/CubesSum/CubesSum.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer n, find all positive numbers less than n that can be represented as the sum of two cubes for at least two different pairs. In other words, find all positive numbers m <= n that can be expressed as m = (a^3 + b^3) = (c^3 + d^3) for distinct a, b, c, d.\r\n\r\nFor example,\r\n\r\nInput: n = 25000\r\nOutput: {1729, 4104, 13832, 20683}\r\nExplanation: For n = 25000, m can be any of 1729, 4104, 13832, or 20683 as these numbers can be represented as the sum of two cubes for two different pairs.\r\n\r\n1729 = 1^3 + 12^3 = 9^3 + 10^3\r\n4104 = 2^3 + 16^3 = 9^3 + 15^3\r\n13832 = 2^3 + 24^3 = 18^3 + 20^3\r\n20683 = 10^3 + 27^3 = 19^3 + 24^3\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Clock Angle Problem",
    "link": "https://www.techiedelight.com/?problem=ClockAngleProblem",
    "category": "Programming Puzzles",
    "tag": "Algorithm",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ClockAngleProblem/ClockAngleProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven time in hh:mm format, calculate and return the shorter angle between the hour and minute hand in an analog clock.\r\n\r\nAssume valid time in 24-hour notation, where hh (0 to 23) is the number of full hours that have passed since midnight, and mm (0 to 59) is the number of minutes that have passed since the last full hour.\r\n\r\nInput: hh = 5, mm = 30\r\nOutput: 15\r\n\r\nInput: hh = 9, mm = 00\r\nOutput: 90\r\n\r\nInput: hh = 21, mm = 00\r\nOutput: 90\r\n\r\nInput: hh = 12, mm = 00\r\nOutput: 0\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Tower of Hanoi Problem",
    "link": "https://www.techiedelight.com/?problem=TowerOfHanoiProblem",
    "category": "Programming Puzzles",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/TowerOfHanoiProblem/TowerOfHanoiProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven n disks of different sizes, find the optimal solution to Tower of Hanoi problem.\r\n\r\nThe Tower of Hanoi is a mathematical puzzle consisting of three rods and n disks of different sizes which can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the smallest at the top, making a conical shape. The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:\r\n\r\n\u00e2\u0080\u00a2 Only one disk can be moved at a time.\r\n\u00e2\u0080\u00a2 Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack, i.e., a disk can only be moved if it is the uppermost disk on a stack.\r\n\u00e2\u0080\u00a2 No disk may be placed on top of a smaller disk.\r\n\r\nThe minimum number of moves required to solve a Tower of Hanoi puzzle is 2^n-1, where n is the total number of disks. Note that the solution with the minimal number of moves is unique.\r\n\r\nFor example,\r\n\r\nInput: n = 2\r\nOutput: [(1, 2), (1, 3), (2, 3)]\r\nExplanation: Let the 2 disks be 'A' and 'B', with disk 'A' being the smallest and at the top. The optimal unique solution is:\r\n\r\nMove disk 'A' from rod 1 \u00e2\u0080\u0094> 2\r\nMove disk 'B' from rod 1 \u00e2\u0080\u0094> 3\r\nMove disk 'A' from rod 2 \u00e2\u0080\u0094> 3\r\n\r\nInput: n = 3\r\nOutput: [(1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3)]\r\nExplanation: Let the 3 disks be 'A', 'B', and 'C', with disk 'A' being the smallest and at the top. The optimal unique solution is:\r\n\r\nMove disk 'A' from rod 1 \u00e2\u0080\u0094> 3\r\nMove disk 'B' from rod 1 \u00e2\u0080\u0094> 2\r\nMove disk 'A' from rod 3 \u00e2\u0080\u0094> 2\r\nMove disk 'C' from rod 1 \u00e2\u0080\u0094> 3\r\nMove disk 'A' from rod 2 \u00e2\u0080\u0094> 1\r\nMove disk 'B' from rod 2 \u00e2\u0080\u0094> 3\r\nMove disk 'A' from rod 1 \u00e2\u0080\u0094> 3\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sort Stack",
    "link": "https://www.techiedelight.com/?problem=SortStack",
    "category": "Stack",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/SortStack/SortStack.java",
    "problem": "/* START *//*\r\n\r\nGiven a stack, in-place sort it without using any inbuilt functions or data structures.\r\n\r\nInput : stack[5, -2, 9, -7, 3], where 3 is the top element\r\nOutput: stack[-7, -2, 3, 5, 9], where 9 is the top element\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Reverse Stack",
    "link": "https://www.techiedelight.com/?problem=ReverseStack",
    "category": "Stack",
    "tag": "Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReverseStack/ReverseStack.java",
    "problem": "/* START *//*\r\n\r\nGiven a stack, in-place reverse it without using only its abstract data type (ADT) standard operations, i.e., push(), pop(), peek(), size(), etc.\r\n\r\nInput : stack [1, 2, 3, 4, 5], where 5 is the top element\r\nOutput: stack [5, 4, 3, 2, 1], where 1 is the top element\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Generate Binary Numbers",
    "link": "https://www.techiedelight.com/?problem=GenerateBinaryNumbers",
    "category": "Bit Manipulation, Queue, String",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/GenerateBinaryNumbers/GenerateBinaryNumbers.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n, efficiently generate binary numbers between 1 and n in linear time.\r\n\r\nInput: n = 10\r\nOutput: {\"1\", \"10\", \"11\", \"100\", \"101\", \"110\", \"111\", \"1000\", \"1001\", \"1010\", \"1011\", \"1100\", \"1101\", \"1110\", \"1111\", \"10000\"}\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Convert Number to Words",
    "link": "https://www.techiedelight.com/?problem=ConvertNumberToWords",
    "category": "C++, Java, Python, String",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ConvertNumberToWords/ConvertNumberToWords.java",
    "problem": "/* START *//*\r\n\r\nGiven a positive number n, return the word representaion of n. Assume that n <= 10000000000.\r\n\r\nInput: n = 99\r\nOutput: 'Ninety Nine'\r\n\r\nInput: n = 1000\r\nOutput: 'One Thousand'\r\n\r\nInput: n = 751076\r\nOutput: 'Seven Lakh, Fifty One Thousand and Seventy Six'\r\n\r\nInput: n = 1000000\r\nOutput: 'Ten Lakh'\r\n\r\nInput: n = 2147483647\r\nOutput: 'Two Billion, Fourteen Crore, Seventy Four Lakh, Eighty Three Thousand, Six Hundred and Forty Seven'\r\n\r\nInput: n = 10000000000\r\nOutput: 'Ten Billion'\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Implement Strstr Function",
    "link": "https://www.techiedelight.com/?problem=ImplementStrstrFunction",
    "category": "String",
    "tag": "Algorithm, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ImplementStrstrFunction/ImplementStrstrFunction.java",
    "problem": "/* START *//*\r\n\r\nGiven a text and a pattern, return the index of the first occurrence of pattern in text and return -1 if pattern is not part of text.\r\n\r\nInput: text = \"ABCABAABCABAC\", pattern = \"ABAA\"\r\nOutput: 3\r\nExplanation: The pattern occurs only once in the text, starting from index 3.\r\n\r\nInput: text = \"ABCABAABCABAC\", pattern = \"CAB\"\r\nOutput: 2\r\nExplanation: The pattern occurs twice in the text, starting from index 2 and 8. The solution should return the index of the first occurrence, i.e., 2.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Shortest Superstring Problem",
    "link": "https://www.techiedelight.com/?problem=ShortestSuperstringProblem",
    "category": "String",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/ShortestSuperstringProblem/ShortestSuperstringProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of strings where no string is a substring of another, find the shortest string that contains each string in the list as a substring.\r\n\r\nInput: [\"CATGC\", \"CTAAGT\", \"GCTA\", \"TTCA\", \"ATGCATC\"]\r\nOutput: \"GCTAAGTTCATGCATC\"\r\nExplanation: \"GCTAAGTTCATGCATC\" is the shortest possible string such that it contains every string in the input list as its substring.\r\n\r\nGCTAAGTT [CATGC] ATC\r\nG [CTAAGT] TCATGCATC\r\n[GCTA] AGTTCATGCATC\r\nGCTAAG [TTCA] TGCATC\r\nGCTAAGTTC [ATGCATC]\r\n\r\nIf multiple superstrings of the minimum length is possible, return any one of them.\r\n\r\nInput: [\"CBC\", \"CC\"]\r\nOutput: \"CBCC\" or \"CCBC\"\r\n\r\n*/\r\n\r\n\r\n"
  },
  {
    "title": "Replace Array Elements II",
    "link": "https://www.techiedelight.com/?problem=ReplaceArrayElementsII",
    "category": "Array, BST",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReplaceArrayElementsII/ReplaceArrayElementsII.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of distinct integers, in-place replace every element with the least greater element on its right or with -1 if there are no greater elements.\r\n\r\nInput : [10, 100, 93, 32, 35, 65, 80, 90, 94, 6]\r\nOutput: [32, -1, 94, 35, 65, 80, 90, 94, -1, -1]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Combinations XI",
    "link": "https://www.techiedelight.com/?problem=CombinationsXI",
    "category": "Array, Binary Tree, String",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/CombinationsXI/CombinationsXI.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of single-digit positive integers, return all possible combinations of words formed by replacing the continuous digits with corresponding character in the English alphabet, i.e., subset [1] can be replaced by A, [2] can be replaced by B, [1, 0] can be replaced by J, [2, 1] can be replaced by U, etc.\r\n\r\nInput: [1, 2, 2]\r\nOutput: [\"ABB\", \"AV\", \"LB\"]\r\nExplanation:\r\n\r\n[1, 2, 2] = \"ABB\"\r\n[1, 22] = \"AV\"\r\n[12, 2] = \"LB\"\r\n\r\nInput: [1, 2, 2, 1]\r\nOutput: [\"ABBA\", \"ABU\", \"AVA\", \"LBA\", \"LU\"]\r\nExplanation:\r\n\r\n[1, 2, 2, 1] = \"ABBA\"\r\n[1, 2, 21] = \"ABU\"\r\n[1, 22, 1] = \"AVA\"\r\n[12, 2, 1] = \"LBA\"\r\n[12, 21] = \"LU\"\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Array V",
    "link": "https://www.techiedelight.com/?problem=RearrangeArrayV",
    "category": "Array, Divide & Conquer, Sorting",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeArrayV/RearrangeArrayV.java",
    "problem": "/* START *//*\r\n\r\nGiven an array of positive and negative integers, in-place segregate them without changing the relative order of elements. The output should contain all positive numbers follow negative numbers while maintaining the same relative ordering.\r\n\r\nInput : [9, -3, 5, -2, -8, -6, 1, 3]\r\nOutput: [-3, -2, -8, -6, 9, 5, 1, 3]\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Ticket Itinerary",
    "link": "https://www.techiedelight.com/?problem=TicketItinerary",
    "category": "Array, Graph",
    "tag": "Hashing, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/TicketItinerary/TicketItinerary.java",
    "problem": "/* START *//*\r\n\r\nGiven a map of departure and arrival airports, find the itinerary in order. It may be assumed that departure is scheduled from every airport except the final destination, and each airport is visited only once, i.e., there are no cycles in the route.\r\n\r\nInput: {'HKG': 'DXB', 'FRA': 'HKG', 'DEL': 'FRA'}\r\nOutput: ['DEL', 'FRA', 'HKG', 'DXB']\r\nExplanation: The input represents the following tickets [HKG \u00e2\u0080\u0094> DXB, FRA \u00e2\u0080\u0094> HKG, DEL \u00e2\u0080\u0094> FRA]. The ticket itinerary is [DEL \u00e2\u0080\u0094> FRA \u00e2\u0080\u0094> HKG \u00e2\u0080\u0094> DXB].\r\n\r\nInput: {'LAX': 'DXB', 'DFW': 'JFK', 'LHR': 'DFW', 'JFK': 'LAX'}\r\nOutput: ['LHR', 'DFW', 'JFK', 'LAX', 'DXB']\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Snake and Ladder Problem",
    "link": "https://www.techiedelight.com/?problem=SnakeAndLadderProblem",
    "category": "Graph, Queue",
    "tag": "Algorithm, Breadth-First Search",
    "lists": "TopClassic, TopLiked",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/SnakeAndLadderProblem/SnakeAndLadderProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a 10 x 10 board of snake and ladder game, marked with numbers in the range [1-100], find the minimum number of throws required to win it (reach board #1 to board #100).\r\n\r\nInput: Map of snakes and ladders\r\n\r\nLadder = {80=99, 1=38, 51=67, 4=14, 21=42, 72=91, 9=31, 28=84}\r\nSnake = {64=60, 17=7, 98=79, 54=34, 87=36, 93=73, 62=19, 95=75}\r\n\r\nOutput: 7\r\n\r\nExplanation: The game requires at least 7 dice throws to win.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Words",
    "link": "https://www.techiedelight.com/?problem=RearrangeWords",
    "category": "Graph",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeWords/RearrangeWords.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of words, check if the individual words can be rearranged to form a circle. Two words, X and Y, can be put together in a circle if the last character of X is the same as the first character of Y or vice-versa.\r\n\r\nInput: [ANT, OSTRICH, DEER, TURKEY, KANGAROO, TIGER, RABBIT, RAT, TOAD, YAK, HYENA]\r\n\r\nOutput: true\r\n\r\nExplanation: The words can be rearranged as follows to form a circle. Note that, for any pair of consecutive words (X \u00e2\u0086\u0092 Y) in the circle, the last character of the word X is the same as the first character of the word Y.\r\n\r\n   ANT \u00e2\u0086\u0092 TIGER \u00e2\u0086\u0092 RABBIT \u00e2\u0086\u0092 TOAD\r\n\t\u00e2\u0086\u0091\t\t\t\t\t  \u00e2\u0086\u0093\r\n  HYENA\t\t\t\t   DEER\r\n\t\u00e2\u0086\u0091\t\t\t\t\t  \u00e2\u0086\u0093\r\n OSTRICH\t\t\t\t  RAT\r\n\t\u00e2\u0086\u0091\t\t\t\t\t  \u00e2\u0086\u0093\r\n KANGAROO   \u00e2\u0086\u0090  YAK   \u00e2\u0086\u0090   TURKEY\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Palindrome Number II",
    "link": "https://www.techiedelight.com/?problem=PalindromeNumberII",
    "category": "Bit Manipulation",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/PalindromeNumberII/PalindromeNumberII.java",
    "problem": "/* START *//*\r\n\r\nGiven a non-negative number n, check if the binary representation of n is a palindrome. A palindromic number is a number that remains the same when its digits are reversed.\r\n\r\nThe solution should consider the binary representation starting from the LSB (least significant bit) till the last set bit.\r\n\r\nInput: n = 9\r\nOutput: true\r\nExplanation: The binary representation of 9 is 1001, which is symmetric.\r\n\r\nInput: n = 11\r\nOutput: false\r\nExplanation: The binary representation of 11 is 1011, which is not symmetric.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Read Write Conflicts",
    "link": "https://www.techiedelight.com/?problem=ReadWriteConflicts",
    "category": "Array, Sorting",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ReadWriteConflicts/ReadWriteConflicts.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of database transactions, find all read-write conflicts among them. Assume that there is no strict two-phase locking (Strict 2PL) protocol to prevent read-write conflicts.\r\n\r\nEach database transaction is given in the form of a tuple. A tuple (T, A, t, R) indicates that a transaction T accessed a database record A at a time t, and a read operation is performed on the record.\r\n\r\nAssume that a data conflict happens when two transactions access the same record in the database within an interval of 5 units. At least one write operation is performed on the record.\r\n\r\nInput:\r\n\r\ntransactions = [\r\n\t(T1, A, 0, R),\r\n\t(T2, A, 2, W),\r\n\t(T3, B, 4, W),\r\n\t(T4, C, 5, W),\r\n\t(T5, B, 7, R),\r\n\t(T6, C, 8, W),\r\n\t(T7, A, 9, R)\r\n]\r\n\r\nOutput: {(T1, T2, RW), (T3, T5, WR), (T4, T6, WW)}\r\n\r\nExplanation:\r\n\r\n\u00e2\u0080\u00a2 Transaction T1 and T2 are involved in RW conflict.\r\n\u00e2\u0080\u00a2 Transaction T3 and T5 are involved in WR conflict.\r\n\u00e2\u0080\u00a2 Transaction T4 and T6 are involved in WW conflict.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Rearrange Linked List V",
    "link": "https://www.techiedelight.com/?problem=RearrangeLinkedListV",
    "category": "Linked List",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/RearrangeLinkedListV/RearrangeLinkedListV.java",
    "problem": "/* START *//*\r\n\r\nGiven a singly-linked list of integers, rearrange it such that every second node of the linked list is greater than its left and right nodes. In other words, rearrange the linked list node in alternating high-low.\r\n\r\nAssume that no duplicate nodes are present in the linked list. Since several lists might satisfy the constraints, the solution should return any one of them in single traveral of the linked list.\r\n\r\nInput : 1 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\nOutput: 1 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> null\r\n\r\nInput : 9 \u00e2\u0080\u0094> 6 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\nOutput: 6 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 3 \u00e2\u0080\u0094> 8 \u00e2\u0080\u0094> 7 \u00e2\u0080\u0094> null\r\n\r\nInput : 6 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\nOutput: 6 \u00e2\u0080\u0094> 9 \u00e2\u0080\u0094> 2 \u00e2\u0080\u0094> 5 \u00e2\u0080\u0094> 1 \u00e2\u0080\u0094> 4 \u00e2\u0080\u0094> null\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Sink Nodes Binary Tree",
    "link": "https://www.techiedelight.com/?problem=SinkNodesBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/SinkNodesBinaryTree/SinkNodesBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree containing many zero nodes, sink nodes having zero value at the bottom of the subtree rooted at that node. In other words, the resultant binary tree should not contain any node having zero value that is the parent of the node having a non-zero value.\r\n\r\nSince several binary tree might satisfy the constraints, the solution should return any one of them.\r\n\r\nInput:\r\n\r\n\t   0\r\n\t /   \\\r\n\t/\t  \\\r\n   1\t   0\r\n\r\nOutput:\r\n\r\n\t   1\r\n\t /   \\\r\n\t/\t  \\\r\n   0\t   0\r\n\r\nInput:\r\n\r\n\t   1\r\n\t /\t \\\r\n\t/\t  \\\r\n   /\t   \\\r\n  0\t\t\t3\r\n\t\t   / \\\r\n\t \t  /\t  \\\r\n\t\t 4\t   2\r\n\t\t/ \\\r\n\t   /   \\\r\n\t  0\t\t0\r\n\r\nOutput:\r\n\r\n\t   1\r\n\t /\t \\\r\n\t/\t  \\\r\n   /\t   \\\r\n  0\t\t\t4\r\n\t\t   / \\\r\n\t \t  /\t  \\\r\n\t\t 3\t   2\r\n\t\t/ \\\r\n\t   /   \\\r\n\t  0\t\t0\r\n\r\nor any other valid binary tree.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Check Children Sum Property",
    "link": "https://www.techiedelight.com/?problem=CheckChildrenSumProperty",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/CheckChildrenSumProperty/CheckChildrenSumProperty.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, determine if the binary tree holds children-sum property. For a tree to satisfy the children-sum property, each node's value should be equal to the sum of values at its left and right subtree. The value of an empty node is considered as 0.\r\n\r\nInput:\r\n\r\n\t\t  25\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 12\t\t   13\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  7\t\t 5\t6\t   7\r\n\r\nOutput: true\r\n\r\nExplanation: All non-leaf nodes follows the children-sum property, as shown below:\r\n\r\n\t\t  25 (12+13)\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 12 (7+5)  13 (6+7)\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  7\t\t 5\t6\t   7\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Fix Children Sum Property",
    "link": "https://www.techiedelight.com/?problem=FixChildrenSumProperty",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/FixChildrenSumProperty/FixChildrenSumProperty.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, fix the children-sum property in the binary tree. For a tree to satisfy the children-sum property, each node's value should be equal to the sum of values at its left and right subtree. The value of an empty node is considered as 0. The only operation allowed is an increment operation on the node's value.\r\n\r\nSince several binary tree might satisfy the constraints, the solution should return any one of them.\r\n\r\nInput:\r\n\r\n\t\t  25\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 8\t\t   10\r\n\t/ \\\t\t  /  \\\r\n   /   \\\t /\t  \\\r\n  4\t\t5\t6\t   7\r\n\r\nOutput:\r\n\r\n\t\t  25\r\n\t\t/\t \\\r\n\t   /\t  \\\r\n\t  /\t\t   \\\r\n\t 12\t\t   13\r\n\t/  \\\t  /  \\\r\n   /\t\\\t /\t  \\\r\n  7\t\t 5\t6\t   7\r\n\r\nor any other valid binary tree.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Ancestor Matrix II",
    "link": "https://www.techiedelight.com/?problem=AncestorMatrixII",
    "category": "Binary Tree, Matrix",
    "tag": "Hashing",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/AncestorMatrixII/AncestorMatrixII.java",
    "problem": "/* START *//*\r\n\r\nGiven an N \u00c3\u0097 N ancestor matrix, whose cell (i, j) has the value true if i is the ancestor of j in a binary tree, construct a binary tree from the ancestor matrix where binary tree nodes are labeled from 0 to N-1.\r\n\r\nPlease note that several binary trees can be constructed out of a single matrix since the ancestor matrix doesn't specify which child is left and which is right. The solution should return any one of them.\r\n\r\nInput: [\r\n\t[0, 0, 0, 0, 0],\r\n\t[1, 0, 0, 0, 0],\r\n\t[0, 0, 0, 1, 0],\r\n\t[0, 0, 0, 0, 0],\r\n\t[1, 1, 1, 1, 0]\r\n]\r\n\r\nOutput: Any one of the following trees\r\n\r\n     4               4              4\r\n   /   \\           /   \\          /   \\\r\n  1     2   OR    2     1    OR  1     2  OR any other valid binary tree\u00e2\u0080\u00a6\r\n /     /         /       \\        \\   /\r\n0     3         3         0        0 3\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Topological Sort II",
    "link": "https://www.techiedelight.com/?problem=TopologicalSortII",
    "category": "Backtracking, Graph",
    "tag": "Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/TopologicalSortII/TopologicalSortII.java",
    "problem": "/* START *//*\r\n\r\nGiven a list of edges of a directed acyclic graph (DAG), return a set of all topological orderings of the graph.\r\n\r\nInput: edges = [(0, 1), (0, 2)]\r\nOutput: {[0, 1, 2], [0, 2, 1]}\r\n\r\nInput: edges = [(0, 2), (1, 2), (2, 3), (2, 4), (3, 4), (3, 5)]\r\nOutput: {[0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 5, 4], [1, 0, 2, 3, 4, 5], [1, 0, 2, 3, 5, 4]}\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The maximum number of nodes in the graph is 100.\r\n\u00e2\u0080\u00a2 There are no cycles in the graph.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "BST to Min Heap",
    "link": "https://www.techiedelight.com/?problem=BSTToMinHeap",
    "category": "BST, Heap, Linked List, Queue",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/BSTToMinHeap/BSTToMinHeap.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary search tree (BST), efficiently convert the BST into a min-heap. The solution should convert the given BST into a complete binary tree where each node has a higher value than its parent's value, using the same set of keys. The output binary tree should satisfy the structural and heap-ordering property of the min-heap data structure.\r\n\r\nInput:\r\n\t\t 5\r\n\t   /   \\\r\n\t  /\t\t\\\r\n\t 3\t\t 8\r\n\t/ \\\t\t/ \\\r\n   /   \\   /   \\\r\n  2\t\t4 6\t   10\r\n\r\nOutput:\r\n\r\n\t\t 2\r\n\t   /   \\\r\n\t  /\t\t\\\r\n\t 3\t\t 4\r\n\t/ \\\t\t/ \\\r\n   /   \\   /   \\\r\n  5\t\t6 8\t   10\r\n\r\nOR, any other valid min-heap.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Box Stacking Problem",
    "link": "https://www.techiedelight.com/?problem=BoxStackingProblem",
    "category": "Array, Dynamic Programming, Sorting",
    "tag": "Algorithm, Bottom-up",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/BoxStackingProblem/BoxStackingProblem.java",
    "problem": "/* START *//*\r\n\r\nGiven a set of rectangular 3D boxes (cuboids), create a stack of boxes as tall as possible and return the maximum height of the stacked boxes.\r\n\r\n\u00e2\u0080\u00a2 A box can be placed on top of another box only if the dimensions of the 2D base of the lower box is each \"strictly\" larger than of the 2D base of the higher box. i.e., box i can be placed on top of box j if and only if length[i] < length[j] and width[i] < width[j].\r\n\r\n\u00e2\u0080\u00a2 The solution can include \"multiple\" instances of the same box, such that a box can be rotated to use any of its sides as the base, and does not have to include the every box to achieve the maximum height.\r\n\r\nFor example,\r\n\r\nInput: [(4, 2, 5), (3, 1, 6), (3, 2, 1), (6, 3, 8)]\r\nOutput: 22\r\nExplanation: Each of the given box has dimensions L \u00c3\u0097 W \u00c3\u0097 H:\r\n\r\n(4 \u00c3\u0097 2 \u00c3\u0097 5)\r\n(3 \u00c3\u0097 1 \u00c3\u0097 6)\r\n(3 \u00c3\u0097 2 \u00c3\u0097 1)\r\n(6 \u00c3\u0097 3 \u00c3\u0097 8)\r\n\r\nThe valid rotations (length more than the width) of the boxes are:\r\n\r\n(4 \u00c3\u0097 2 \u00c3\u0097 5), (5 \u00c3\u0097 4 \u00c3\u0097 2), (5 \u00c3\u0097 2 \u00c3\u0097 4)\r\n(3 \u00c3\u0097 1 \u00c3\u0097 6), (6 \u00c3\u0097 3 \u00c3\u0097 1), (6 \u00c3\u0097 1 \u00c3\u0097 3)\r\n(3 \u00c3\u0097 2 \u00c3\u0097 1), (3 \u00c3\u0097 1 \u00c3\u0097 2), (2 \u00c3\u0097 1 \u00c3\u0097 3)\r\n(6 \u00c3\u0097 3 \u00c3\u0097 8), (8 \u00c3\u0097 6 \u00c3\u0097 3), (8 \u00c3\u0097 3 \u00c3\u0097 6)\r\n\r\nThe maximum height possible is 22, which can be obtained by arranging the boxes in the following order:\r\n\r\n(3 \u00c3\u0097 1 \u00c3\u0097 6)\r\n(4 \u00c3\u0097 2 \u00c3\u0097 5)\r\n(6 \u00c3\u0097 3 \u00c3\u0097 8)\r\n(8 \u00c3\u0097 6 \u00c3\u0097 3)\r\n\r\nNote that (3 \u00c3\u0097 2 \u00c3\u0097 1) box is not included to achieve the maximum height.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Stack",
    "link": "https://www.techiedelight.com/?problem=ConstructStack",
    "category": "Stack",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructStack/ConstructStack.java",
    "problem": "/* START *//*\r\n\r\nYou're given an empty Stack class. Write code to support standard stack operations like push, pop, peek, size, and isEmpty.\r\n\r\n\u00e2\u0080\u00a2 void push(int val): Inserts element 'val' on top of the stack\r\n\u00e2\u0080\u00a2 int pop(): Removes and return the top element from the stack\r\n\u00e2\u0080\u00a2 int peek(): Returns the top element of the stack\r\n\u00e2\u0080\u00a2 int size(): Returns the total number of elements in the stack\r\n\u00e2\u0080\u00a2 bool isEmpty(): Returns true if the stack is empty; false otherwise\r\n\r\nFor example,\r\n\r\nInput: [push(6), push(5), push(7), isEmpty(), size(), peek(), pop(), peek(), pop(), peek(), pop(), isEmpty(), size()]\r\nOutput: [null, null, null, false, 3, 7, 7, 5, 5, 6, 6, true, 0]\r\nExplanation:\r\n\r\nStack s = new Stack();\r\ns.push(6)\r\ns.push(5)\r\ns.push(7)\r\ns.isEmpty() -> false\r\ns.size() -> 3\r\ns.peek() -> 7\r\ns.pop() -> 7\r\ns.peek() -> 5\r\ns.pop() -> 5\r\ns.peek() -> 6\r\ns.pop() -> 6\r\ns.isEmpty() -> true\r\ns.size() -> 0\r\n\r\n\r\nInput: [isEmpty(), push(6), push(7), push(8), push(5), push(3), peek(), pop(), push(10), peek(), pop(), peek(), pop(), isEmpty(), size()]\r\nOutput: [true, null, null, null, null, null, 3, 3, null, 10, 10, 5, 5, false, 3]\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The pop and peek operations will never be called on an empty stack.\r\n\u00e2\u0080\u00a2 The maximum capacity of the stack is 1000.\r\n\r\n*/\r\n\r\nclass Stack\r\n{\r\n\tStack() {\r\n\r\n\t}\r\n\r\n\tpublic void push(int val) {\r\n\r\n\t}\r\n\r\n\tpublic int pop() {\r\n\r\n\t}\r\n\r\n\tpublic int peek() {\r\n\r\n\t}\r\n\r\n\tpublic int size() {\r\n\r\n\t}\r\n\r\n\tpublic boolean isEmpty() {\r\n\r\n\t}\r\n}\r\n/* END */\r\n\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args) throws Exception\r\n\t{\r\n\t\tString line;\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\twhile ((line = reader.readLine()) != null)\r\n\t\t{\r\n\t\t\tStack s = new Stack();\r\n\r\n\t\t\tList<String> seq = new ArrayList<>();\r\n\r\n\t\t\tfor (String _line: line.split(\" # \"))\r\n\t\t\t{\r\n\t\t\t\tString[] tokens = _line.split(\", \");\r\n\t\t\t\tString operation = tokens[0].trim();\r\n\t\t\t\tint output = -1;\r\n\t\t\t\tif (!operation.equals(\"isEmpty\")) {\r\n\t\t\t\t\toutput = Integer.parseInt(tokens[1].trim());\r\n\t\t\t\t}\r\n\t\t\t\tboolean isEmpty = tokens[1].trim().equals(\"Y\");\r\n\r\n\t\t\t\tint actual_output = output;\r\n\t\t\t\tboolean actual_isEmpty = isEmpty;\r\n\r\n\t\t\t\tif (!operation.equals(\"push\")) {\r\n\t\t\t\t\tseq.add(operation + \"()\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (operation.equals(\"push\")) {\r\n\t\t\t\t\tseq.add(operation + \"(\" + output + \")\");\r\n\t\t\t\t\ts.push(output);\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"pop\")) {\r\n\t\t\t\t\tactual_output = s.pop();\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"peek\")) {\r\n\t\t\t\t\tactual_output = s.peek();\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"size\")) {\r\n\t\t\t\t\tactual_output = s.size();\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"isEmpty\")) {\r\n\t\t\t\t\tactual_isEmpty = s.isEmpty();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!operation.equals(\"push\") && (output != actual_output || isEmpty != actual_isEmpty))\r\n\t\t\t\t{\r\n\t\t\t\t\tSystem.out.println(\"Operations \" + seq);\r\n\t\t\t\t\tSystem.out.println(\"\\nFailed for last operation = \" + operation + \"()\");\r\n\t\t\t\t\tif (operation.equals(\"isEmpty\")) {\r\n\t\t\t\t\t\tSystem.out.println(\"\\nExpected output \u00e2\u0080\u0094> \" + isEmpty);\r\n\t\t\t\t\t\tSystem.out.println(\"Your output     \u00e2\u0080\u0094> \" + actual_isEmpty);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tSystem.out.println(\"\\nExpected output \u00e2\u0080\u0094> \" + output);\r\n\t\t\t\t\t\tSystem.out.println(\"Your output     \u00e2\u0080\u0094> \" + actual_output);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tSystem.exit(-1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tSystem.out.println(\"Accepted\");\r\n\t}\r\n}"
  },
  {
    "title": "Construct Queue",
    "link": "https://www.techiedelight.com/?problem=ConstructQueue",
    "category": "Queue",
    "tag": "",
    "lists": "",
    "type": "Easy",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructQueue/ConstructQueue.java",
    "problem": "/* START *//*\r\n\r\nYou're given an empty Queue class. Write code to support standard queue operations like enqueue, dequeue, peek, size, and isEmpty.\r\n\r\n\u00e2\u0080\u00a2 void enqueue(int val): Inserts element 'val' at the rear (right side) of the queue\r\n\u00e2\u0080\u00a2 int dequeue(): Removes and return the element from the front (left side) of the queue\r\n\u00e2\u0080\u00a2 int peek(): Returns the element at the front of the queue without removing it\r\n\u00e2\u0080\u00a2 int size(): Returns the total number of elements in the queue\r\n\u00e2\u0080\u00a2 bool isEmpty(): Returns true if the queue is empty; false otherwise\r\n\r\nFor example,\r\n\r\nInput: [enqueue(6), enqueue(5), enqueue(7), isEmpty(), size(), peek(), dequeue(), peek(), dequeue(), peek(), dequeue(), isEmpty(), size()]\r\nOutput: [null, null, null, false, 3, 7, 7, 5, 5, 6, 6, true, 0]\r\nExplanation:\r\n\r\nQueue s = new Queue()\r\ns.enqueue(6)\r\ns.enqueue(5)\r\ns.enqueue(7)\r\ns.isEmpty() -> false\r\ns.size() -> 3\r\ns.peek() -> 7\r\ns.dequeue() -> 7\r\ns.peek() -> 5\r\ns.dequeue() -> 5\r\ns.peek() -> 6\r\ns.dequeue() -> 6\r\ns.isEmpty() -> true\r\ns.size() -> 0\r\n\r\n\r\nInput: [isEmpty(), enqueue(6), enqueue(7), enqueue(8), enqueue(5), enqueue(3), peek(), dequeue(), enqueue(10), peek(), dequeue(), peek(), dequeue(), isEmpty(), size()]\r\nOutput: [true, null, null, null, null, null, 3, 3, null, 10, 10, 5, 5, false, 3]\r\n\r\nConstraints:\r\n\r\n\u00e2\u0080\u00a2 The dequeue and peek operations will never be called on an empty queue.\r\n\u00e2\u0080\u00a2 The maximum capacity of the queue is 1000.\r\n\r\n*/\r\n\r\nclass Queue\r\n{\r\n\tQueue() {\r\n\r\n\t}\r\n\r\n\tpublic int dequeue() {\r\n\r\n\t}\r\n\r\n\tpublic void enqueue(int val) {\r\n\r\n\t}\r\n\r\n\tpublic int peek() {\r\n\r\n\t}\r\n\r\n\tpublic int size() {\r\n\r\n\t}\r\n\r\n\tpublic boolean isEmpty() {\r\n\r\n\t}\r\n}\r\n/* END */\r\n\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args) throws Exception\r\n\t{\r\n\t\tString line;\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\twhile ((line = reader.readLine()) != null)\r\n\t\t{\r\n\t\t\tQueue s = new Queue();\r\n\r\n\t\t\tList<String> seq = new ArrayList<>();\r\n\r\n\t\t\tfor (String _line: line.split(\" # \"))\r\n\t\t\t{\r\n\t\t\t\tString[] tokens = _line.split(\", \");\r\n\t\t\t\tString operation = tokens[0].trim();\r\n\t\t\t\tint output = -1;\r\n\t\t\t\tif (!operation.equals(\"isEmpty\")) {\r\n\t\t\t\t\toutput = Integer.parseInt(tokens[1].trim());\r\n\t\t\t\t}\r\n\t\t\t\tboolean isEmpty = tokens[1].trim().equals(\"Y\");\r\n\r\n\t\t\t\tint actual_output = output;\r\n\t\t\t\tboolean actual_isEmpty = isEmpty;\r\n\r\n\t\t\t\tif (!operation.equals(\"enqueue\")) {\r\n\t\t\t\t\tseq.add(operation + \"()\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (operation.equals(\"enqueue\")) {\r\n\t\t\t\t\tseq.add(operation + \"(\" + output + \")\");\r\n\t\t\t\t\ts.enqueue(output);\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"dequeue\")) {\r\n\t\t\t\t\tactual_output = s.dequeue();\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"peek\")) {\r\n\t\t\t\t\tactual_output = s.peek();\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"size\")) {\r\n\t\t\t\t\tactual_output = s.size();\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"isEmpty\")) {\r\n\t\t\t\t\tactual_isEmpty = s.isEmpty();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!operation.equals(\"enqueue\") && (output != actual_output || isEmpty != actual_isEmpty))\r\n\t\t\t\t{\r\n\t\t\t\t\tSystem.out.println(\"Operations \" + seq);\r\n\t\t\t\t\tSystem.out.println(\"\\nFailed for last operation = \" + operation + \"()\");\r\n\t\t\t\t\tif (operation.equals(\"isEmpty\")) {\r\n\t\t\t\t\t\tSystem.out.println(\"\\nExpected output \u00e2\u0080\u0094> \" + isEmpty);\r\n\t\t\t\t\t\tSystem.out.println(\"Your output     \u00e2\u0080\u0094> \" + actual_isEmpty);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tSystem.out.println(\"\\nExpected output \u00e2\u0080\u0094> \" + output);\r\n\t\t\t\t\t\tSystem.out.println(\"Your output     \u00e2\u0080\u0094> \" + actual_output);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tSystem.exit(-1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tSystem.out.println(\"Accepted\");\r\n\t}\r\n}"
  },
  {
    "title": "Min Stack",
    "link": "https://www.techiedelight.com/?problem=MinStack",
    "category": "Stack",
    "tag": "",
    "lists": "",
    "type": "Hard",
    "file_url": "https://www.techiedelight.com/practice/template/MinStack/MinStack.java",
    "problem": "/* START *//*\r\n\r\nDesign a stack to support an additional operation that returns the minimum element from the stack in constant time. The stack should continue supporting all other operations like push, pop, top, size, isEmpty, etc., with no degradation in these operations' performance.\r\n\r\nYou're given an empty MinStack class, with following methods:\r\n\r\n\u00e2\u0080\u00a2 void push(int val): Inserts element 'val' on top of the stack\r\n\u00e2\u0080\u00a2 int pop(): Removes and return the top element from the stack\r\n\u00e2\u0080\u00a2 int top(): Returns the top element of the stack\r\n\u00e2\u0080\u00a2 int getMin(): Returns the minimum element from the stack in constant time\r\n\u00e2\u0080\u00a2 int size(): Returns the total number of elements in the stack\r\n\u00e2\u0080\u00a2 bool isEmpty(): Returns true if the stack is empty; false otherwise\r\n\r\nYou may assume that pop, top, and getMin operations will never be called on an empty stack.\r\n\r\nFor example,\r\n\r\nInput: [push(6), getMin(), push(5), getMin(), push(7), getMin(), isEmpty(), size(), top(), pop(), getMin(), top(), pop(), getMin(), top(), pop(), isEmpty(), size()]\r\n\r\nOutput: [null, 6, null, 5, null, 5, false, 3, 7, 7, 5, 5, 5, 6, 6, 6, true, 0]\r\n\r\nExplanation:\r\n\r\nMinStack s = new MinStack()\r\ns.push(6)\r\ns.getMin() -> 6\r\ns.push(5)\r\ns.getMin() -> 5\r\ns.push(7)\r\ns.getMin() -> 5\r\ns.isEmpty() -> false\r\ns.size() -> 3\r\ns.top() -> 7\r\ns.pop() -> 7\r\ns.getMin() -> 5\r\ns.top() -> 5\r\ns.pop() -> 5\r\ns.getMin() -> 6\r\ns.top() -> 6\r\ns.pop() -> 6\r\ns.isEmpty() -> true\r\ns.size() -> 0\r\n\r\nInput: [isEmpty(), push(6), getMin(), push(7), getMin(), push(8), getMin(), push(5), getMin(), push(3), getMin(), top(), pop(), getMin(), push(10), getMin(), top(), pop(), getMin(), top(), pop(), getMin(), isEmpty(), size()]\r\n\r\nOutput: [true, null, 6, null, 6, null, 6, null, 5, null, 3, 3, 3, 5, null, 5, 10, 10, 5, 5, 5, 6, false, 3]\r\n\r\n*/\r\n\r\nclass MinStack\r\n{\r\n\tpublic MinStack() {\r\n\r\n\t}\r\n\r\n\tpublic void push(int val) {\r\n\r\n\t}\r\n\r\n\tpublic int pop() {\r\n\r\n\t}\r\n\r\n\tpublic int top() {\r\n\r\n\t}\r\n\r\n\tpublic int size() {\r\n\r\n\t}\r\n\r\n\tpublic boolean isEmpty() {\r\n\r\n\t}\r\n\r\n\tpublic int getMin() {\r\n\r\n\t}\r\n}\r\n/* END */\r\n\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args) throws Exception\r\n\t{\r\n\t\tString line;\r\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\r\n\t\twhile ((line = reader.readLine()) != null)\r\n\t\t{\r\n\t\t\tMinStack s = new MinStack();\r\n\r\n\t\t\tList<String> seq = new ArrayList<>();\r\n\r\n\t\t\tfor (String _line: line.split(\" # \"))\r\n\t\t\t{\r\n\t\t\t\tString[] tokens = _line.split(\", \");\r\n\t\t\t\tString operation = tokens[0].trim();\r\n\t\t\t\tint output = -1;\r\n\t\t\t\tif (!operation.equals(\"isEmpty\")) {\r\n\t\t\t\t\toutput = Integer.parseInt(tokens[1].trim());\r\n\t\t\t\t}\r\n\t\t\t\tboolean isEmpty = tokens[1].trim().equals(\"Y\");\r\n\r\n\t\t\t\tint actual_output = output;\r\n\t\t\t\tboolean actual_isEmpty = isEmpty;\r\n\r\n\t\t\t\tif (!operation.equals(\"push\")) {\r\n\t\t\t\t\tseq.add(operation + \"()\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (operation.equals(\"push\")) {\r\n\t\t\t\t\tseq.add(operation + \"(\" + output + \")\");\r\n\t\t\t\t\ts.push(output);\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"pop\")) {\r\n\t\t\t\t\tactual_output = s.pop();\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"top\")) {\r\n\t\t\t\t\tactual_output = s.top();\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"getMin\")) {\r\n\t\t\t\t\tactual_output = s.getMin();\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"size\")) {\r\n\t\t\t\t\tactual_output = s.size();\r\n\t\t\t\t}\r\n\t\t\t\telse if (operation.equals(\"isEmpty\")) {\r\n\t\t\t\t\tactual_isEmpty = s.isEmpty();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!operation.equals(\"push\") && (output != actual_output || isEmpty != actual_isEmpty))\r\n\t\t\t\t{\r\n\t\t\t\t\tSystem.out.println(\"Operations \" + seq);\r\n\t\t\t\t\tSystem.out.println(\"\\nFailed for last operation = \" + operation + \"()\");\r\n\t\t\t\t\tif (operation.equals(\"isEmpty\")) {\r\n\t\t\t\t\t\tSystem.out.println(\"\\nExpected output \u00e2\u0080\u0094> \" + isEmpty);\r\n\t\t\t\t\t\tSystem.out.println(\"Your output     \u00e2\u0080\u0094> \" + actual_isEmpty);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tSystem.out.println(\"\\nExpected output \u00e2\u0080\u0094> \" + output);\r\n\t\t\t\t\t\tSystem.out.println(\"Your output     \u00e2\u0080\u0094> \" + actual_output);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tSystem.exit(-1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tSystem.out.println(\"Accepted\");\r\n\t}\r\n}"
  },
  {
    "title": "Maximum Difference Pair III",
    "link": "https://www.techiedelight.com/?problem=MaximumDifferencePairIII",
    "category": "Array",
    "tag": "",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/MaximumDifferencePairIII/MaximumDifferencePairIII.java",
    "problem": "/* START *//*\r\n\r\nGiven an integer array `nums`, find the maximum value of `j-i` such that `nums[j] > nums[i]`.\r\n\r\nFor example,\r\n\r\nInput: nums = [9, 10, 2, 6, 7, 12, 8, 1]\r\nOutput: 5\r\nExplanation: The maximum difference is 5 for i = 0, j = 5\r\n\r\nInput: nums = [9, 2, 1, 6, 7, 3, 8]\r\nOutput: 5\r\nExplanation: The maximum difference is 5 for i = 1, j = 6\r\n\r\nInput: nums = [8, 7, 5, 4, 2, 1]\r\nOutput: -1 (or any other negative number)\r\nExplanation: Array is sorted in decreasing order.\r\n\r\n*/\r\n\r\n"
  },
  {
    "title": "Construct Threaded Binary Tree",
    "link": "https://www.techiedelight.com/?problem=ConstructThreadedBinaryTree",
    "category": "Binary Tree",
    "tag": "Depth-First Search, Recursive",
    "lists": "",
    "type": "Medium",
    "file_url": "https://www.techiedelight.com/practice/template/ConstructThreadedBinaryTree/ConstructThreadedBinaryTree.java",
    "problem": "/* START *//*\r\n\r\nGiven the root of a binary tree, convert it into a single-threaded binary tree. In a single-threaded binary tree, all empty right child pointers in a binary tree point to the in-order successor of the node, if it exists.\r\n\r\nInput: A binary tree with each node containing extra boolean field `isThreaded` (initially set to False).\r\n\r\n          5\r\n        /   \\\r\n       /     \\\r\n      2       7\r\n     / \\     / \\\r\n    /   \\   /   \\\r\n   1     4 6     9\r\n        /       / \\\r\n       /       /   \\\r\n      3       8    10\r\n\r\nOutput: Above binary tree with empty right child points to their inorder successor. i.e,\r\n\r\n\u00e2\u0080\u00a2 Right child of node 1 should point to node 2.\r\n\u00e2\u0080\u00a2 Right child of node 3 should point to node 4.\r\n\u00e2\u0080\u00a2 Right child of node 4 should point to node 5.\r\n\u00e2\u0080\u00a2 Right child of node 6 should point to node 7.\r\n\u00e2\u0080\u00a2 Right child of node 8 should point to node 9.\r\n\r\nAlso, `isThreaded` field is set to true for all nodes having a threaded link. i.e., nodes 1, 3, 4, 6, 8.\r\n\r\nNote: The solution should convert the tree in-place and should not create any new tree nodes.\r\n\r\n*/\r\n\r\n"
  }
]